/*! For license information please see 0ce74438.a1c632ec.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{253:function(e,n,t){"use strict";var r=t(0);n.a=function(){if("undefined"==typeof window)return{width:999,height:999};var e=Object(r.useState)({width:window.innerWidth,height:window.innerHeight}),n=e[0],t=e[1];return Object(r.useEffect)((function(){function e(){t({width:window.innerWidth,height:window.innerHeight})}return window.addEventListener("resize",e),function(){return window.removeEventListener("resize",e)}}),[]),n}},302:function(e,n,t){"use strict";var r;t.d(n,"a",(function(){return r})),function(e){e[e.INIT=0]="INIT",e[e.STARTED=1]="STARTED",e[e.ENDED=2]="ENDED"}(r||(r={}))},303:function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,"b",(function(){return runCoinlibCode})),__webpack_require__.d(__webpack_exports__,"a",(function(){return copyShareUrl}));var _airgap_coinlib_core__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(362),_airgap_coinlib_core__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_airgap_coinlib_core__WEBPACK_IMPORTED_MODULE_0__),typescript__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(363),typescript__WEBPACK_IMPORTED_MODULE_1___default=__webpack_require__.n(typescript__WEBPACK_IMPORTED_MODULE_1__);function replaceAll(e,n,t){return e.split(n).join(t)}var removeImports=function(e){var n=e.split("\n"),t=!0;return n.map((function(e){e.trim().startsWith("import")&&(t=!1);var n=t?e:void 0;return e.indexOf("@airgap/coinlib-core")>=0&&(t=!0),n})).filter((function(e){return!!e})).join("\n")},runCoinlibCode=function runCoinlibCode(rawCode,setOutput){var code=rawCode,output="",appendOutput=function(e){setOutput((output+="\n"+e).trim())},myLog=function(){for(var e,n=arguments.length,t=new Array(n),r=0;r<n;r++)t[r]=arguments[r];(e=console).log.apply(e,["CODE_RUNNER:"].concat(t)),appendOutput(t.map((function(e){return"object"==typeof e?JSON.stringify(e,null,2):e})).join(" "))},runnable;return code=replaceAll(code,"console.log(","progress("),code=removeImports(code),code=typescript__WEBPACK_IMPORTED_MODULE_1__.transpile("({\n      run: async (coinlib: any, progress: any): string => {\n        Object.keys(coinlib).forEach(key => {\n          window[key] = coinlib[key]\n        })\n        return (async () => {\n          window.fetch = () => Promise.reject('FETCH API DISABLED')\n          window.XMLHttpRequest = {}\n\n          "+code+";\n          if (typeof result !== 'undefined') {\n            return result\n          }\n        })()\n      })"),new Promise((function(resolve){try{runnable=eval(code),runnable.run(_airgap_coinlib_core__WEBPACK_IMPORTED_MODULE_0__,myLog).then((function(e){e&&appendOutput("Returned:\n"+JSON.stringify(e,null,2)),resolve(e)})).catch((function(e){console.warn(e),appendOutput(JSON.stringify(e,null,2)),resolve(e)}))}catch(e){appendOutput(e),console.error(e),resolve(e)}}))},copyShareUrl=function(e){var n="https://"+window.location.host+"/playground?code="+btoa(e);navigator.clipboard.writeText(n).catch((function(e){return console.error("Failed to copy to url!",e)}))}},321:function(e,n,t){"use strict";var r=t(3),o=t(0),i=t.n(o),s=t(257),a=[{name:"@airgap/coinlib-core/actions/Action.d.ts",dts:"export declare enum ActionState {\n    READY = 0,\n    EXECUTING = 1,\n    COMPLETED = 2,\n    CANCELLED = 3\n}\nexport declare abstract class Action<Result, Context> {\n    get identifier(): string;\n    readonly context: Context;\n    result?: Result;\n    error?: Error;\n    onComplete?: (result: Result) => Promise<void>;\n    onError?: (error: Error) => Promise<void>;\n    onCancel?: () => Promise<void>;\n    private readonly stateMachine;\n    constructor(context: Context);\n    getState(): ActionState;\n    start(): Promise<void>;\n    cancel(): void;\n    protected abstract perform(): Promise<Result>;\n    protected addValidTransition(from: ActionState, to: ActionState): void;\n    private handleSuccess;\n    private handleError;\n}\n"},{name:"@airgap/coinlib-core/actions/GetKtAccountsAction.d.ts",dts:"import { Action } from './Action';\nexport interface ImportAccoutActionContext {\n    publicKey: string;\n}\nexport declare class ImportAccountAction extends Action<string[], ImportAccoutActionContext> {\n    get identifier(): string;\n    protected perform(): Promise<string[]>;\n}\n"},{name:"@airgap/coinlib-core/actions/LinkedAction.d.ts",dts:"import { Action } from './Action';\nexport declare class LinkedAction<Result, Context> extends Action<Result, void> {\n    private readonly linkedActionType;\n    readonly action: Action<Context, void>;\n    private linkedAction?;\n    constructor(action: Action<Context, void>, linkedActionType: new (context: Context) => Action<Result, Context>);\n    getLinkedAction(): Action<Result, Context> | undefined;\n    protected perform(): Promise<Result>;\n    cancel(): void;\n}\n"},{name:"@airgap/coinlib-core/actions/RepeatableAction.d.ts",dts:"import { Action } from './Action';\nexport declare class RepeatableAction<Result, InnerContext, Context> extends Action<Result, Context> {\n    private readonly actionFactory;\n    private innerAction?;\n    constructor(context: Context, actionFactory: () => Action<Result, InnerContext>);\n    protected perform(): Promise<Result>;\n    cancel(): void;\n}\n"},{name:"@airgap/coinlib-core/actions/SimpleAction.d.ts",dts:"import { Action } from './Action';\nexport declare class SimpleAction<Result> extends Action<Result, void> {\n    get identifier(): string;\n    private readonly promise;\n    constructor(promise: () => Promise<Result>);\n    protected perform(): Promise<Result>;\n}\n"},{name:"@airgap/coinlib-core/actions/StateMachine.d.ts",dts:"export declare class StateMachine<S> {\n    private state;\n    private readonly validTransitions;\n    constructor(initialState: S, validTransitions: Map<S, S[]>);\n    transitionTo(state: S): void;\n    getState(): S;\n    addValidStateTransition(from: S, to: S): void;\n    private canTransitionTo;\n}\n"},{name:"@airgap/coinlib-core/data/KeyPair.d.ts",dts:'/// <reference types="node" />\nexport interface KeyPair {\n    publicKey: Buffer;\n    privateKey: Buffer;\n}\n'},{name:"@airgap/coinlib-core/data/Lazy.d.ts",dts:"export declare class Lazy<T> {\n    private readonly init;\n    private isInitialized;\n    private value?;\n    constructor(init: () => T);\n    get(): T;\n}\n"},{name:"@airgap/coinlib-core/data/RPCBody.d.ts",dts:"export declare class RPCBody {\n    readonly method: string;\n    readonly params: any[];\n    readonly id: number;\n    readonly jsonrpc: string;\n    constructor(method: string, params: any[], id?: number, jsonrpc?: string);\n}\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito/src/forger/interface.d.ts",dts:"import { OperationContents } from '../../../taquito-rpc/src/types';\nexport interface ForgeParams {\n    branch: string;\n    contents: OperationContents[];\n}\nexport declare type ForgeResponse = string;\nexport interface Forger {\n    forge(params: ForgeParams): Promise<ForgeResponse>;\n}\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/michelson/codec.d.ts",dts:"import { Decoder } from '../decoder';\nimport { Uint8ArrayConsumer } from '../uint8array-consumer';\nimport { Encoder } from '../taquito-local-forging';\ndeclare type PrimValue = {\n    prim: string;\n    args?: MichelsonValue[];\n    annots?: string[];\n};\ndeclare type BytesValue = {\n    bytes: string;\n};\ndeclare type StringValue = {\n    string: string;\n};\ndeclare type IntValue = {\n    int: string;\n};\nexport declare type MichelsonValue = PrimValue | BytesValue | StringValue | IntValue | (PrimValue | BytesValue | StringValue | IntValue)[];\nexport declare const isPrim: (value: MichelsonValue) => value is PrimValue;\nexport declare const isBytes: (value: MichelsonValue) => value is BytesValue;\nexport declare const isString: (value: MichelsonValue) => value is StringValue;\nexport declare const isInt: (value: MichelsonValue) => value is IntValue;\nexport declare const scriptEncoder: Encoder<{\n    code: MichelsonValue;\n    storage: MichelsonValue;\n}>;\nexport declare const scriptDecoder: Decoder;\nexport declare const valueEncoder: Encoder<MichelsonValue>;\nexport declare const valueDecoder: Decoder;\nexport declare const extractRequiredLen: (value: Uint8ArrayConsumer, bytesLength?: number) => Uint8Array;\nexport declare const bytesEncoder: Encoder<BytesValue>;\nexport declare const bytesDecoder: Decoder;\nexport declare const stringEncoder: Encoder<StringValue>;\nexport declare const stringDecoder: Decoder;\nexport declare const intEncoder: Encoder<IntValue>;\nexport declare const intDecoder: (value: Uint8ArrayConsumer) => IntValue;\nexport declare const primEncoder: Encoder<PrimValue>;\nexport declare const primDecoder: (value: Uint8ArrayConsumer, preamble: Uint8Array) => Partial<PrimValue>;\nexport declare const encodeAnnots: Encoder<string[]>;\nexport declare const decodeAnnots: Decoder;\nexport {};\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/schema/operation.d.ts",dts:"import { Decoder } from '../decoder';\nimport { Uint8ArrayConsumer } from '../uint8array-consumer';\nexport declare const ManagerOperationSchema: {\n    branch: string;\n    contents: string[];\n};\nexport declare const ActivationSchema: {\n    pkh: string;\n    secret: string;\n};\nexport declare const RevealSchema: {\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    public_key: string;\n};\nexport declare const DelegationSchema: {\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    delegate: string;\n};\nexport declare const TransactionSchema: {\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters: string;\n};\nexport declare const OriginationSchema: {\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    balance: string;\n    delegate: string;\n    script: string;\n};\nexport declare const BallotSchema: {\n    source: string;\n    period: string;\n    proposal: string;\n    ballot: string;\n};\nexport declare const EndorsementSchema: {\n    level: string;\n};\nexport declare const SeedNonceRevelationSchema: {\n    level: string;\n    nonce: string;\n};\nexport declare const ProposalsSchema: {\n    source: string;\n    period: string;\n    proposals: string;\n};\nexport declare const operationEncoder: (encoders: {\n    [key: string]: (val: {}) => string;\n}) => (operation: {\n    kind: string;\n}) => string;\nexport declare const operationDecoder: (decoders: {\n    [key: string]: Decoder;\n}) => (value: Uint8ArrayConsumer) => {\n    kind: string;\n};\nexport declare const schemaEncoder: (encoders: {\n    [key: string]: (val: {}) => string;\n}) => (schema: {\n    [key: string]: string | string[];\n}) => <T extends {\n    [key: string]: any;\n}>(value: T) => string;\nexport declare const schemaDecoder: (decoders: {\n    [key: string]: Decoder;\n}) => (schema: {\n    [key: string]: string | string[];\n}) => (value: Uint8ArrayConsumer) => {};\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/codec.d.ts",dts:"import { Prefix } from '../../../../../@taquito/utils-8.0.1-beta.1/packages/taquito-utils/src/taquito-utils';\nimport { MichelsonValue } from './michelson/codec';\nimport { Uint8ArrayConsumer } from './uint8array-consumer';\nexport declare const prefixEncoder: (prefix: Prefix) => (str: string) => string;\nexport declare const prefixDecoder: (pre: Prefix) => (str: Uint8ArrayConsumer) => any;\nexport declare const tz1Decoder: (str: Uint8ArrayConsumer) => any;\nexport declare const branchDecoder: (str: Uint8ArrayConsumer) => any;\nexport declare const pkhDecoder: (val: Uint8ArrayConsumer) => any;\nexport declare const branchEncoder: (str: string) => string;\nexport declare const tz1Encoder: (str: string) => string;\nexport declare const boolEncoder: (bool: unknown) => string;\nexport declare const proposalEncoder: (proposal: string) => string;\nexport declare const proposalDecoder: (proposal: Uint8ArrayConsumer) => string;\nexport declare const proposalsDecoder: (proposal: Uint8ArrayConsumer) => string[];\nexport declare const proposalsEncoder: (proposals: string[]) => string;\nexport declare const ballotEncoder: (ballot: string) => string;\nexport declare const ballotDecoder: (ballot: Uint8ArrayConsumer) => string;\nexport declare const delegateEncoder: (val: string) => string;\nexport declare const int32Encoder: (val: number | string) => string;\nexport declare const int32Decoder: (val: Uint8ArrayConsumer) => number;\nexport declare const boolDecoder: (val: Uint8ArrayConsumer) => boolean;\nexport declare const delegateDecoder: (val: Uint8ArrayConsumer) => any;\nexport declare const pkhEncoder: (val: string) => string;\nexport declare const publicKeyEncoder: (val: string) => string;\nexport declare const addressEncoder: (val: string) => string;\nexport declare const publicKeyDecoder: (val: Uint8ArrayConsumer) => any;\nexport declare const addressDecoder: (val: Uint8ArrayConsumer) => any;\nexport declare const zarithEncoder: (n: string) => string;\nexport declare const zarithDecoder: (n: Uint8ArrayConsumer) => string;\nexport declare const entrypointDecoder: (value: Uint8ArrayConsumer) => string;\nexport declare const parametersDecoder: (val: Uint8ArrayConsumer) => {\n    entrypoint: string;\n    value: string | number | {} | undefined;\n} | undefined;\nexport declare const entrypointEncoder: (entrypoint: string) => string;\nexport declare const parametersEncoder: (val: {\n    entrypoint: string;\n    value: MichelsonValue;\n}) => string;\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/constants.d.ts",dts:'export declare const ENTRYPOINT_MAX_LENGTH = 31;\nexport declare enum CODEC {\n    SECRET = "secret",\n    RAW = "raw",\n    TZ1 = "tz1",\n    BRANCH = "branch",\n    ZARITH = "zarith",\n    PUBLIC_KEY = "public_key",\n    PKH = "pkh",\n    DELEGATE = "delegate",\n    SCRIPT = "script",\n    BALLOT_STATEMENT = "ballotStmt",\n    PROPOSAL = "proposal",\n    PROPOSAL_ARR = "proposalArr",\n    INT32 = "int32",\n    PARAMETERS = "parameters",\n    ADDRESS = "address",\n    OPERATION = "operation",\n    OP_ACTIVATE_ACCOUNT = "activate_account",\n    OP_DELEGATION = "delegation",\n    OP_TRANSACTION = "transaction",\n    OP_ORIGINATION = "origination",\n    OP_BALLOT = "ballot",\n    OP_ENDORSEMENT = "endorsement",\n    OP_SEED_NONCE_REVELATION = "seed_nonce_revelation",\n    OP_REVEAL = "reveal",\n    OP_PROPOSALS = "proposals",\n    MANAGER = "manager"\n}\nexport declare const opMapping: {\n    [key: string]: string;\n};\nexport declare const opMappingReverse: {\n    [key: string]: string;\n};\nexport declare const kindMapping: {\n    [key: number]: string;\n};\nexport declare const kindMappingReverse: {\n    [key: string]: string;\n};\nexport declare const entrypointMapping: {\n    [key: string]: string;\n};\nexport declare const entrypointMappingReverse: {\n    [key: string]: string;\n};\n'},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/decoder.d.ts",dts:"import { Uint8ArrayConsumer } from './uint8array-consumer';\nexport declare type Decoder = (val: Uint8ArrayConsumer) => string | number | {} | undefined;\nexport declare const decoders: {\n    [key: string]: Decoder;\n};\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/encoder.d.ts",dts:"export declare type Encoder<T> = (val: T) => string;\nexport declare const encoders: {\n    [key: string]: Encoder<any>;\n};\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/taquito-local-forging.d.ts",dts:"import { ForgeParams, Forger } from '../../taquito/src/forger/interface';\nimport { CODEC } from './constants';\nexport { CODEC } from './constants';\nexport * from './decoder';\nexport * from './encoder';\nexport * from './uint8array-consumer';\nexport declare function getCodec(codec: CODEC): {\n    encoder: import(\"./encoder\").Encoder<any>;\n    decoder: (hex: string) => any;\n};\nexport declare class LocalForger implements Forger {\n    private codec;\n    forge(params: ForgeParams): Promise<string>;\n    parse(hex: string): Promise<ForgeParams>;\n}\nexport declare const localForger: LocalForger;\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/uint8array-consumer.d.ts",dts:"export declare class Uint8ArrayConsumer {\n    private readonly arr;\n    private offset;\n    static fromHexString(hex: string): Uint8ArrayConsumer;\n    constructor(arr: Uint8Array, offset?: number);\n    consume(count: number): Uint8Array;\n    get(idx: number): number;\n    length(): number;\n}\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-local-forging/src/utils.d.ts",dts:"export declare const concat: (...arr: Uint8Array[]) => Uint8Array;\nexport declare const toHexString: (bytes: Uint8Array) => string;\nexport declare const pad: (num: number, paddingLen?: number) => string;\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-rpc/src/opkind.d.ts",dts:'export declare enum OpKind {\n    ORIGINATION = "origination",\n    DELEGATION = "delegation",\n    REVEAL = "reveal",\n    TRANSACTION = "transaction",\n    ACTIVATION = "activate_account",\n    ENDORSEMENT = "endorsement",\n    SEED_NONCE_REVELATION = "seed_nonce_revelation",\n    DOUBLE_ENDORSEMENT_EVIDENCE = "double_endorsement_evidence",\n    DOUBLE_BAKING_EVIDENCE = "double_baking_evidence",\n    PROPOSALS = "proposals",\n    BALLOT = "ballot"\n}\n'},{name:"@airgap/coinlib-core/dependencies/src/@taquito/local-forging-8.0.1-beta.1/packages/taquito-rpc/src/types.d.ts",dts:"import BigNumber from '../../../../../bignumber.js-9.0.0/bignumber';\nimport { OpKind } from './opkind';\nexport declare type BalanceResponse = BigNumber;\nexport declare type StorageResponse = ScriptedContracts['storage'];\nexport declare type ScriptResponse = ScriptedContracts;\nexport declare type BigMapGetResponse = MichelsonV1Expression;\nexport declare type ManagerResponse = {\n    manager: string;\n};\nexport declare type ManagerKeyResponse = string | {\n    key: string;\n};\nexport declare type DelegateResponse = string | null;\nexport declare type OperationHash = string;\nexport interface DelegatesResponse {\n    balance: BigNumber;\n    frozen_balance: BigNumber;\n    frozen_balance_by_cycle: Frozenbalancebycycle[];\n    staking_balance: BigNumber;\n    delegated_contracts: string[];\n    delegated_balance: BigNumber;\n    deactivated: boolean;\n    grace_period: number;\n}\ninterface Frozenbalancebycycle {\n    cycle: number;\n    deposit: BigNumber;\n    fees: BigNumber;\n    rewards: BigNumber;\n}\nexport declare type BigMapKey = {\n    key: {\n        [key: string]: string;\n    };\n    type: {\n        prim: string;\n    };\n};\nexport interface BlockFullHeader {\n    level: number;\n    proto: number;\n    predecessor: string;\n    timestamp: TimeStampMixed;\n    validation_pass: number;\n    operations_hash: string;\n    fitness: string[];\n    context: string;\n    priority: number;\n    proof_of_work_nonce: string;\n    seed_nonce_hash?: string;\n    signature: string;\n}\nexport declare type InlinedEndorsementKindEnum = OpKind.ENDORSEMENT;\nexport interface InlinedEndorsementContents {\n    kind: InlinedEndorsementKindEnum;\n    level: number;\n}\nexport interface InlinedEndorsement {\n    branch: string;\n    operations: InlinedEndorsementContents;\n    signature?: string;\n}\nexport declare type OperationContentsBallotEnum = 'nay' | 'yay' | 'pass';\nexport interface OperationContentsEndorsement {\n    kind: OpKind.ENDORSEMENT;\n    level: number;\n}\nexport interface OperationContentsRevelation {\n    kind: OpKind.SEED_NONCE_REVELATION;\n    level: number;\n    nonce: string;\n}\nexport interface OperationContentsDoubleEndorsement {\n    kind: OpKind.DOUBLE_ENDORSEMENT_EVIDENCE;\n    op1: InlinedEndorsement;\n    op2: InlinedEndorsement;\n}\nexport interface OperationContentsDoubleBaking {\n    kind: OpKind.DOUBLE_BAKING_EVIDENCE;\n    bh1: BlockFullHeader;\n    bh2: BlockFullHeader;\n}\nexport interface OperationContentsActivateAccount {\n    kind: OpKind.ACTIVATION;\n    pkh: string;\n    secret: string;\n}\nexport interface OperationContentsProposals {\n    kind: OpKind.PROPOSALS;\n    source: string;\n    period: number;\n    proposals: string[];\n}\nexport interface OperationContentsBallot {\n    kind: OpKind.BALLOT;\n    source: string;\n    period: number;\n    proposal: string;\n    ballot: OperationContentsBallotEnum;\n}\nexport interface OperationContentsReveal {\n    kind: OpKind.REVEAL;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    public_key: string;\n}\nexport interface OperationContentsTransaction {\n    kind: OpKind.TRANSACTION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters?: TransactionOperationParameter;\n}\nexport interface OperationContentsOrigination {\n    kind: OpKind.ORIGINATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    balance: string;\n    delegate?: string;\n    script?: ScriptedContracts;\n}\nexport interface OperationContentsDelegation {\n    kind: OpKind.DELEGATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    delegate?: string;\n}\nexport declare type OperationContents = OperationContentsEndorsement | OperationContentsRevelation | OperationContentsDoubleEndorsement | OperationContentsDoubleBaking | OperationContentsActivateAccount | OperationContentsProposals | OperationContentsBallot | OperationContentsReveal | OperationContentsTransaction | OperationContentsOrigination | OperationContentsDelegation;\nexport interface OperationContentsAndResultMetadataExtended {\n    balance_updates: OperationMetadataBalanceUpdates[];\n    delegate: string;\n    slots: number[];\n}\nexport interface OperationContentsAndResultMetadataReveal {\n    balance_updates: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultReveal;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataTransaction {\n    balance_updates: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultTransaction;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadataDelegation {\n    balance_updates: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultDelegation;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport interface OperationContentsAndResultMetadata {\n    balance_updates: OperationMetadataBalanceUpdates[];\n}\nexport interface OperationContentsAndResultEndorsement {\n    kind: OpKind.ENDORSEMENT;\n    level: number;\n    metadata: OperationContentsAndResultMetadataExtended;\n}\nexport interface OperationContentsAndResultRevelation {\n    kind: OpKind.SEED_NONCE_REVELATION;\n    level: number;\n    nonce: string;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultDoubleEndorsement {\n    kind: OpKind.DOUBLE_ENDORSEMENT_EVIDENCE;\n    op1: InlinedEndorsement;\n    op2: InlinedEndorsement;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultDoubleBaking {\n    kind: OpKind.DOUBLE_BAKING_EVIDENCE;\n    bh1: BlockFullHeader;\n    bh2: BlockFullHeader;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultActivateAccount {\n    kind: OpKind.ACTIVATION;\n    pkh: string;\n    secret: string;\n    metadata: OperationContentsAndResultMetadata;\n}\nexport interface OperationContentsAndResultProposals {\n    kind: OpKind.PROPOSALS;\n    source: string;\n    period: number;\n    proposals: string[];\n}\nexport interface OperationContentsAndResultBallot {\n    kind: OpKind.BALLOT;\n    source: string;\n    period: number;\n    proposal: string;\n    ballot: OperationContentsBallotEnum;\n}\nexport interface OperationContentsAndResultReveal {\n    kind: OpKind.REVEAL;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    public_key: string;\n    metadata: OperationContentsAndResultMetadataReveal;\n}\nexport interface OperationContentsAndResultTransaction {\n    kind: OpKind.TRANSACTION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters?: TransactionOperationParameter;\n    metadata: OperationContentsAndResultMetadataTransaction;\n}\nexport interface OperationContentsAndResultDelegation {\n    kind: OpKind.DELEGATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    delegate?: string;\n    metadata: OperationContentsAndResultMetadataDelegation;\n}\nexport declare type OperationContentsAndResult = OperationContentsAndResultEndorsement | OperationContentsAndResultRevelation | OperationContentsAndResultDoubleEndorsement | OperationContentsAndResultDoubleBaking | OperationContentsAndResultActivateAccount | OperationContentsAndResultProposals | OperationContentsAndResultBallot | OperationContentsAndResultReveal | OperationContentsAndResultTransaction | OperationContentsAndResultOrigination | OperationContentsAndResultDelegation;\nexport interface OperationEntry {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    branch: string;\n    contents: (OperationContents | OperationContentsAndResult)[];\n    signature?: string;\n}\nexport interface BlockResponse {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    header: BlockFullHeader;\n    metadata: BlockMetadata;\n    operations: OperationEntry[][];\n}\nexport declare type BakingRightsArgumentsDelegate = string | string[];\nexport declare type BakingRightsArgumentsCycle = number | number[];\nexport declare type BakingRightsArgumentsLevel = number | number[];\nexport interface BakingRightsQueryArguments {\n    level?: BakingRightsArgumentsLevel;\n    cycle?: BakingRightsArgumentsCycle;\n    delegate?: BakingRightsArgumentsDelegate;\n    max_priority?: number;\n    all?: null;\n}\nexport interface BakingRightsResponseItem {\n    level: number;\n    delegate: string;\n    priority: number;\n    estimated_time?: Date;\n}\nexport declare type BakingRightsResponse = BakingRightsResponseItem[];\nexport declare type EndorsingRightsArgumentsDelegate = string | string[];\nexport declare type EndorsingRightsArgumentsCycle = number | number[];\nexport declare type EndorsingRightsArgumentsLevel = number | number[];\nexport interface EndorsingRightsQueryArguments {\n    level?: EndorsingRightsArgumentsLevel;\n    cycle?: EndorsingRightsArgumentsCycle;\n    delegate?: EndorsingRightsArgumentsDelegate;\n}\nexport interface EndorsingRightsResponseItem {\n    level: number;\n    delegate: string;\n    slots: number[];\n    estimated_time?: Date;\n}\nexport declare type EndorsingRightsResponse = EndorsingRightsResponseItem[];\nexport declare type BallotListResponseEnum = 'nay' | 'yay' | 'pass';\nexport interface BallotListResponseItem {\n    pkh: string;\n    ballot: BallotListResponseEnum;\n}\nexport declare type BallotListResponse = BallotListResponseItem[];\nexport interface BallotsResponse {\n    yay: number;\n    nay: number;\n    pass: number;\n}\nexport declare type PeriodKindResponse = 'proposal' | 'testing_vote' | 'testing' | 'promotion_vote';\nexport declare type CurrentProposalResponse = string | null;\nexport declare type CurrentQuorumResponse = number;\nexport interface VotesListingsResponseItem {\n    pkh: string;\n    rolls: number;\n}\nexport declare type VotesListingsResponse = VotesListingsResponseItem[];\nexport declare type ProposalsResponseItem = [string, number];\nexport declare type ProposalsResponse = ProposalsResponseItem[];\nexport interface RawBlockHeaderResponse {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    level: number;\n    proto: number;\n    predecessor: string;\n    timestamp: string;\n    validation_pass: number;\n    operations_hash: string;\n    fitness: string[];\n    context: string;\n    priority: number;\n    proof_of_work_nonce: string;\n    signature: string;\n}\nexport interface BlockHeaderResponse {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    level: number;\n    proto: number;\n    predecessor: string;\n    timestamp: string;\n    validation_pass: number;\n    operations_hash: string;\n    fitness: string[];\n    context: string;\n    priority: number;\n    proof_of_work_nonce: string;\n    signature: string;\n}\nexport interface PackDataParams {\n    data: MichelsonV1Expression;\n    type: MichelsonV1Expression;\n    gas?: BigNumber;\n}\nexport declare type HexString = string;\nexport interface PackDataResponse {\n    packed: HexString;\n    gas?: BigNumber | 'unaccounted';\n}\nexport declare type BigMapResponse = MichelsonV1Expression | MichelsonV1Expression[];\nexport declare type PreapplyParams = OperationObject[];\nexport declare type PreapplyResponse = {\n    contents: OperationContentsAndResult[];\n};\nexport declare type ForgeOperationsParams = Pick<OperationObject, 'branch' | 'contents'>;\nexport declare type TimeStampMixed = Date | string;\nexport declare type BalanceUpdateKindEnum = 'contract' | 'freezer';\nexport declare type BalanceUpdateCategoryEnum = 'rewards' | 'fees' | 'deposits';\nexport interface MichelsonV1ExpressionBase {\n    int?: string;\n    string?: string;\n    bytes?: string;\n}\nexport interface MichelsonV1ExpressionExtended {\n    prim: string;\n    args?: MichelsonV1Expression[];\n    annots?: string[];\n}\nexport declare type MichelsonV1Expression = MichelsonV1ExpressionBase | MichelsonV1ExpressionExtended | MichelsonV1Expression[];\nexport interface ScriptedContracts {\n    code: MichelsonV1Expression[];\n    storage: MichelsonV1Expression;\n}\nexport interface OperationBalanceUpdatesItem {\n    kind: BalanceUpdateKindEnum;\n    category?: BalanceUpdateCategoryEnum;\n    delegate?: string;\n    cycle?: number;\n    contract?: string;\n    change: string;\n}\nexport declare type OperationBalanceUpdates = OperationBalanceUpdatesItem[];\nexport interface OperationObject {\n    branch?: string;\n    contents?: OperationContents[];\n    protocol?: string;\n    signature?: string;\n}\nexport declare type InternalOperationResultKindEnum = OpKind.REVEAL | OpKind.TRANSACTION | OpKind.ORIGINATION | OpKind.DELEGATION;\nexport declare type InternalOperationResultEnum = OperationResultReveal | OperationResultTransaction | OperationResultDelegation | OperationResultOrigination;\nexport interface OperationResultDelegation {\n    status: OperationResultStatusEnum;\n    consumed_gas?: string;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n}\nexport interface ContractBigMapDiffItem {\n    key_hash: string;\n    key: MichelsonV1Expression;\n    value?: MichelsonV1Expression;\n}\nexport declare type ContractBigMapDiff = ContractBigMapDiffItem[];\nexport interface TezosGenericOperationError {\n    kind: string;\n    id: string;\n}\nexport interface OperationResultTransaction {\n    status: OperationResultStatusEnum;\n    storage?: MichelsonV1Expression;\n    big_map_diff?: ContractBigMapDiff;\n    balance_updates?: OperationBalanceUpdates;\n    originated_contracts?: string[];\n    consumed_gas?: string;\n    storage_size?: string;\n    paid_storage_size_diff?: string;\n    allocated_destination_contract?: boolean;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n}\nexport interface OperationResultReveal {\n    status: OperationResultStatusEnum;\n    consumed_gas?: string;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n}\nexport interface TransactionOperationParameter {\n    entrypoint: string;\n    value: MichelsonV1Expression;\n}\nexport interface InternalOperationResult {\n    kind: InternalOperationResultKindEnum;\n    source: string;\n    nonce: number;\n    amount?: string;\n    destination?: string;\n    parameters?: TransactionOperationParameter;\n    public_key?: string;\n    balance?: string;\n    delegate?: string;\n    script?: ScriptedContracts;\n    result: InternalOperationResultEnum;\n}\nexport declare type MetadataBalanceUpdatesKindEnum = 'contract' | 'freezer';\nexport declare type MetadataBalanceUpdatesCategoryEnum = 'rewards' | 'fees' | 'deposits';\nexport interface OperationMetadataBalanceUpdates {\n    kind: MetadataBalanceUpdatesKindEnum;\n    category?: MetadataBalanceUpdatesCategoryEnum;\n    contract?: string;\n    delegate?: string;\n    cycle?: number;\n    change: string;\n}\nexport declare type OperationResultStatusEnum = 'applied' | 'failed' | 'skipped' | 'backtracked';\nexport interface OperationResultOrigination {\n    status: OperationResultStatusEnum;\n    balance_updates?: OperationBalanceUpdates;\n    originated_contracts?: string[];\n    consumed_gas?: string;\n    storage_size?: string;\n    paid_storage_size_diff?: string;\n    errors?: TezosGenericOperationError[];\n    consumed_milligas?: string;\n}\nexport interface OperationContentsAndResultMetadataOrigination {\n    balance_updates: OperationMetadataBalanceUpdates[];\n    operation_result: OperationResultOrigination;\n    internal_operation_results?: InternalOperationResult[];\n}\nexport declare type ConstantsResponse = ConstantsResponseCommon & ConstantsResponseProto007 & ConstantsResponseProto006 & ConstantsResponseProto005 & ConstantsResponseProto004 & ConstantsResponseProto003 & ConstantsResponseProto001And002;\nexport interface ConstantsResponseCommon {\n    proof_of_work_nonce_size: number;\n    nonce_length: number;\n    max_operation_data_length: number;\n    preserved_cycles: number;\n    blocks_per_cycle: number;\n    blocks_per_commitment: number;\n    blocks_per_roll_snapshot: number;\n    blocks_per_voting_period: number;\n    time_between_blocks: BigNumber[];\n    endorsers_per_block: number;\n    hard_gas_limit_per_operation: BigNumber;\n    hard_gas_limit_per_block: BigNumber;\n    proof_of_work_threshold: BigNumber;\n    tokens_per_roll: BigNumber;\n    michelson_maximum_type_size: number;\n    seed_nonce_revelation_tip: BigNumber;\n    block_security_deposit: BigNumber;\n    endorsement_security_deposit: BigNumber;\n    endorsement_reward: BigNumber | BigNumber[];\n    cost_per_byte: BigNumber;\n    hard_storage_limit_per_operation: BigNumber;\n}\nexport interface ConstantsResponseProto007 extends Omit<ConstantsResponseProto006, 'max_revelations_per_block'> {\n    max_anon_ops_per_block?: number;\n}\nexport interface ConstantsResponseProto006 extends Omit<ConstantsResponseProto005, 'block_reward'> {\n    baking_reward_per_endorsement?: BigNumber[];\n}\nexport interface ConstantsResponseProto005 extends ConstantsResponseProto004 {\n    quorum_min?: number;\n    quorum_max?: number;\n    min_proposal_quorum?: number;\n    initial_endorsers?: number;\n    delay_per_missing_endorsement?: BigNumber;\n}\nexport interface ConstantsResponseProto004 extends ConstantsResponseProto003 {\n    test_chain_duration?: BigNumber;\n}\nexport interface ConstantsResponseProto003 extends Omit<ConstantsResponseProto001And002, 'origination_burn'> {\n    origination_size?: number;\n    max_proposals_per_delegate?: number;\n}\nexport interface ConstantsResponseProto001And002 {\n    max_revelations_per_block?: number;\n    origination_burn?: string;\n    block_reward?: BigNumber;\n}\nexport interface ContractResponse {\n    balance: BigNumber;\n    script: ScriptedContracts;\n    counter?: string;\n    delegate?: string;\n}\nexport interface TestChainStatus {\n    status: string;\n}\nexport interface MaxOperationListLength {\n    max_size: number;\n    max_op: number;\n}\nexport interface Level {\n    level: number;\n    level_position: number;\n    cycle: number;\n    cycle_position: number;\n    voting_period: number;\n    voting_period_position: number;\n    expected_commitment: boolean;\n}\nexport interface BlockMetadata {\n    protocol: string;\n    next_protocol: string;\n    test_chain_status: TestChainStatus;\n    max_operations_ttl: number;\n    max_operation_data_length: number;\n    max_block_header_length: number;\n    max_operation_list_length: MaxOperationListLength[];\n    baker: string;\n    level: Level;\n    voting_period_kind: string;\n    nonce_hash?: any;\n    consumed_gas: string;\n    deactivated: any[];\n    balance_updates: OperationBalanceUpdates;\n}\nexport declare type RPCRunOperationParam = {\n    operation: OperationObject;\n    chain_id: string;\n};\nexport declare type RPCRunCodeParam = {\n    script: MichelsonV1ExpressionExtended[];\n    storage: MichelsonV1Expression;\n    input: MichelsonV1Expression;\n    amount: string;\n    chain_id: string;\n    source?: string;\n    payer?: string;\n    gas?: BigNumber;\n    entrypoint?: string;\n    balance?: string;\n};\nexport declare type RunCodeResult = {\n    storage: MichelsonV1Expression;\n    operations: InternalOperationResult[];\n    big_map_diff?: ContractBigMapDiff;\n};\nexport declare type EntrypointsResponse = {\n    entrypoints: {\n        [key: string]: Object;\n    };\n    unreachable?: {\n        path: ('Left' | 'Right')[];\n    };\n};\nexport interface OperationContentsAndResultOrigination {\n    kind: OpKind.ORIGINATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    balance: string;\n    delegate?: string;\n    script?: ScriptedContracts;\n    metadata: OperationContentsAndResultMetadataOrigination;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/utils-8.0.1-beta.1/packages/taquito-utils/src/constants.d.ts",dts:'export declare enum Prefix {\n    TZ1 = "tz1",\n    TZ2 = "tz2",\n    TZ3 = "tz3",\n    KT = "KT",\n    KT1 = "KT1",\n    EDSK2 = "edsk2",\n    SPSK = "spsk",\n    P2SK = "p2sk",\n    EDPK = "edpk",\n    SPPK = "sppk",\n    P2PK = "p2pk",\n    EDESK = "edesk",\n    SPESK = "spesk",\n    P2ESK = "p2esk",\n    EDSK = "edsk",\n    EDSIG = "edsig",\n    SPSIG = "spsig",\n    P2SIG = "p2sig",\n    SIG = "sig",\n    NET = "Net",\n    NCE = "nce",\n    B = "b",\n    O = "o",\n    LO = "Lo",\n    LLO = "LLo",\n    P = "P",\n    CO = "Co",\n    ID = "id",\n    EXPR = "expr",\n    TZ = "TZ"\n}\nexport declare const prefix: {\n    tz1: Uint8Array;\n    tz2: Uint8Array;\n    tz3: Uint8Array;\n    KT: Uint8Array;\n    KT1: Uint8Array;\n    edsk: Uint8Array;\n    edsk2: Uint8Array;\n    spsk: Uint8Array;\n    p2sk: Uint8Array;\n    edpk: Uint8Array;\n    sppk: Uint8Array;\n    p2pk: Uint8Array;\n    edesk: Uint8Array;\n    spesk: Uint8Array;\n    p2esk: Uint8Array;\n    edsig: Uint8Array;\n    spsig: Uint8Array;\n    p2sig: Uint8Array;\n    sig: Uint8Array;\n    Net: Uint8Array;\n    nce: Uint8Array;\n    b: Uint8Array;\n    o: Uint8Array;\n    Lo: Uint8Array;\n    LLo: Uint8Array;\n    P: Uint8Array;\n    Co: Uint8Array;\n    id: Uint8Array;\n    expr: Uint8Array;\n    TZ: Uint8Array;\n};\nexport declare const prefixLength: {\n    [key: string]: number;\n};\n'},{name:"@airgap/coinlib-core/dependencies/src/@taquito/utils-8.0.1-beta.1/packages/taquito-utils/src/taquito-utils.d.ts",dts:"import { Buffer } from '../../../../../buffer-5.6.0/index';\nexport * from './validators';\nexport { prefix, Prefix, prefixLength } from './constants';\n/**\n *\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\n *\n * @param value Value in hex\n */\nexport declare function encodeExpr(value: string): any;\n/**\n *\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\n *\n * @param value Value to base58 encode\n * @param prefix prefix to append to the encoded string\n */\nexport declare function b58cencode(value: string | Uint8Array, prefix: Uint8Array): any;\n/**\n *\n * @description Base58 decode a string and remove the prefix from it\n *\n * @param value Value to base58 decode\n * @param prefix prefix to remove from the decoded string\n */\nexport declare const b58cdecode: (enc: string, prefixArg: Uint8Array) => Uint8Array;\n/**\n *\n * @description Base58 decode a string with predefined prefix\n *\n * @param value Value to base58 decode\n */\nexport declare function b58decode(payload: string): string;\n/**\n *\n * @description Base58 encode a public key using predefined prefix\n *\n * @param value Public Key to base58 encode\n */\nexport declare function encodePubKey(value: string): any;\n/**\n *\n * @description Base58 encode a key according to its prefix\n *\n * @param value Key to base58 encode\n */\nexport declare function encodeKey(value: string): any;\n/**\n *\n * @description Base58 encode a key hash according to its prefix\n *\n * @param value Key to base58 encode\n */\nexport declare function encodeKeyHash(value: string): any;\n/**\n *\n * @description Convert an hex string to a Uint8Array\n *\n * @param hex Hex string to convert\n */\nexport declare const hex2buf: (hex: string) => Uint8Array;\n/**\n *\n * @description Merge 2 buffers together\n *\n * @param b1 First buffer\n * @param b2 Second buffer\n */\nexport declare const mergebuf: (b1: Uint8Array, b2: Uint8Array) => Uint8Array;\n/**\n *\n * @description Flatten a michelson json representation to an array\n *\n * @param s michelson json\n */\nexport declare const mic2arr: (s: any) => any;\n/**\n *\n * @description Convert a buffer to an hex string\n *\n * @param buffer Buffer to convert\n */\nexport declare const buf2hex: (buffer: Buffer) => string;\n"},{name:"@airgap/coinlib-core/dependencies/src/@taquito/utils-8.0.1-beta.1/packages/taquito-utils/src/validators.d.ts",dts:"import { Prefix } from './constants';\nexport declare enum ValidationResult {\n    NO_PREFIX_MATCHED = 0,\n    INVALID_CHECKSUM = 1,\n    INVALID_LENGTH = 2,\n    VALID = 3\n}\nexport declare function isValidPrefix(value: any): value is Prefix;\n/**\n * @description Used to check if an address or a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateAddress } from '@taquito/utils';\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateAddress(pkh)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateAddress(value: any): ValidationResult;\n/**\n * @description Used to check if a chain id is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateChain } from '@taquito/utils';\n * const chainId = 'NetXdQprcVkpaWU'\n * const validation = validateChain(chainId)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateChain(value: any): ValidationResult;\n/**\n * @description Used to check if a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateContractAddress } from '@taquito/utils';\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\n * const validation = validateContractAddress(contractAddress)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateContractAddress(value: any): ValidationResult;\n/**\n * @description Used to check if a key hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateKeyHash } from '@taquito/utils';\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateKeyHash(keyHashWithoutPrefix)\n * console.log(validation)\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\n * ```\n */\nexport declare function validateKeyHash(value: any): ValidationResult;\n/**\n * @description Used to check if a signature is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateSignature } from '@taquito/utils';\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\n * const validation = validateSignature(signature)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validateSignature(value: any): ValidationResult;\n/**\n * @description Used to check if a signature is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validatePublicKey } from '@taquito/utils';\n * const publicKey = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\n * const validation = validatePublicKey(publicKey)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport declare function validatePublicKey(value: any): ValidationResult;\n"},{name:"@airgap/coinlib-core/dependencies/src/eciesjs-0.3.9/src/keys/PrivateKey.d.ts",dts:'/// <reference types="node" />\nimport PublicKey from "./PublicKey";\nexport default class PrivateKey {\n    static fromHex(hex: string): PrivateKey;\n    readonly secret: Buffer;\n    readonly publicKey: PublicKey;\n    constructor(secret?: Buffer);\n    toHex(): string;\n    encapsulate(pub: PublicKey): Buffer;\n    multiply(pub: PublicKey): Buffer;\n    equals(other: PrivateKey): boolean;\n}\n'},{name:"@airgap/coinlib-core/dependencies/src/eciesjs-0.3.9/src/keys/PublicKey.d.ts",dts:'/// <reference types="node" />\nimport PrivateKey from "./PrivateKey";\nexport default class PublicKey {\n    static fromHex(hex: string): PublicKey;\n    readonly uncompressed: Buffer;\n    readonly compressed: Buffer;\n    constructor(buffer: Buffer);\n    toHex(compressed?: boolean): string;\n    decapsulate(priv: PrivateKey): Buffer;\n    equals(other: PublicKey): boolean;\n}\n'},{name:"@airgap/coinlib-core/dependencies/src/eciesjs-0.3.9/src/keys/index.d.ts",dts:'export { default as PrivateKey } from "./PrivateKey";\nexport { default as PublicKey } from "./PublicKey";\n'},{name:"@airgap/coinlib-core/dependencies/src/eciesjs-0.3.9/src/index.d.ts",dts:'/// <reference types="node" />\nimport { aesDecrypt, aesEncrypt, decodeHex, getValidSecret, remove0x } from "./utils";\nexport declare function encrypt(receiverRawPub: string | Buffer, msg: Buffer): Buffer;\nexport declare function decrypt(receiverRawPrv: string | Buffer, msg: Buffer): Buffer;\nexport { PrivateKey, PublicKey } from "./keys";\nexport declare const utils: {\n    aesDecrypt: typeof aesDecrypt;\n    aesEncrypt: typeof aesEncrypt;\n    decodeHex: typeof decodeHex;\n    getValidSecret: typeof getValidSecret;\n    remove0x: typeof remove0x;\n};\n'},{name:"@airgap/coinlib-core/dependencies/src/eciesjs-0.3.9/src/utils.d.ts",dts:'/// <reference types="node" />\nexport declare function remove0x(hex: string): string;\nexport declare function decodeHex(hex: string): Buffer;\nexport declare function getValidSecret(): Buffer;\nexport declare function aesEncrypt(key: Buffer, plainText: Buffer): Buffer;\nexport declare function aesDecrypt(key: Buffer, cipherText: Buffer): Buffer;\n'},{name:"@airgap/coinlib-core/dependencies/src/hd-wallet-js-b216450e56954a6e82ace0aade9474673de5d9d5/src/hd-key.d.ts",dts:"import * as nacl from '../../tweetnacl-1.0.1/nacl';\nexport declare function getMasterKeyFromSeed(seed: any): {\n    privateKey: any;\n    chainCode: any;\n};\nexport declare function deriveChild({ privateKey, chainCode }: {\n    privateKey: any;\n    chainCode: any;\n}, index: any): {\n    privateKey: any;\n    chainCode: any;\n};\nexport declare function getKeyPair(privateKey: any): nacl.SignKeyPair;\nexport declare function derivePathFromKey(path: any, key: any): any;\nexport declare function derivePathFromSeed(path: any, seed: any): any;\n"},{name:"@airgap/coinlib-core/dependencies/src/hd-wallet-js-b216450e56954a6e82ace0aade9474673de5d9d5/src/hd-wallet.d.ts",dts:'export declare function generateHDWallet(seed: any): any;\nexport declare function generateWalletUsingDerivationPath(seed: any, derivationPath?: string): import("../../tweetnacl-1.0.1/nacl").SignKeyPair;\nexport declare function getHDWalletAccounts(wallet: any, accountCount: any): any;\n'},{name:"@airgap/coinlib-core/dependencies/src/hd-wallet-js-b216450e56954a6e82ace0aade9474673de5d9d5/src/index.d.ts",dts:"export * from './hd-wallet';\n"},{name:"@airgap/coinlib-core/errors/coinlib-error.d.ts",dts:'export declare enum Domain {\n    SERIALIZER = "serializer"\n}\nexport declare class CoinlibError extends Error {\n    domain: Domain;\n    code: string;\n    description: string;\n    constructor(domain: Domain, code: string, description?: string);\n}\n'},{name:"@airgap/coinlib-core/errors/index.d.ts",dts:'import { CoinlibError } from \'./coinlib-error\';\nexport declare enum SerializerErrorType {\n    SERIALIZER_VERSION_MISMATCH = "SERIALIZER_VERSION_MISMATCH",\n    PROTOCOL_NOT_SUPPORTED = "PROTOCOL_NOT_SUPPORTED",\n    PROTOCOL_VERSION_MISMATCH = "PROTOCOL_VERSION_MISMATCH",\n    TYPE_NOT_SUPPORTED = "TYPE_NOT_SUPPORTED",\n    INVALID_SCHEMA = "INVALID_SCHEMA",\n    INVALID_SCHEMA_TYPE = "INVALID_SCHEMA_TYPE",\n    INVALID_HEX_STRING = "INVALID_HEX_STRING",\n    INVALID_STRING = "INVALID_STRING",\n    SCHEMA_ALREADY_EXISTS = "SCHEMA_ALREADY_EXISTS",\n    SCHEMA_DOES_NOT_EXISTS = "SCHEMA_DOES_NOT_EXISTS",\n    UNEXPECTED_PAYLOAD = "UNEXPECTED_PAYLOAD",\n    PAYLOAD_TYPE_UNKNOWN = "PAYLOAD_TYPE_UNKNOWN",\n    PAYLOAD_TYPE_MISMATCH = "PAYLOAD_TYPE_MISMATCH",\n    PAYLOAD_TYPE_NOT_SUPPORTED = "PAYLOAD_TYPE_NOT_SUPPORTED",\n    PROPERTY_IS_EMPTY = "PROPERTY_IS_EMPTY",\n    PROPERTY_INVALID = "PROPERTY_INVALID"\n}\nexport declare class SerializerError extends CoinlibError {\n    constructor(code: string, description?: string);\n}\n/**\n * Gets thrown if the serializer version does not match\n */\nexport declare class SerializerVersionMismatch extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the serializer cannot handle the specified coin/protocol\n */\nexport declare class ProtocolNotSupported extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the serializer CAN handle the specified coin/protocol, but not in this version\n */\nexport declare class ProtocolVersionMismatch extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the specified Type is not supported\n */\nexport declare class TypeNotSupported extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the schema in the serializer is invalid\n */\nexport declare class InvalidSchema extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the 2 types provided are not compatible\n */\nexport declare class InvalidSchemaType extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the string is not a valid hex string\n */\nexport declare class InvalidHexString extends SerializerError {\n    constructor(description?: string);\n}\n/**\n * Gets thrown if the string starts with "0x". This causes problems with RLP\n */\nexport declare class InvalidString extends SerializerError {\n    constructor(description?: string);\n}\n'},{name:"@airgap/coinlib-core/interfaces/IAirGapSignedTransaction.d.ts",dts:"export declare type IAirGapSignedTransaction = string;\n"},{name:"@airgap/coinlib-core/interfaces/IAirGapTransaction.d.ts",dts:"import { CosmosTransactionCursor } from './../protocols/cosmos/CosmosTypes';\nimport { SubstrateTransactionCursor } from './../protocols/substrate/SubstrateTypes';\nimport { TezosTransactionCursor } from './../protocols/tezos/types/TezosTransactionCursor';\nimport { BitcoinTransactionCursor, BitcoinBlockbookTransactionCursor } from './../protocols/bitcoin/BitcoinTypes';\nimport { ProtocolNetwork } from '../utils/ProtocolNetwork';\nimport { ProtocolSymbols } from '../utils/ProtocolSymbols';\nimport { EthereumTransactionCursor } from '../protocols/ethereum/EthereumTypes';\nimport { AeternityTransactionCursor } from '../protocols/aeternity/AeternityTypes';\nexport declare enum AirGapTransactionType {\n    SPEND = \"Spend Transaction\",\n    DELEGATE = \"Delegation\",\n    UNDELEGATE = \"Undelegate\"\n}\nexport declare enum AirGapTransactionStatus {\n    APPLIED = \"applied\",\n    FAILED = \"failed\"\n}\nexport interface IAirGapTransaction {\n    from: string[];\n    to: string[];\n    isInbound: boolean;\n    amount: string;\n    fee: string;\n    timestamp?: number;\n    protocolIdentifier: ProtocolSymbols;\n    network: ProtocolNetwork;\n    hash?: string;\n    blockHeight?: string;\n    data?: string;\n    extra?: any;\n    status?: AirGapTransactionStatus;\n    transactionDetails?: any;\n}\nexport declare type IProtocolTransactionCursor = EthereumTransactionCursor | BitcoinTransactionCursor | TezosTransactionCursor | AeternityTransactionCursor | SubstrateTransactionCursor | CosmosTransactionCursor | BitcoinBlockbookTransactionCursor;\nexport interface IAirGapTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: IProtocolTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/interfaces/IAirGapWallet.d.ts",dts:"import { ICoinProtocol } from '../protocols/ICoinProtocol';\nexport interface IAirGapWallet {\n    addresses: string[];\n    protocol: ICoinProtocol;\n    deriveAddresses(amount: number): Promise<string[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/aeternity/AeternityCryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { Ed25519CryptoClient } from '../Ed25519CryptoClient';\nexport declare class AeternityCryptoClient extends Ed25519CryptoClient {\n    constructor();\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n}\n"},{name:"@airgap/coinlib-core/protocols/aeternity/AeternityProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport { AeternityTransactionResult, AeternityTransactionCursor } from './AeternityTypes';\nimport { IAirGapSignedTransaction } from '../../interfaces/IAirGapSignedTransaction';\nimport { AirGapTransactionStatus, IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { SignedAeternityTransaction } from '../../serializer/schemas/definitions/signed-transaction-aeternity';\nimport { UnsignedAeternityTransaction } from '../../serializer/schemas/definitions/unsigned-transaction-aeternity';\nimport { RawAeternityTransaction } from '../../serializer/types';\nimport { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults, ICoinProtocol } from '../ICoinProtocol';\nimport { NonExtendedProtocol } from '../NonExtendedProtocol';\nimport { AeternityCryptoClient } from './AeternityCryptoClient';\nimport { AeternityProtocolOptions } from './AeternityProtocolOptions';\nimport { ICoinSubProtocol } from '../ICoinSubProtocol';\nexport declare class AeternityProtocol extends NonExtendedProtocol implements ICoinProtocol {\n    readonly options: AeternityProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    feeDefaults: {\n        low: string;\n        medium: string;\n        high: string;\n    };\n    units: CurrencyUnit[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    defaultNetworkId: string;\n    private readonly feesURL;\n    readonly cryptoClient: AeternityCryptoClient;\n    constructor(options?: AeternityProtocolOptions);\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    /**\n     * Returns the PublicKey as String, derived from a supplied hex-string\n     * @param secret HEX-Secret from BIP39\n     * @param derivationPath DerivationPath for Key\n     */\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    /**\n     * Returns the PrivateKey as Buffer, derived from a supplied hex-string\n     * @param secret HEX-Secret from BIP39\n     * @param derivationPath DerivationPath for Key\n     */\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getAddressFromPublicKey(publicKey: string): Promise<string>;\n    getAddressesFromPublicKey(publicKey: string): Promise<string[]>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: AeternityTransactionCursor): Promise<AeternityTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: AeternityTransactionCursor): Promise<AeternityTransactionResult>;\n    protected getPageNumber(limit: number, offset: number): number;\n    signWithPrivateKey(privateKey: Buffer, transaction: RawAeternityTransaction): Promise<IAirGapSignedTransaction>;\n    private decodeTx;\n    getTransactionDetails(unsignedTx: UnsignedAeternityTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(signedTx: SignedAeternityTransaction): Promise<IAirGapTransaction[]>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    getAvailableBalanceOfAddresses(addresses: string[]): Promise<string>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, payload?: string): Promise<RawAeternityTransaction>;\n    /**\n     * This is a function that we only use to fix incompatibilitis with old vault versions that are unable to understand b64 encoded Txs.\n     *\n     * @deprecated\n     * @param preparedTx\n     */\n    convertTxToBase58(preparedTx: RawAeternityTransaction): RawAeternityTransaction;\n    broadcastTransaction(rawTransaction: string): Promise<string>;\n    private toHexBuffer;\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(message: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(message: string, privateKey: Buffer): Promise<string>;\n    decryptAES(message: string, privateKey: Buffer): Promise<string>;\n    getTransactionStatuses(transactionHashes: string[]): Promise<AirGapTransactionStatus[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/aeternity/AeternityProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nexport declare class AeternalBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer?: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class AeternityProtocolNetwork extends ProtocolNetwork<undefined> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: undefined);\n}\nexport declare class AeternityProtocolOptions implements ProtocolOptions<undefined> {\n    readonly network: AeternityProtocolNetwork;\n    readonly config: undefined;\n    constructor(network?: AeternityProtocolNetwork, config?: undefined);\n}\n"},{name:"@airgap/coinlib-core/protocols/aeternity/AeternityTypes.d.ts",dts:"import { IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nexport interface AeternityTransactionCursor {\n    page: number;\n}\nexport interface AeternityTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: AeternityTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/bitcoin/BitcoinCryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { ICoinProtocol } from '../..';\nimport { Secp256k1CryptoClient } from '../Secp256k1CryptoClient';\nexport declare class BitcoinCryptoClient extends Secp256k1CryptoClient {\n    private readonly protocol;\n    private readonly bitcoinJSMessage;\n    constructor(protocol: ICoinProtocol, bitcoinJSMessage: any);\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n}\n"},{name:"@airgap/coinlib-core/protocols/bitcoin/BitcoinProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport { BitcoinBlockbookTransactionCursor, BitcoinBlockbookTransactionResult } from './BitcoinTypes';\nimport { IAirGapSignedTransaction } from '../../interfaces/IAirGapSignedTransaction';\nimport { AirGapTransactionStatus, IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { SignedBitcoinTransaction } from '../../serializer/schemas/definitions/signed-transaction-bitcoin';\nimport { UnsignedTransaction } from '../../serializer/schemas/definitions/unsigned-transaction';\nimport { RawBitcoinTransaction } from '../../serializer/types';\nimport { CurrencyUnit, FeeDefaults, ICoinProtocol } from '../ICoinProtocol';\nimport { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { BitcoinProtocolOptions } from './BitcoinProtocolOptions';\nimport { BitcoinCryptoClient } from './BitcoinCryptoClient';\nimport { ICoinSubProtocol } from '../ICoinSubProtocol';\nexport interface Vin {\n    txid: string;\n    sequence: any;\n    n: number;\n    addresses: string[];\n    value: string;\n    hex: string;\n}\nexport interface Vout {\n    value: string;\n    n: number;\n    hex: string;\n    addresses: string[];\n    spent?: boolean;\n}\nexport interface Transaction {\n    txid: string;\n    version: number;\n    vin: Vin[];\n    vout: Vout[];\n    blockhash: string;\n    blockHeight: number;\n    confirmations: number;\n    blockTime: number;\n    value: string;\n    valueIn: string;\n    fees: string;\n    hex: string;\n}\nexport interface Token {\n    type: string;\n    name: string;\n    path: string;\n    transfers: number;\n    decimals: number;\n    balance: string;\n    totalReceived: string;\n    totalSent: string;\n}\nexport interface XPubResponse {\n    page: number;\n    totalPages: number;\n    itemsOnPage: number;\n    address: string;\n    balance: string;\n    totalReceived: string;\n    totalSent: string;\n    unconfirmedBalance: string;\n    unconfirmedTxs: number;\n    txs: number;\n    transactions?: Transaction[];\n    totalTokens?: number;\n    tokens?: Token[];\n}\nexport interface AddressResponse {\n    page: number;\n    totalPages: number;\n    itemsOnPage: number;\n    address: string;\n    balance: string;\n    totalReceived: string;\n    totalSent: string;\n    unconfirmedBalance: string;\n    unconfirmedTxs: number;\n    txs: number;\n    transactions?: Transaction[];\n}\nexport declare class BitcoinProtocol implements ICoinProtocol {\n    readonly options: BitcoinProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    subProtocols: never[];\n    feeDefaults: FeeDefaults;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    units: CurrencyUnit[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    readonly cryptoClient: BitcoinCryptoClient;\n    constructor(options?: BitcoinProtocolOptions);\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    getExtendedPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getExtendedPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getAddressFromPublicKey(publicKey: string): Promise<string>;\n    getAddressesFromPublicKey(publicKey: string): Promise<string[]>;\n    getAddressFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressDerivationIndex: number): Promise<string>;\n    getAddressesFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressCount: number, offset: number): Promise<string[]>;\n    signWithPrivateKey(privateKey: Buffer, transaction: RawBitcoinTransaction): Promise<IAirGapSignedTransaction>;\n    signWithExtendedPrivateKey(extendedPrivateKey: string, transaction: RawBitcoinTransaction): Promise<string>;\n    getTransactionDetails(unsignedTx: UnsignedTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(signedTx: SignedBitcoinTransaction): Promise<IAirGapTransaction[]>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getBalanceOfExtendedPublicKey(extendedPublicKey: string, offset?: number): Promise<string>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    getAvailableBalanceOfAddresses(addresses: string[]): Promise<string>;\n    estimateMaxTransactionValueFromExtendedPublicKey(extendedPublicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateFeeDefaultsFromExtendedPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromExtendedPublicKey(extendedPublicKey: string, offset: number, recipients: string[], values: string[], fee: string): Promise<RawBitcoinTransaction>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string): Promise<RawBitcoinTransaction>;\n    broadcastTransaction(rawTransaction: string): Promise<string>;\n    getTransactionsFromExtendedPublicKey(extendedPublicKey: string, limit: number, cursor?: BitcoinBlockbookTransactionCursor, addressOffset?: number): Promise<BitcoinBlockbookTransactionResult>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: BitcoinBlockbookTransactionCursor): Promise<BitcoinBlockbookTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: BitcoinBlockbookTransactionCursor): Promise<BitcoinBlockbookTransactionResult>;\n    private containsSome;\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(message: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(message: string, privateKey: Buffer): Promise<string>;\n    decryptAES(message: string, privateKey: Buffer): Promise<string>;\n    getTransactionStatuses(transactionHashes: string[]): Promise<AirGapTransactionStatus[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/bitcoin/BitcoinProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nexport declare class BitcoinProtocolNetworkExtras {\n    readonly indexerApi: string;\n    readonly network: any;\n    constructor(indexerApi?: string, network?: any);\n}\nexport declare class BlockcypherBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer?: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class BitcoinProtocolNetwork extends ProtocolNetwork<BitcoinProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: BitcoinProtocolNetworkExtras);\n}\nexport declare class BitcoinProtocolConfig {\n    readonly bitcoinJSLib: any;\n    constructor(bitcoinJSLib?: any);\n}\nexport declare class BitcoinProtocolOptions implements ProtocolOptions<BitcoinProtocolConfig> {\n    readonly network: BitcoinProtocolNetwork;\n    readonly config: BitcoinProtocolConfig;\n    constructor(network?: BitcoinProtocolNetwork, config?: BitcoinProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/bitcoin/BitcoinTestnetProtocol.d.ts",dts:"import { BitcoinProtocol } from './BitcoinProtocol';\nexport declare class BitcoinTestnetProtocol extends BitcoinProtocol {\n    name: string;\n    standardDerivationPath: string;\n    addressValidationPattern: string;\n    constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/bitcoin/BitcoinTypes.d.ts",dts:"import { IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nexport interface BitcoinTransactionCursor {\n    offset: number;\n}\nexport interface BitcoinTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: BitcoinTransactionCursor;\n}\nexport interface BitcoinBlockbookTransactionCursor {\n    page: number;\n}\nexport interface BitcoinBlockbookTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: BitcoinBlockbookTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/cosmos-message/CosmosDelegateMessage.d.ts",dts:"import { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { CosmosCoin } from '../CosmosCoin';\nimport { CosmosProtocol } from '../CosmosProtocol';\nimport { CosmosMessage, CosmosMessageJSON, CosmosMessageType } from './CosmosMessage';\nexport declare class CosmosDelegateMessage implements CosmosMessage {\n    readonly delegatorAddress: string;\n    readonly validatorAddress: string;\n    readonly amount: CosmosCoin;\n    readonly type: CosmosMessageType;\n    constructor(delegatorAddress: string, validatorAddress: string, amount: CosmosCoin, undelegate?: boolean);\n    toJSON(): CosmosMessageJSON;\n    static fromJSON(json: CosmosMessageJSON): CosmosDelegateMessage;\n    toRPCBody(): any;\n    toAirGapTransaction(protocol: CosmosProtocol, fee: string): IAirGapTransaction;\n    static fromRPCBody(json: any): CosmosDelegateMessage;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/cosmos-message/CosmosMessage.d.ts",dts:"import { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { CosmosCoinJSON } from '../CosmosCoin';\nimport { CosmosProtocol } from '../CosmosProtocol';\nimport { JSONConvertible, RPCConvertible } from '../CosmosTransaction';\nexport interface CosmosMessageJSON {\n    type: CosmosMessageTypeIndex;\n    amount: CosmosCoinJSON[];\n    fromAddress: string;\n    toAddress: string;\n}\nexport declare enum CosmosMessageTypeIndex {\n    SEND = 0,\n    DELEGATE = 1,\n    UNDELEGATE = 2,\n    WITHDRAW_DELEGATION_REWARD = 3\n}\nexport declare class CosmosMessageType {\n    static Send: CosmosMessageType;\n    static Delegate: CosmosMessageType;\n    static Undelegate: CosmosMessageType;\n    static WithdrawDelegationReward: CosmosMessageType;\n    readonly index: CosmosMessageTypeIndex;\n    readonly value: string;\n    constructor(index: CosmosMessageTypeIndex);\n}\nexport interface CosmosMessage extends JSONConvertible, RPCConvertible {\n    type: CosmosMessageType;\n    toAirGapTransaction(protocol: CosmosProtocol, fee: string): IAirGapTransaction;\n    toJSON(): CosmosMessageJSON;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/cosmos-message/CosmosSendMessage.d.ts",dts:"import { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { CosmosCoin } from '../CosmosCoin';\nimport { CosmosProtocol } from '../CosmosProtocol';\nimport { CosmosMessage, CosmosMessageJSON, CosmosMessageType } from './CosmosMessage';\nexport declare class CosmosSendMessage implements CosmosMessage {\n    readonly fromAddress: string;\n    readonly toAddress: string;\n    readonly amount: CosmosCoin[];\n    readonly type: CosmosMessageType;\n    constructor(fromAddress: string, toAddress: string, amount: CosmosCoin[]);\n    toJSON(): CosmosMessageJSON;\n    static fromJSON(json: CosmosMessageJSON): CosmosSendMessage;\n    toRPCBody(): any;\n    toAirGapTransaction(protocol: CosmosProtocol, fee: string): IAirGapTransaction;\n    static fromRPCBody(json: any): CosmosSendMessage;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/cosmos-message/CosmosWithdrawDelegationRewardMessage.d.ts",dts:"import { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { CosmosProtocol } from '../CosmosProtocol';\nimport { CosmosMessage, CosmosMessageJSON, CosmosMessageType } from './CosmosMessage';\nexport declare class CosmosWithdrawDelegationRewardMessage implements CosmosMessage {\n    readonly delegatorAddress: string;\n    readonly validatorAddress: string;\n    readonly type: CosmosMessageType;\n    constructor(delegatorAddress: string, validatorAddress: string);\n    toAirGapTransaction(protocol: CosmosProtocol, fee: string): IAirGapTransaction;\n    toJSON(): CosmosMessageJSON;\n    static fromJSON(json: CosmosMessageJSON): CosmosWithdrawDelegationRewardMessage;\n    toRPCBody(): {\n        type: string;\n        value: {\n            delegator_address: string;\n            validator_address: string;\n        };\n    };\n    static fromRPCBody(json: any): CosmosWithdrawDelegationRewardMessage;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosCoin.d.ts",dts:"import { JSONConvertible, RPCConvertible } from './CosmosTransaction';\nexport interface CosmosCoinJSON {\n    denom: string;\n    amount: string;\n}\nexport declare class CosmosCoin implements JSONConvertible, RPCConvertible {\n    private static readonly supportedDenominations;\n    readonly denom: string;\n    readonly amount: string;\n    constructor(denom: string, amount: string);\n    toJSON(): CosmosCoinJSON;\n    static fromJSON(json: CosmosCoinJSON): CosmosCoin;\n    toRPCBody(): any;\n    static fromRPCBody(json: any): CosmosCoin;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosCryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { Secp256k1CryptoClient } from '../Secp256k1CryptoClient';\nexport declare class CosmosCryptoClient extends Secp256k1CryptoClient {\n    constructor();\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosFee.d.ts",dts:"import { CosmosCoin } from './CosmosCoin';\nimport { JSONConvertible, RPCConvertible } from './CosmosTransaction';\nexport declare class CosmosFee implements JSONConvertible, RPCConvertible {\n    readonly amount: CosmosCoin[];\n    readonly gas: string;\n    constructor(amount: CosmosCoin[], gas: string);\n    toJSON(): {\n        amount: import(\"./CosmosCoin\").CosmosCoinJSON[];\n        gas: string;\n    };\n    static fromJSON(json: any): CosmosFee;\n    toRPCBody(): any;\n    static fromRPCBody(json: any): CosmosFee;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosNodeClient.d.ts",dts:"import BigNumber from '../../dependencies/src/bignumber.js-9.0.0/bignumber';\nexport interface CosmosNodeInfo {\n    protocol_version: {\n        p2p: string;\n        block: string;\n        app: string;\n    };\n    id: string;\n    listen_addr: string;\n    network: string;\n    version: string;\n    channels: string;\n    moniker: string;\n    other: {\n        tx_index: string;\n        rpc_address: string;\n    };\n}\nexport interface CosmosAccount {\n    type: string;\n    value: CosmosAccountValue;\n}\nexport interface CosmosAccountValue {\n    account_number: string;\n    address: string;\n    coins: CosmosAccountCoin[];\n    sequence?: string;\n    public_key?: string;\n}\nexport interface CosmosAccountCoin {\n    denom: string;\n    amount: string;\n}\nexport interface CosmosDelegation {\n    delegation: {\n        delegator_address: string;\n        validator_address: string;\n        shares: string;\n    };\n    balance: {\n        denom: string;\n        amount: string;\n    };\n}\nexport interface CosmosUnbondingDelegation {\n    delegator_address: string;\n    validator_address: string;\n    entries: {\n        creation_height: string;\n        completion_time: string;\n        initial_balance: string;\n        balance: string;\n    }[];\n}\nexport interface CosmosValidator {\n    operator_address: string;\n    consensus_pubkey: string;\n    jailed: boolean;\n    status: number;\n    tokens: string;\n    delegator_shares: string;\n    description: CosmosValidatorDescription;\n    unbonding_height: string;\n    unbonding_time: string;\n    commission: CosmosValidatorCommission;\n    min_self_delegation: string;\n}\nexport interface CosmosValidatorDescription {\n    moniker: string;\n    identity: string;\n    website: string;\n    details: string;\n}\nexport interface CosmosValidatorCommission {\n    commission_rates: CosmosValidatorCommissionRate;\n    update_time: string;\n}\nexport interface CosmosValidatorCommissionRate {\n    rate: string;\n    max_rate: string;\n    max_change_rate: string;\n}\nexport interface CosmosBroadcastSignedTransactionResponse {\n    txhash: string;\n    height: number;\n}\nexport interface CosmosRewardDetails {\n    validator_address: string;\n    reward: {\n        denom: string;\n        amount: number;\n    }[];\n}\nexport interface CosmosPagedSendTxsResponse {\n    total_count: string;\n    count: string;\n    page_number: string;\n    page_total: string;\n    limit: string;\n    txs: CosmosSendTx[];\n}\nexport interface CosmosSendTx {\n    height: string;\n    txhash: string;\n    gas_wanted: string;\n    gas_used: string;\n    tx: {\n        type: string;\n        value: {\n            msg: [\n                {\n                    type: string;\n                    value: {\n                        from_address: string;\n                        to_address: string;\n                        amount: [\n                            {\n                                denom: string;\n                                amount: string;\n                            }\n                        ];\n                    };\n                }\n            ];\n            fee: {\n                amount: [\n                    {\n                        denom: string;\n                        amount: string;\n                    }\n                ];\n                gas: string;\n            };\n            memo: string;\n        };\n    };\n    timestamp: string;\n}\nexport declare class CosmosNodeClient {\n    readonly baseURL: string;\n    useCORSProxy: boolean;\n    constructor(baseURL: string, useCORSProxy?: boolean);\n    fetchBalance(address: string, totalBalance?: boolean): Promise<BigNumber>;\n    fetchSendTransactionsFor(address: string, page?: number, limit?: number, isSender?: boolean): Promise<CosmosPagedSendTxsResponse>;\n    fetchNodeInfo(): Promise<CosmosNodeInfo>;\n    broadcastSignedTransaction(transaction: string): Promise<string>;\n    fetchAccount(address: string): Promise<CosmosAccount>;\n    fetchDelegations(address: string, filterEmpty?: boolean): Promise<CosmosDelegation[]>;\n    fetchTotalDelegatedAmount(address: string): Promise<BigNumber>;\n    fetchValidator(address: string): Promise<CosmosValidator>;\n    fetchValidators(): Promise<CosmosValidator[]>;\n    fetchSelfDelegation(validatorAddress: string): Promise<CosmosDelegation>;\n    fetchUnbondingDelegations(delegatorAddress: string): Promise<CosmosUnbondingDelegation[]>;\n    fetchTotalUnbondingAmount(address: string): Promise<BigNumber>;\n    fetchRewardDetails(delegatorAddress: string): Promise<CosmosRewardDetails[]>;\n    fetchTotalReward(delegatorAddress: string): Promise<BigNumber>;\n    fetchRewardForDelegation(delegatorAddress: string, validatorAddress: string): Promise<BigNumber>;\n    withdrawAllDelegationRewards(delegatorAddress: string, chainID: string, accountNumber: string, sequence: string, gas: BigNumber, fee: BigNumber, memo: string, simulate?: boolean): Promise<string>;\n    withdrawDelegationRewards(delegatorAddress: string, validatorAdress: string, chainID: string, accountNumber: string, sequence: string, gas: BigNumber, fee: BigNumber, memo: string, simulate?: boolean): Promise<string>;\n    private url;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport { KeyPair } from '../../data/KeyPair';\nimport BigNumber from '../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { AirGapTransactionStatus, IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { SignedCosmosTransaction } from '../../serializer/schemas/definitions/signed-transaction-cosmos';\nimport { UnsignedCosmosTransaction } from '../../serializer/types';\nimport { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { DelegateeDetails, DelegationDetails, DelegatorDetails, ICoinDelegateProtocol } from '../ICoinDelegateProtocol';\nimport { CurrencyUnit, FeeDefaults } from '../ICoinProtocol';\nimport { ICoinSubProtocol } from '../ICoinSubProtocol';\nimport { NonExtendedProtocol } from '../NonExtendedProtocol';\nimport { CosmosCryptoClient } from './CosmosCryptoClient';\nimport { CosmosDelegation, CosmosNodeClient, CosmosUnbondingDelegation, CosmosValidator } from './CosmosNodeClient';\nimport { CosmosProtocolOptions } from './CosmosProtocolOptions';\nimport { CosmosTransaction } from './CosmosTransaction';\nimport { CosmosTransactionCursor, CosmosTransactionResult } from './CosmosTypes';\nexport declare enum CosmosDelegationActionType {\n    DELEGATE = \"delegate\",\n    UNDELEGATE = \"undelegate\",\n    WITHDRAW_ALL_REWARDS = \"withdraw_all_rewards\",\n    WITHDRAW_VALIDATOR_REWARDS = \"withdraw_validator_rewards\"\n}\nexport declare class CosmosProtocol extends NonExtendedProtocol implements ICoinDelegateProtocol {\n    readonly options: CosmosProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    feeDefaults: FeeDefaults;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    units: CurrencyUnit[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    subProtocols?: ICoinSubProtocol[];\n    private readonly addressPrefix;\n    private readonly defaultGas;\n    readonly cryptoClient: CosmosCryptoClient;\n    get nodeClient(): CosmosNodeClient;\n    constructor(options?: CosmosProtocolOptions);\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    generateKeyPair(mnemonic: string, derivationPath?: string, password?: string): KeyPair;\n    private generateKeyPairFromNode;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getPublicKeyFromPrivateKey(privateKey: Buffer): Buffer;\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getAddressFromPublicKey(publicKey: string): Promise<string>;\n    getAddressesFromPublicKey(publicKey: string): Promise<string[]>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: CosmosTransactionCursor): Promise<CosmosTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: CosmosTransactionCursor): Promise<CosmosTransactionResult>;\n    signWithPrivateKey(privateKey: Buffer, transaction: CosmosTransaction): Promise<string>;\n    getTransactionDetails(transaction: UnsignedCosmosTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(transaction: SignedCosmosTransaction): Promise<IAirGapTransaction[]>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getAvailableBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    private getBalance;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: unknown): Promise<CosmosTransaction>;\n    getDefaultDelegatee(): Promise<string>;\n    getCurrentDelegateesForPublicKey(publicKey: string): Promise<string[]>;\n    getCurrentDelegateesForAddress(address: string): Promise<string[]>;\n    getDelegateeDetails(address: string): Promise<DelegateeDetails>;\n    isPublicKeyDelegating(publicKey: string): Promise<boolean>;\n    isAddressDelegating(address: string): Promise<boolean>;\n    getDelegatorDetailsFromPublicKey(publicKey: string): Promise<DelegatorDetails>;\n    getDelegatorDetailsFromAddress(address: string): Promise<DelegatorDetails>;\n    getDelegationDetailsFromPublicKey(publicKey: string, delegatees: string[]): Promise<DelegationDetails>;\n    getDelegationDetailsFromAddress(address: string, delegatees: string[]): Promise<DelegationDetails>;\n    prepareDelegatorActionFromPublicKey(publicKey: string, type: CosmosDelegationActionType, data?: any): Promise<CosmosTransaction[]>;\n    undelegate(publicKey: string, validatorAddress: string, amount: string, memo?: string): Promise<CosmosTransaction>;\n    delegate(publicKey: string, validatorAddress: string | string[], amount: string, undelegate?: boolean, memo?: string): Promise<CosmosTransaction>;\n    withdrawDelegationRewards(publicKey: string, _validatorAddresses?: string[], memo?: string): Promise<CosmosTransaction>;\n    withdrawAllDelegationRewards(delegatorAddress: string, fee: BigNumber, memo?: string): Promise<string>;\n    fetchTotalReward(delegatorAddress: string): Promise<BigNumber>;\n    fetchRewardForDelegation(delegatorAddress: string, validatorAddress: string): Promise<BigNumber>;\n    fetchDelegations(address: string): Promise<CosmosDelegation[]>;\n    fetchTotalDelegatedAmount(address: string): Promise<BigNumber>;\n    fetchValidator(address: string): Promise<CosmosValidator>;\n    fetchUnbondingDelegations(delegatorAddress: string): Promise<CosmosUnbondingDelegation[]>;\n    fetchTotalUnbondingAmount(address: string): Promise<BigNumber>;\n    fetchValidators(): Promise<CosmosValidator[]>;\n    fetchSelfDelegation(address: string): Promise<CosmosDelegation>;\n    broadcastTransaction(rawTransaction: string): Promise<string>;\n    private getDelegatorDetails;\n    private getAvailableDelegatorActions;\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(message: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(message: string, privateKey: Buffer): Promise<string>;\n    decryptAES(message: string, privateKey: Buffer): Promise<string>;\n    getTransactionStatuses(transactionHashes: string[]): Promise<AirGapTransactionStatus[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nimport { CosmosNodeClient } from './CosmosNodeClient';\nexport declare class MintscanBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer?: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class CosmosProtocolNetwork extends ProtocolNetwork<undefined> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: undefined);\n}\nexport declare class CosmosProtocolConfig {\n    readonly nodeClient: CosmosNodeClient;\n    constructor(nodeClient?: CosmosNodeClient);\n}\nexport declare class CosmosProtocolOptions implements ProtocolOptions<CosmosProtocolConfig> {\n    readonly network: CosmosProtocolNetwork;\n    readonly config: CosmosProtocolConfig;\n    constructor(network?: CosmosProtocolNetwork, config?: CosmosProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosTransaction.d.ts",dts:"import { IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { SerializableUnsignedCosmosTransaction } from '../../serializer/schemas/definitions/unsigned-transaction-cosmos';\nimport { CosmosMessage } from './cosmos-message/CosmosMessage';\nimport { CosmosFee } from './CosmosFee';\nimport { CosmosProtocol } from './CosmosProtocol';\nexport interface JSONConvertible {\n    toJSON(): any;\n}\nexport interface RPCConvertible {\n    toRPCBody(): any;\n}\nexport declare class CosmosTransaction implements JSONConvertible, RPCConvertible {\n    readonly messages: CosmosMessage[];\n    readonly fee: CosmosFee;\n    readonly memo: string;\n    readonly chainID: string;\n    readonly accountNumber: string;\n    readonly sequence: string;\n    constructor(messages: CosmosMessage[], fee: CosmosFee, memo: string, chainID: string, accountNumber: string, sequence: string);\n    toJSON(): {\n        accountNumber: string;\n        chainID: string;\n        fee: {\n            amount: import(\"./CosmosCoin\").CosmosCoinJSON[];\n            gas: string;\n        };\n        memo: string;\n        messages: import(\"./cosmos-message/CosmosMessage\").CosmosMessageJSON[];\n        sequence: string;\n    };\n    toRPCBody(): any;\n    toAirGapTransactions(protocol: CosmosProtocol): IAirGapTransaction[];\n    static fromJSON(json: SerializableUnsignedCosmosTransaction): CosmosTransaction;\n    static fromRPCBody(json: any): CosmosTransaction;\n}\n"},{name:"@airgap/coinlib-core/protocols/cosmos/CosmosTypes.d.ts",dts:"import { IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nexport interface CosmosTransactionCursor {\n    address: string;\n    limit: number;\n    sender: {\n        page: number;\n        totalPages: number;\n        count: number;\n        totalCount: number;\n    };\n    receipient: {\n        page: number;\n        totalPages: number;\n        count: number;\n        totalCount: number;\n    };\n}\nexport interface CosmosTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: CosmosTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/clients/info-clients/EtherscanInfoClient.d.ts",dts:"import { EthereumProtocol } from '../../EthereumProtocol';\nimport { EthereumInfoClient } from './InfoClient';\nimport { EthereumTransactionCursor, EthereumTransactionResult } from '../../EthereumTypes';\nexport declare class EtherscanInfoClient extends EthereumInfoClient {\n    constructor(baseURL?: string);\n    fetchTransactions(protocol: EthereumProtocol, address: string, limit: any, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n    fetchContractTransactions(protocol: EthereumProtocol, contractAddress: string, address: string, limit: number, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/clients/info-clients/InfoClient.d.ts",dts:"import { EthereumProtocol } from '../../EthereumProtocol';\nimport { EthereumTransactionCursor, EthereumTransactionResult } from '../../EthereumTypes';\nexport declare abstract class EthereumInfoClient {\n    baseURL: string;\n    constructor(baseURL: string);\n    abstract fetchTransactions(protocol: EthereumProtocol, address: string, limit: number, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n    abstract fetchContractTransactions(protocol: EthereumProtocol, contractAddress: string, address: string, limit: number, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/clients/node-clients/AirGapNodeClient.d.ts",dts:"import { BigNumber } from '../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { AirGapTransactionStatus } from '../../../../interfaces/IAirGapTransaction';\nimport { EthereumNodeClient } from './NodeClient';\nexport declare class EthereumRPCData {\n    protected static parametersLength: number;\n    methodSignature: string;\n    constructor(methodSignature: string);\n    abiEncoded(): string;\n    static addLeadingZeroPadding(value: string, targetLength?: number): string;\n    static removeLeadingZeroPadding(value: string): string;\n}\nexport declare class EthereumRPCDataBalanceOf extends EthereumRPCData {\n    static methodName: string;\n    address: string;\n    constructor(address: string);\n    abiEncoded(): string;\n}\nexport declare class EthereumRPCDataTransfer extends EthereumRPCData {\n    static methodName: string;\n    recipient: string;\n    amount: string;\n    constructor(toAddressOrData: string, amount?: string);\n    abiEncoded(): string;\n}\nexport declare class AirGapNodeClient extends EthereumNodeClient {\n    constructor(baseURL?: string);\n    fetchBalance(address: string): Promise<BigNumber>;\n    fetchTransactionCount(address: string): Promise<number>;\n    sendSignedTransaction(transaction: string): Promise<string>;\n    getTransactionStatus(transactionHash: string): Promise<AirGapTransactionStatus>;\n    callBalanceOf(contractAddress: string, address: string): Promise<BigNumber>;\n    callBalanceOfOnContracts(contractAddresses: string[], address: string): Promise<{\n        [contractAddress: string]: BigNumber;\n    }>;\n    private balanceOfBody;\n    estimateTransactionGas(fromAddress: string, toAddress: string, amount?: string, data?: string, gas?: string): Promise<BigNumber>;\n    estimateTransferGas(contractAddress: string, fromAddress: string, toAddress: string, hexAmount: string): Promise<BigNumber>;\n    getGasPrice(): Promise<BigNumber>;\n    private send;\n    private batchSend;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/clients/node-clients/NodeClient.d.ts",dts:"import { BigNumber } from '../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { AirGapTransactionStatus } from '../../../../interfaces/IAirGapTransaction';\nexport declare abstract class EthereumNodeClient {\n    baseURL: string;\n    constructor(baseURL: string);\n    abstract fetchBalance(address: string): Promise<BigNumber>;\n    abstract fetchTransactionCount(address: string): Promise<number>;\n    abstract sendSignedTransaction(transaction: string): Promise<string>;\n    abstract callBalanceOf(contractAddress: string, address: string): Promise<BigNumber>;\n    abstract getTransactionStatus(transactionHash: string): Promise<AirGapTransactionStatus>;\n    abstract estimateTransferGas(contractAddress: string, fromAddress: string, toAddress: string, hexAmount: string): Promise<BigNumber>;\n    abstract estimateTransactionGas(fromAddress: string, toAddress: string, amount?: string, data?: string, gas?: string): Promise<BigNumber>;\n    abstract getGasPrice(): Promise<BigNumber>;\n    abstract callBalanceOfOnContracts(contractAddresses: string[], address: string): Promise<{\n        [contractAddress: string]: BigNumber;\n    }>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/erc20/ERC20.d.ts",dts:"import { GenericERC20 } from './GenericERC20';\ndeclare const ERC20Token: GenericERC20;\nexport { ERC20Token };\n"},{name:"@airgap/coinlib-core/protocols/ethereum/erc20/GenericERC20.d.ts",dts:"/// <reference types=\"node\" />\nimport { EthereumTransactionResult, EthereumTransactionCursor } from './../EthereumTypes';\nimport { IAirGapSignedTransaction } from '../../../interfaces/IAirGapSignedTransaction';\nimport { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { SignedEthereumTransaction } from '../../../serializer/schemas/definitions/signed-transaction-ethereum';\nimport { UnsignedTransaction } from '../../../serializer/schemas/definitions/unsigned-transaction';\nimport { RawEthereumTransaction } from '../../../serializer/types';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { ICoinSubProtocol, SubProtocolType } from '../../ICoinSubProtocol';\nimport { BaseEthereumProtocol } from '../BaseEthereumProtocol';\nimport { EtherscanInfoClient } from '../clients/info-clients/EtherscanInfoClient';\nimport { AirGapNodeClient } from '../clients/node-clients/AirGapNodeClient';\nimport { EthereumERC20ProtocolOptions } from '../EthereumProtocolOptions';\nexport declare class GenericERC20 extends BaseEthereumProtocol<AirGapNodeClient, EtherscanInfoClient> implements ICoinSubProtocol {\n    readonly options: EthereumERC20ProtocolOptions;\n    isSubProtocol: boolean;\n    subProtocolType: SubProtocolType;\n    readonly contractAddress: string;\n    constructor(options: EthereumERC20ProtocolOptions);\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    signWithPrivateKey(privateKey: Buffer, transaction: RawEthereumTransaction): Promise<IAirGapSignedTransaction>;\n    private estimateGas;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string): Promise<RawEthereumTransaction>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n    getTransactionDetailsFromSigned(signedTx: SignedEthereumTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetails(unsignedTx: UnsignedTransaction): Promise<IAirGapTransaction[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/utils/utils.d.ts",dts:"export declare class EthereumUtils {\n    static toHex(value: any): string;\n    private static readonly SHA3_NULL_S;\n    static sha3(value: any): string | null;\n    private static numberToHex;\n    private static hexToBytes;\n    private static isHexStrict;\n    private static checkAddressChecksum;\n    private static isAddress;\n    private static isBigNumber;\n    private static utf8ToHex;\n    private static isObject;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/BaseEthereumProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport { IAirGapSignedTransaction } from '../../interfaces/IAirGapSignedTransaction';\nimport { AirGapTransactionStatus, IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { Network } from '../../networks';\nimport { SignedEthereumTransaction } from '../../serializer/schemas/definitions/signed-transaction-ethereum';\nimport { UnsignedTransaction } from '../../serializer/schemas/definitions/unsigned-transaction';\nimport { RawEthereumTransaction } from '../../serializer/types';\nimport { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults, ICoinProtocol } from '../ICoinProtocol';\nimport { ICoinSubProtocol } from '../ICoinSubProtocol';\nimport { EthereumInfoClient } from './clients/info-clients/InfoClient';\nimport { EthereumNodeClient } from './clients/node-clients/NodeClient';\nimport { EthereumCryptoClient } from './EthereumCryptoClient';\nimport { EthereumProtocolOptions } from './EthereumProtocolOptions';\nimport { EthereumTransactionCursor, EthereumTransactionResult } from './EthereumTypes';\nexport declare abstract class BaseEthereumProtocol<NodeClient extends EthereumNodeClient, InfoClient extends EthereumInfoClient> implements ICoinProtocol {\n    readonly options: EthereumProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    feeDefaults: FeeDefaults;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    protected readonly MAX_GAS_ESTIMATE: string;\n    units: CurrencyUnit[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    network: Network;\n    readonly cryptoClient: EthereumCryptoClient;\n    get subProtocols(): ICoinSubProtocol[];\n    constructor(options?: EthereumProtocolOptions);\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    getExtendedPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getExtendedPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getAddressFromPublicKey(publicKey: string | Buffer): Promise<string>;\n    getAddressesFromPublicKey(publicKey: string | Buffer): Promise<string[]>;\n    getAddressFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressDerivationIndex: number): Promise<string>;\n    getAddressesFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressCount: number, offset: number): Promise<string[]>;\n    signWithExtendedPrivateKey(extendedPrivateKey: string, transaction: RawEthereumTransaction): Promise<IAirGapSignedTransaction>;\n    signWithPrivateKey(privateKey: Buffer, transaction: RawEthereumTransaction): Promise<IAirGapSignedTransaction>;\n    getTransactionDetails(unsignedTx: UnsignedTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(transaction: SignedEthereumTransaction): Promise<IAirGapTransaction[]>;\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    getBalanceOfExtendedPublicKey(extendedPublicKey: string, offset?: number): Promise<string>;\n    getAvailableBalanceOfAddresses(addresses: string[]): Promise<string>;\n    estimateMaxTransactionValueFromExtendedPublicKey(extendedPublicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateFeeDefaultsFromExtendedPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromExtendedPublicKey(extendedPublicKey: string, offset: number, recipients: string[], values: string[], fee: string): Promise<RawEthereumTransaction>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: any): Promise<RawEthereumTransaction>;\n    broadcastTransaction(rawTransaction: string): Promise<string>;\n    getTransactionsFromExtendedPublicKey(extendedPublicKey: string, limit: number, cursor: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n    getTransactionsFromPublicKey(publicKey: string, limit?: number, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: EthereumTransactionCursor): Promise<EthereumTransactionResult>;\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(message: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(message: string, privateKey: Buffer): Promise<string>;\n    decryptAES(message: string, privateKey: Buffer): Promise<string>;\n    getTransactionStatuses(transactionHashes: string[]): Promise<AirGapTransactionStatus[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/EthereumClassicProtocol.d.ts",dts:"import { BaseEthereumProtocol } from './BaseEthereumProtocol';\nimport { EtherscanInfoClient } from './clients/info-clients/EtherscanInfoClient';\nimport { AirGapNodeClient } from './clients/node-clients/AirGapNodeClient';\nexport declare class EthereumClassicProtocol extends BaseEthereumProtocol<AirGapNodeClient, EtherscanInfoClient> {\n    constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/EthereumCryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { Secp256k1CryptoClient } from '../Secp256k1CryptoClient';\nimport { BaseEthereumProtocol } from './BaseEthereumProtocol';\nimport { EthereumInfoClient } from './clients/info-clients/InfoClient';\nimport { EthereumNodeClient } from './clients/node-clients/NodeClient';\nexport declare class EthereumCryptoClient extends Secp256k1CryptoClient {\n    private readonly protocol;\n    constructor(protocol: BaseEthereumProtocol<EthereumNodeClient, EthereumInfoClient>);\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/EthereumProtocol.d.ts",dts:"import { BaseEthereumProtocol } from './BaseEthereumProtocol';\nimport { EtherscanInfoClient } from './clients/info-clients/EtherscanInfoClient';\nimport { AirGapNodeClient } from './clients/node-clients/AirGapNodeClient';\nimport { EthereumProtocolOptions } from './EthereumProtocolOptions';\nexport declare class EthereumProtocol extends BaseEthereumProtocol<AirGapNodeClient, EtherscanInfoClient> {\n    readonly options: EthereumProtocolOptions;\n    constructor(options?: EthereumProtocolOptions);\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/EthereumProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nimport { SubProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { EthereumInfoClient } from './clients/info-clients/InfoClient';\nimport { EthereumNodeClient } from './clients/node-clients/NodeClient';\nexport declare const NODE_URL: string;\nexport declare const BLOCK_EXPLORER_API: string;\nexport declare class EthereumProtocolNetworkExtras {\n    readonly chainID: number;\n    readonly blockExplorerApi: string;\n    constructor(chainID?: number, blockExplorerApi?: string);\n}\nexport declare class EtherscanBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer?: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class EthereumProtocolNetwork extends ProtocolNetwork<EthereumProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: EthereumProtocolNetworkExtras);\n}\nexport declare class EthereumProtocolConfig {\n    constructor();\n}\nexport declare class EthereumProtocolOptions implements ProtocolOptions<EthereumProtocolConfig> {\n    readonly network: EthereumProtocolNetwork;\n    readonly config: EthereumProtocolConfig;\n    readonly nodeClient: EthereumNodeClient;\n    readonly infoClient: EthereumInfoClient;\n    constructor(network?: EthereumProtocolNetwork, config?: EthereumProtocolConfig);\n}\nexport declare class EthereumERC20ProtocolConfig {\n    readonly symbol: string;\n    readonly name: string;\n    readonly marketSymbol: string;\n    readonly identifier: SubProtocolSymbols;\n    readonly contractAddress: string;\n    readonly decimals: number;\n    constructor(symbol: string, name: string, marketSymbol: string, identifier: SubProtocolSymbols, contractAddress: string, decimals: number);\n}\nexport declare class EthereumERC20ProtocolOptions extends EthereumProtocolOptions {\n    readonly network: EthereumProtocolNetwork;\n    readonly config: EthereumERC20ProtocolConfig;\n    constructor(network: EthereumProtocolNetwork, config: EthereumERC20ProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/EthereumRopstenProtocol.d.ts",dts:"import { BaseEthereumProtocol } from './BaseEthereumProtocol';\nimport { EtherscanInfoClient } from './clients/info-clients/EtherscanInfoClient';\nimport { AirGapNodeClient } from './clients/node-clients/AirGapNodeClient';\nexport declare class EthereumRopstenProtocol extends BaseEthereumProtocol<AirGapNodeClient, EtherscanInfoClient> {\n    constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/ethereum/EthereumTypes.d.ts",dts:"import { IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nexport interface EthereumTransactionCursor {\n    page: number;\n}\nexport interface EthereumTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: EthereumTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/groestlcoin/GroestlcoinProtocol.d.ts",dts:"import { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { BitcoinProtocol } from '../bitcoin/BitcoinProtocol';\nimport { BitcoinCryptoClient } from '../bitcoin/BitcoinCryptoClient';\nimport { CurrencyUnit, FeeDefaults } from '../ICoinProtocol';\nimport { GroestlcoinProtocolOptions } from './GroestlcoinProtocolOptions';\nexport declare class GroestlcoinProtocol extends BitcoinProtocol {\n    readonly options: GroestlcoinProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    feeDefaults: FeeDefaults;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    units: CurrencyUnit[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    readonly cryptoClient: BitcoinCryptoClient;\n    constructor(options?: GroestlcoinProtocolOptions);\n}\n"},{name:"@airgap/coinlib-core/protocols/groestlcoin/GroestlcoinProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nexport declare class GroestlcoinProtocolNetworkExtras {\n    readonly indexerApi: string;\n    readonly network: any;\n    constructor(indexerApi?: string, network?: any);\n}\nexport declare class CryptoidBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer?: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class GroestlcoinProtocolNetwork extends ProtocolNetwork<GroestlcoinProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: GroestlcoinProtocolNetworkExtras);\n}\nexport declare class GroestlcoinProtocolConfig {\n    readonly bitcoinJSLib: any;\n    constructor(bitcoinJSLib?: any);\n}\nexport declare class GroestlcoinProtocolOptions implements ProtocolOptions<GroestlcoinProtocolConfig> {\n    readonly network: GroestlcoinProtocolNetwork;\n    readonly config: GroestlcoinProtocolConfig;\n    constructor(network?: GroestlcoinProtocolNetwork, config?: GroestlcoinProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/groestlcoin/GroestlcoinTestnetProtocol.d.ts",dts:"import { BitcoinProtocol } from '../bitcoin/BitcoinProtocol';\nexport declare class GroestlcoinTestnetProtocol extends BitcoinProtocol {\n    constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/blockexplorer/SubstrateBlockExplorerClient.d.ts",dts:"import { SubstrateTransactionCursor } from './../../SubstrateTypes';\nimport { IAirGapTransaction } from '../../../../interfaces/IAirGapTransaction';\nimport { SubstrateNetwork } from '../../SubstrateNetwork';\nexport declare class SubstrateBlockExplorerClient {\n    readonly network: SubstrateNetwork;\n    readonly apiUrl: string;\n    constructor(network: SubstrateNetwork, apiUrl: string);\n    getTransactions(address: string, limit: number, protocolDecimals: number, cursor?: SubstrateTransactionCursor): Promise<IAirGapTransaction[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/account/SubstrateAccountInfo.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../scale/SCALEDecoder';\nimport { SCALEInt } from '../scale/type/SCALEInt';\ndeclare class SubstrateAccountData {\n    readonly free: SCALEInt;\n    readonly reserved: SCALEInt;\n    readonly miscFrozen: SCALEInt;\n    readonly feeFrozen: SCALEInt;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<SubstrateAccountData>;\n    private constructor();\n}\nexport declare class SubstrateAccountInfo {\n    readonly nonce: SCALEInt;\n    readonly consumers: SCALEInt;\n    readonly providers: SCALEInt;\n    readonly data: SubstrateAccountData;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SubstrateAccountInfo;\n    private static migrateConsumersProducersLengths;\n    private constructor();\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/account/SubstrateAddress.d.ts",dts:"/// <reference types=\"node\" />\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nexport declare type SubstrateAccountId = string | SubstrateAddress;\nexport declare class SubstrateAddress {\n    readonly version: Buffer;\n    readonly payload: Buffer;\n    readonly checksum: Buffer;\n    private static placeholder;\n    static createPlaceholder(): SubstrateAddress;\n    static from(accountId: SubstrateAccountId, network: SubstrateNetwork): SubstrateAddress;\n    static fromPublicKey(payload: Buffer | Uint8Array | string, network: SubstrateNetwork): SubstrateAddress;\n    static fromEncoded(encoded: string): SubstrateAddress;\n    private static fromBytes;\n    private static fromPayload;\n    private static generateChecksum;\n    private encoded;\n    constructor(version: Buffer, payload: Buffer, checksum: Buffer);\n    compare(other: SubstrateAccountId): number;\n    toString(): string;\n    getBufferPublicKey(): Buffer;\n    getHexPublicKey(): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/account/SubstrateRegistration.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../scale/SCALEDecoder';\nimport { SCALEArray } from '../scale/type/SCALEArray';\nimport { SCALEData } from '../scale/type/SCALEData';\nimport { SCALEEnum } from '../scale/type/SCALEEnum';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nimport { SCALETuple } from '../scale/type/SCALETuple';\ndeclare enum SubstrateJudgement {\n    UNKNOWN = 0,\n    FEE_PAID = 1,\n    REASONABLE = 2,\n    KNOWN_GOOD = 3,\n    OUT_OF_DATE = 4,\n    LOW_QUALITY = 5,\n    ERRORNEOUS = 6\n}\nexport declare class SubstrateIdentityInfo {\n    readonly display: SCALEData;\n    readonly legal: SCALEData;\n    readonly web: SCALEData;\n    readonly riot: SCALEData;\n    readonly email: SCALEData;\n    readonly image: SCALEData;\n    readonly twitter: SCALEData;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<SubstrateIdentityInfo>;\n    private constructor();\n}\nexport declare class SubstrateRegistration {\n    readonly judgements: SCALEArray<SCALETuple<SCALEInt, SCALEEnum<SubstrateJudgement>>>;\n    readonly deposit: SCALEInt;\n    readonly identityInfo: SubstrateIdentityInfo;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SubstrateRegistration;\n    private constructor();\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/decorator/call/SubstrateCall.d.ts",dts:"export interface SubstrateCall {\n    moduleName: string;\n    name: string;\n    moduleIndex: number;\n    callIndex: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/decorator/constant/SubstrateConstant.d.ts",dts:'/// <reference types="node" />\nexport interface SubstrateConstant {\n    moduleName: string;\n    name: string;\n    value: Buffer;\n    type: string;\n}\n'},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/decorator/storage/SubstrateStorageEntry.d.ts",dts:"import { SCALEType } from '../../../scale/type/SCALEType';\nexport declare enum SubstrateStorageEntryHasher {\n    BLAKE2_128 = 0,\n    BLAKE2_256 = 1,\n    BLAKE2_128_CONCAT = 2,\n    TWOX128 = 3,\n    TWOX256 = 4,\n    TWOX64_CONCAT = 5,\n    IDENTITY = 6\n}\nexport declare abstract class SubstrateStorageEntry {\n    readonly moduleName: string;\n    readonly prefix: string;\n    private readonly storageHash;\n    constructor(moduleName: string, prefix: string);\n    hash(...args: SCALEType[]): Promise<string>;\n    protected abstract argsToKeys(args: SCALEType[]): Promise<string>;\n    protected abstract hashArgs(args: SCALEType[]): Promise<string>;\n    private hashPrefixTrie;\n}\nexport declare class SubstratePlainStorageEntry extends SubstrateStorageEntry {\n    protected argsToKeys(args: SCALEType[]): Promise<string>;\n    protected hashArgs(args: SCALEType[]): Promise<string>;\n}\nexport declare class SubstrateMapStorageEntry extends SubstrateStorageEntry {\n    readonly hasher: SubstrateStorageEntryHasher;\n    constructor(module: string, prefix: string, hasher: SubstrateStorageEntryHasher);\n    protected argsToKeys(args: SCALEType[]): Promise<string>;\n    protected hashArgs(args: SCALEType[]): Promise<string>;\n}\nexport declare class SubstrateDoubleMapStorageEntry extends SubstrateStorageEntry {\n    readonly firstHasher: SubstrateStorageEntryHasher;\n    readonly secondHasher: SubstrateStorageEntryHasher;\n    constructor(module: string, prefix: string, firstHasher: SubstrateStorageEntryHasher, secondHasher: SubstrateStorageEntryHasher);\n    protected argsToKeys(args: SCALEType[]): Promise<string>;\n    protected hashArgs(args: SCALEType[]): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/decorator/MetadataDecorator.d.ts",dts:"import { SubstrateCall } from './call/SubstrateCall';\nimport { SubstrateConstant } from './constant/SubstrateConstant';\nimport { SubstrateStorageEntry } from './storage/SubstrateStorageEntry';\nexport declare class MetadataDecorator {\n    private readonly storageEntries;\n    private readonly calls;\n    private readonly constants;\n    constructor(storageEntries: SubstrateStorageEntry[], calls: SubstrateCall[], constants: SubstrateConstant[]);\n    storageEntry(moduleName: string, entryName: string): SubstrateStorageEntry | undefined;\n    call(moduleName: string, callName: string): SubstrateCall | undefined;\n    constant(moduleName: string, constantName: string): SubstrateConstant | undefined;\n    private createMapKey;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/v11/module/storage/MetadataV11Storage.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { MetadataV11StorageEntry } from './MetadataV11StorageEntry';\nexport declare class MetadataV11Storage extends SCALEClass {\n    readonly prefix: SCALEString;\n    readonly storageEntries: SCALEArray<MetadataV11StorageEntry>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11Storage>;\n    protected scaleFields: SCALEString[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/v11/module/storage/MetadataV11StorageEntry.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../../scale/type/SCALEArray';\nimport { SCALEBytes } from '../../../../scale/type/SCALEBytes';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALEEnum } from '../../../../scale/type/SCALEEnum';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { MetadataV11StorageEntryType } from './MetadataV11StorageEntryType';\ndeclare enum StorageEntryModifier {\n    Optional = 0,\n    Default = 1\n}\nexport declare class MetadataV11StorageEntry extends SCALEClass {\n    readonly name: SCALEString;\n    readonly modifier: SCALEEnum<StorageEntryModifier>;\n    readonly type: MetadataV11StorageEntryType;\n    readonly defaultValue: SCALEBytes;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11StorageEntry>;\n    protected scaleFields: (SCALEBytes | SCALEString | MetadataV11StorageEntryType | SCALEEnum<StorageEntryModifier>)[];\n    private constructor();\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/v11/module/storage/MetadataV11StorageEntryType.d.ts",dts:"import { SubstrateNetwork } from '../../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../../scale/SCALEDecoder';\nimport { SCALEBoolean } from '../../../../scale/type/SCALEBoolean';\nimport { SCALEClass } from '../../../../scale/type/SCALEClass';\nimport { SCALEEnum } from '../../../../scale/type/SCALEEnum';\nimport { SCALEString } from '../../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../../scale/type/SCALEType';\nimport { SubstrateStorageEntry, SubstrateStorageEntryHasher } from '../../../decorator/storage/SubstrateStorageEntry';\ndeclare enum StorageEntryType {\n    Plain = 0,\n    Map = 1,\n    DoubleMap = 2\n}\nexport declare abstract class MetadataV11StorageEntryType extends SCALEClass {\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11StorageEntryType>;\n    protected abstract readonly type: SCALEEnum<StorageEntryType>;\n    protected abstract readonly _scaleFields: SCALEType[];\n    protected readonly scaleFields: SCALEType[];\n    abstract decorate(moduleName: string, prefix: string): SubstrateStorageEntry;\n}\nexport declare class MetadataV11StorageEntryPlain extends MetadataV11StorageEntryType {\n    readonly name: SCALEString;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11StorageEntryPlain>;\n    protected readonly type: SCALEEnum<StorageEntryType>;\n    protected readonly _scaleFields: SCALEString[];\n    private constructor();\n    decorate(moduleName: string, prefix: string): SubstrateStorageEntry;\n}\nexport declare class MetadataV11StorageEntryMap extends MetadataV11StorageEntryType {\n    readonly hasher: SCALEEnum<SubstrateStorageEntryHasher>;\n    readonly key: SCALEString;\n    readonly value: SCALEString;\n    readonly unused: SCALEBoolean;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11StorageEntryMap>;\n    protected readonly type: SCALEEnum<StorageEntryType>;\n    protected readonly _scaleFields: (SCALEBoolean | SCALEString | SCALEEnum<SubstrateStorageEntryHasher>)[];\n    private constructor();\n    decorate(moduleName: string, prefix: string): SubstrateStorageEntry;\n}\nexport declare class MetadataV11StorageEntryDoubleMap extends MetadataV11StorageEntryType {\n    readonly hasher1: SCALEEnum<SubstrateStorageEntryHasher>;\n    readonly key1: SCALEString;\n    readonly key2: SCALEString;\n    readonly value: SCALEString;\n    readonly hasher2: SCALEEnum<SubstrateStorageEntryHasher>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11StorageEntryDoubleMap>;\n    protected readonly type: SCALEEnum<StorageEntryType>;\n    protected readonly _scaleFields: (SCALEString | SCALEEnum<SubstrateStorageEntryHasher>)[];\n    private constructor();\n    decorate(moduleName: string, prefix: string): SubstrateStorageEntry;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/v11/module/MetadataV11Call.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALEString } from '../../../scale/type/SCALEString';\ndeclare class MetadataV11CallArgument extends SCALEClass {\n    readonly name: SCALEString;\n    readonly type: SCALEString;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11CallArgument>;\n    protected scaleFields: SCALEString[];\n    private constructor();\n}\nexport declare class MetadataV11Call extends SCALEClass {\n    readonly name: SCALEString;\n    readonly args: SCALEArray<MetadataV11CallArgument>;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11Call>;\n    protected scaleFields: (SCALEString | SCALEArray<MetadataV11CallArgument>)[];\n    private constructor();\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/v11/module/MetadataV11Constants.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEBytes } from '../../../scale/type/SCALEBytes';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nexport declare class MetadataV11Constant extends SCALEClass {\n    readonly name: SCALEString;\n    readonly type: SCALEString;\n    readonly value: SCALEBytes;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11Constant>;\n    protected scaleFields: (SCALEBytes | SCALEString | SCALEArray<SCALEString>)[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/v11/module/MetadataV11Error.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nexport declare class MetadataV11Error extends SCALEClass {\n    readonly name: SCALEString;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11Error>;\n    protected scaleFields: (SCALEString | SCALEArray<SCALEString>)[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/v11/module/MetadataV11Event.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nexport declare class MetadataV11Event extends SCALEClass {\n    readonly name: SCALEString;\n    readonly args: SCALEArray<SCALEString>;\n    readonly docs: SCALEArray<SCALEString>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11Event>;\n    scaleFields: (SCALEString | SCALEArray<SCALEString>)[];\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/v11/module/MetadataV11Module.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEClass } from '../../../scale/type/SCALEClass';\nimport { SCALEOptional } from '../../../scale/type/SCALEOptional';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../scale/type/SCALEType';\nimport { MetadataV11Call } from './MetadataV11Call';\nimport { MetadataV11Constant } from './MetadataV11Constants';\nimport { MetadataV11Error } from './MetadataV11Error';\nimport { MetadataV11Event } from './MetadataV11Event';\nimport { MetadataV11Storage } from './storage/MetadataV11Storage';\nexport declare class MetadataV11Module extends SCALEClass {\n    readonly name: SCALEString;\n    readonly storage: SCALEOptional<MetadataV11Storage>;\n    readonly calls: SCALEOptional<SCALEArray<MetadataV11Call>>;\n    readonly events: SCALEOptional<SCALEArray<MetadataV11Event>>;\n    readonly constants: SCALEArray<MetadataV11Constant>;\n    readonly errors: SCALEArray<MetadataV11Error>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV11Module>;\n    protected scaleFields: SCALEType[];\n    protected constructor(name: SCALEString, storage: SCALEOptional<MetadataV11Storage>, calls: SCALEOptional<SCALEArray<MetadataV11Call>>, events: SCALEOptional<SCALEArray<MetadataV11Event>>, constants: SCALEArray<MetadataV11Constant>, errors: SCALEArray<MetadataV11Error>);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/v11/MetadataV11.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SCALEArray } from '../../scale/type/SCALEArray';\nimport { SCALEInt } from '../../scale/type/SCALEInt';\nimport { SCALEType } from '../../scale/type/SCALEType';\nimport { MetadataDecorator } from '../decorator/MetadataDecorator';\nimport { MetadataVersioned } from '../MetadataVersioned';\nimport { MetadataV11Module } from './module/MetadataV11Module';\nexport declare class MetadataV11 extends MetadataVersioned {\n    readonly magicNumber: SCALEInt;\n    readonly version: SCALEInt;\n    readonly modules: SCALEArray<MetadataV11Module>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): MetadataV11;\n    protected scaleFields: SCALEType[];\n    protected constructor(magicNumber: SCALEInt, version: SCALEInt, modules: SCALEArray<MetadataV11Module>);\n    decorate(): MetadataDecorator;\n    private createDecoratedStorageEntries;\n    private createDecoratedCalls;\n    private createDecoratedConstants;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/v12/module/MetadataV12Module.d.ts",dts:"import { SubstrateNetwork } from '../../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../../scale/SCALEDecoder';\nimport { SCALEArray } from '../../../scale/type/SCALEArray';\nimport { SCALEInt } from '../../../scale/type/SCALEInt';\nimport { SCALEOptional } from '../../../scale/type/SCALEOptional';\nimport { SCALEString } from '../../../scale/type/SCALEString';\nimport { SCALEType } from '../../../scale/type/SCALEType';\nimport { MetadataV11Call } from '../../v11/module/MetadataV11Call';\nimport { MetadataV11Constant } from '../../v11/module/MetadataV11Constants';\nimport { MetadataV11Error } from '../../v11/module/MetadataV11Error';\nimport { MetadataV11Event } from '../../v11/module/MetadataV11Event';\nimport { MetadataV11Module } from '../../v11/module/MetadataV11Module';\nimport { MetadataV11Storage } from '../../v11/module/storage/MetadataV11Storage';\nexport declare class MetadataV12Module extends MetadataV11Module {\n    readonly index: SCALEInt;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<MetadataV12Module>;\n    protected scaleFields: SCALEType[];\n    protected constructor(name: SCALEString, storage: SCALEOptional<MetadataV11Storage>, calls: SCALEOptional<SCALEArray<MetadataV11Call>>, events: SCALEOptional<SCALEArray<MetadataV11Event>>, constants: SCALEArray<MetadataV11Constant>, errors: SCALEArray<MetadataV11Error>, index: SCALEInt);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/v12/MetadataV12.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SCALEArray } from '../../scale/type/SCALEArray';\nimport { SCALEInt } from '../../scale/type/SCALEInt';\nimport { MetadataDecorator } from '../decorator/MetadataDecorator';\nimport { MetadataVersioned } from '../MetadataVersioned';\nimport { MetadataV12Module } from './module/MetadataV12Module';\nexport declare class MetadataV12 extends MetadataVersioned {\n    readonly magicNumber: SCALEInt;\n    readonly version: SCALEInt;\n    readonly modules: SCALEArray<MetadataV12Module>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): MetadataV12;\n    protected scaleFields: SCALEInt[];\n    protected constructor(magicNumber: SCALEInt, version: SCALEInt, modules: SCALEArray<MetadataV12Module>);\n    decorate(): MetadataDecorator;\n    private createDecoratedStorageEntries;\n    private createDecoratedCalls;\n    private createDecoratedConstants;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/Metadata.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { MetadataDecorator } from './decorator/MetadataDecorator';\nimport { MetadataVersioned } from './MetadataVersioned';\nexport declare class Metadata {\n    readonly versioned: MetadataVersioned;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): Metadata;\n    private static assertMagicNumber;\n    private constructor();\n    decorate(): MetadataDecorator;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/metadata/MetadataVersioned.d.ts",dts:"import { SCALEInt } from '../scale/type/SCALEInt';\nimport { MetadataDecorator } from './decorator/MetadataDecorator';\nexport declare abstract class MetadataVersioned {\n    abstract readonly version: SCALEInt;\n    abstract decorate(): MetadataDecorator;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEAccountId.d.ts",dts:"/// <reference types=\"node\" />\nimport { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SubstrateAddress } from '../../account/SubstrateAddress';\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEAccountId extends SCALEType {\n    readonly address: SubstrateAddress;\n    static from(value: string | Uint8Array | Buffer | SubstrateAddress, network: SubstrateNetwork): SCALEAccountId;\n    static decode(network: SubstrateNetwork, hex: string): SCALEDecodeResult<SCALEAccountId>;\n    private constructor();\n    compare(other: SCALEAccountId): number;\n    asAddress(): string;\n    asBytes(): Buffer;\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEArray.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { DecoderMethod, SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEArray<T extends SCALEType> extends SCALEType {\n    readonly elements: T[];\n    static from<T extends SCALEType>(elements: T[]): SCALEArray<T>;\n    static decode<T extends SCALEType>(network: SubstrateNetwork, runtimeVersion: number | undefined, hex: string, decodeElement: DecoderMethod<T>): SCALEDecodeResult<SCALEArray<T>>;\n    protected constructor(elements: T[]);\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEBoolean.d.ts",dts:"import { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEBoolean extends SCALEType {\n    readonly value: boolean;\n    static from(value: boolean | number): SCALEBoolean;\n    static decode(hex: string): SCALEDecodeResult<SCALEBoolean>;\n    private constructor();\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEBytes.d.ts",dts:"/// <reference types=\"node\" />\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEBytes extends SCALEType {\n    readonly bytes: Buffer;\n    static from(bytes: string | Buffer | Uint8Array): SCALEBytes;\n    static decode(hex: string): SCALEDecodeResult<SCALEBytes>;\n    private constructor();\n    toString(encoding?: BufferEncoding): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEClass.d.ts",dts:"import { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare abstract class SCALEClass extends SCALEType {\n    protected abstract readonly scaleFields: SCALEType[];\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALECompactInt.d.ts",dts:"import BigNumber from '../../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEInt } from './SCALEInt';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\ndeclare type Number = SCALECompactInt | SCALEInt | BigNumber | number;\nexport declare class SCALECompactInt extends SCALEType {\n    readonly value: BigNumber;\n    static from(value: number | BigNumber | string): SCALECompactInt;\n    static decode(hex: string): SCALEDecodeResult<SCALECompactInt>;\n    private constructor();\n    toString(base?: number): string;\n    toNumber(): number;\n    plus(other: Number): SCALECompactInt;\n    minus(other: Number): SCALECompactInt;\n    multiply(other: Number): SCALECompactInt;\n    divide(other: Number): SCALECompactInt;\n    lt(other: Number): boolean;\n    lte(other: Number): boolean;\n    gt(other: Number): boolean;\n    gte(other: Number): boolean;\n    eq(other: Number): boolean;\n    protected _encode(config?: SCALEEncodeConfig): string;\n    private applyOperation;\n    private performOperation;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEData.d.ts",dts:"/// <reference types=\"node\" />\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare enum SCALEDataType {\n    None = 0,\n    Raw = 1,\n    BlakeTwo256 = 2,\n    Sha256 = 3,\n    Keccak256 = 4,\n    ShaThree256 = 5\n}\nexport declare class SCALEData extends SCALEType {\n    readonly type: SCALEDataType;\n    readonly bytes: Buffer | null;\n    static from(type: SCALEDataType, bytes?: string | Uint8Array | Buffer): SCALEData;\n    static decode(hex: string): SCALEDecodeResult<SCALEData>;\n    constructor(type: SCALEDataType, bytes: Buffer | null);\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEEnum.d.ts",dts:"import { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEEnum<T> extends SCALEType {\n    readonly value: T;\n    static from<T>(value: T): SCALEEnum<T>;\n    static decode<T>(hex: string, getEnumValue: (value: number) => T | null): SCALEDecodeResult<SCALEEnum<T>>;\n    private constructor();\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEEra.d.ts",dts:"import BigNumber from '../../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport interface EraConfig {\n    chainHeight: number | BigNumber;\n    period?: number | BigNumber;\n}\nexport declare class SCALEEra extends SCALEType {\n    readonly period: number;\n    readonly phase: number;\n    static Immortal(): SCALEEra;\n    static Mortal(config: EraConfig): SCALEEra;\n    readonly isMortal: boolean;\n    static decode(hex: string): SCALEDecodeResult<SCALEEra>;\n    private static decodeImmortal;\n    private static decodeMortal;\n    private constructor();\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n    private getTrailingZeros;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEHash.d.ts",dts:"/// <reference types=\"node\" />\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEHash extends SCALEType {\n    readonly value: Buffer;\n    static empty(bitLength?: number): SCALEHash;\n    static from(bytes: string | Buffer | Uint8Array): SCALEHash;\n    static decode(hex: string, bitLength: number): SCALEDecodeResult<SCALEHash>;\n    readonly isEmpty: boolean;\n    private constructor();\n    toString(encoding?: BufferEncoding): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEInt.d.ts",dts:"import BigNumber from '../../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALECompactInt } from './SCALECompactInt';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\ndeclare type Number = SCALECompactInt | SCALEInt | BigNumber | number;\nexport declare class SCALEInt extends SCALEType {\n    readonly value: BigNumber;\n    readonly bitLength?: number | undefined;\n    static from(value: number | BigNumber | string, bitLength?: number): SCALEInt;\n    static decode(hex: string, bitLength?: number): SCALEDecodeResult<SCALEInt>;\n    private constructor();\n    toString(base?: number): string;\n    toNumber(): number;\n    plus(other: Number): SCALEInt;\n    minus(other: Number): SCALEInt;\n    multiply(other: Number): SCALEInt;\n    divide(other: Number): SCALEInt;\n    lt(other: Number): boolean;\n    lte(other: Number): boolean;\n    gt(other: Number): boolean;\n    gte(other: Number): boolean;\n    eq(other: Number): boolean;\n    protected _encode(config?: SCALEEncodeConfig): string;\n    private applyOperation;\n    private performOperation;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEMultiAddress.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SubstrateAddress } from '../../account/SubstrateAddress';\nimport { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEAccountId } from './SCALEAccountId';\nimport { SCALEBytes } from './SCALEBytes';\nimport { SCALEHash } from './SCALEHash';\nimport { SCALEInt } from './SCALEInt';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare enum SCALEMultiAddressType {\n    Id = 0,\n    Index = 1,\n    Raw = 2,\n    Address32 = 3,\n    Address20 = 4\n}\ndeclare type SCALEMultiAddressValue<T extends SCALEMultiAddressType> = T extends SCALEMultiAddressType.Id ? SCALEAccountId : T extends SCALEMultiAddressType.Index ? SCALEInt : T extends SCALEMultiAddressType.Raw ? SCALEBytes : T extends SCALEMultiAddressType.Address32 ? SCALEHash : T extends SCALEMultiAddressType.Address20 ? SCALEHash : never;\nexport declare class SCALEMultiAddress<T extends SCALEMultiAddressType> extends SCALEType {\n    readonly type: T;\n    readonly value: SCALEMultiAddressValue<T>;\n    static isOfType<T extends SCALEMultiAddressType>(multiAddress: SCALEMultiAddress<SCALEMultiAddressType>, type: T): multiAddress is SCALEMultiAddress<T>;\n    static from(value: number | string | BigNumber, type: SCALEMultiAddressType.Index, network: SubstrateNetwork): SCALEMultiAddress<SCALEMultiAddressType.Index>;\n    static from<T extends Exclude<SCALEMultiAddressType, SCALEMultiAddressType.Index>>(value: string | Uint8Array | Buffer | SubstrateAddress, type: T, network: SubstrateNetwork): SCALEMultiAddress<T>;\n    static decode<T extends SCALEMultiAddressType = SCALEMultiAddressType>(network: SubstrateNetwork, hex: string, type?: T, runtimeVersion?: number): SCALEDecodeResult<SCALEMultiAddress<T>>;\n    private constructor();\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEOptional.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { DecoderMethod, SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare enum SCALEOptionalType {\n    None = 0,\n    Some = 1\n}\nexport declare class SCALEOptional<T extends SCALEType> extends SCALEType {\n    readonly value: T | undefined;\n    static empty<T extends SCALEType>(): SCALEOptional<T>;\n    static from<T extends SCALEType>(value: T): SCALEOptional<T>;\n    static decode<T extends SCALEType>(network: SubstrateNetwork, runtimeVersion: number | undefined, hex: string, decodeValue: DecoderMethod<T>): SCALEDecodeResult<SCALEOptional<T>>;\n    private readonly type;\n    private constructor();\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEString.d.ts",dts:"import { SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALEString extends SCALEType {\n    readonly value: string;\n    static from(value: string): SCALEString;\n    static decode(hex: string): SCALEDecodeResult<SCALEString>;\n    private constructor();\n    toCamelCase(options?: {\n        startUpper: boolean;\n    }): string;\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALETuple.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { DecoderMethod, SCALEDecodeResult } from '../SCALEDecoder';\nimport { SCALEEncodeConfig, SCALEType } from './SCALEType';\nexport declare class SCALETuple<T extends SCALEType, R extends SCALEType> extends SCALEType {\n    readonly first: T;\n    readonly second: R;\n    static from<T extends SCALEType, R extends SCALEType>(first: T, second: R): SCALETuple<T, R>;\n    static from<T extends SCALEType, R extends SCALEType>(tuple: [T, R]): SCALETuple<T, R>;\n    static decode<T extends SCALEType, R extends SCALEType>(network: SubstrateNetwork, runtimeVersion: number | undefined, hex: string, decodeFirst: DecoderMethod<T>, decodeSecond: DecoderMethod<R>): SCALEDecodeResult<SCALETuple<T, R>>;\n    private constructor();\n    toString(): string;\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/type/SCALEType.d.ts",dts:"import { SubstrateNetwork } from '../../../../SubstrateNetwork';\nexport interface SCALEEncodeConfig {\n    withPrefix?: boolean;\n    network?: SubstrateNetwork;\n    runtimeVersion?: number;\n}\nexport declare abstract class SCALEType {\n    encode(config?: SCALEEncodeConfig): string;\n    abstract toString(): string;\n    protected abstract _encode(config?: SCALEEncodeConfig): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/scale/SCALEDecoder.d.ts",dts:"/// <reference types=\"node\" />\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEAccountId } from './type/SCALEAccountId';\nimport { SCALEArray } from './type/SCALEArray';\nimport { SCALEBoolean } from './type/SCALEBoolean';\nimport { SCALEBytes } from './type/SCALEBytes';\nimport { SCALECompactInt } from './type/SCALECompactInt';\nimport { SCALEData } from './type/SCALEData';\nimport { SCALEEnum } from './type/SCALEEnum';\nimport { SCALEEra } from './type/SCALEEra';\nimport { SCALEHash } from './type/SCALEHash';\nimport { SCALEInt } from './type/SCALEInt';\nimport { SCALEMultiAddress, SCALEMultiAddressType } from './type/SCALEMultiAddress';\nimport { SCALEOptional } from './type/SCALEOptional';\nimport { SCALEString } from './type/SCALEString';\nimport { SCALETuple } from './type/SCALETuple';\nimport { SCALEType } from './type/SCALEType';\nexport declare type DecoderMethod<T> = (network: SubstrateNetwork, runtimeVersion: number | undefined, hex: string) => SCALEDecodeResult<T>;\nexport declare type DecoderPartialMethod<T> = (hex: string) => SCALEDecodeResult<T>;\nexport interface SCALEDecodeResult<T> {\n    bytesDecoded: number;\n    decoded: T;\n}\nexport declare class SCALEDecoder {\n    private readonly network;\n    private readonly runtimeVersion;\n    private hex;\n    constructor(network: SubstrateNetwork, runtimeVersion: number | undefined, bytes: string | Uint8Array | Buffer);\n    decodeNextAccountId(): SCALEDecodeResult<SCALEAccountId>;\n    decodeNextArray<T extends SCALEType>(decoderMethod: DecoderMethod<T>): SCALEDecodeResult<SCALEArray<T>>;\n    decodeNextBoolean(): SCALEDecodeResult<SCALEBoolean>;\n    decodeNextBytes(): SCALEDecodeResult<SCALEBytes>;\n    decodeNextCompactInt(): SCALEDecodeResult<SCALECompactInt>;\n    decodeNextEra(): SCALEDecodeResult<SCALEEra>;\n    decodeNextHash(bitLength: number): SCALEDecodeResult<SCALEHash>;\n    decodeNextInt(bitLength: number): SCALEDecodeResult<SCALEInt>;\n    decodeNextMultiAccount<T extends SCALEMultiAddressType>(type?: T): SCALEDecodeResult<SCALEMultiAddress<T>>;\n    decodeNextOptional<T extends SCALEType>(decoderMethod: DecoderMethod<T>): SCALEDecodeResult<SCALEOptional<T>>;\n    decodeNextString(): SCALEDecodeResult<SCALEString>;\n    decodeNextTuple<T extends SCALEType, R extends SCALEType>(firstDecoderMethod: DecoderMethod<T>, secondDecoderMethod: DecoderMethod<R>): SCALEDecodeResult<SCALETuple<T, R>>;\n    decodeNextEnum<T>(getEnumValue: (value: number) => T | null): SCALEDecodeResult<SCALEEnum<T>>;\n    decodeNextData(): SCALEDecodeResult<SCALEData>;\n    decodeNextObject<T>(decoderMethod: DecoderMethod<T>): SCALEDecodeResult<T>;\n    private decodeNextValuePartial;\n    private decodeNextValue;\n    private moveCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/staking/SubstrateActiveEraInfo.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nimport { SCALEOptional } from '../scale/type/SCALEOptional';\nexport declare class SubstrateActiveEraInfo {\n    readonly index: SCALEInt;\n    readonly start: SCALEOptional<SCALEInt>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SubstrateActiveEraInfo;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/staking/SubstrateEraElectionStatus.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEEnum } from '../scale/type/SCALEEnum';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nexport declare enum SubstrateElectionStatus {\n    CLOSED = 0,\n    OPEN = 1\n}\nexport declare class SubstrateEraElectionStatus {\n    status: SCALEEnum<SubstrateElectionStatus>;\n    blockNumber?: SCALEInt | undefined;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SubstrateEraElectionStatus;\n    constructor(status: SCALEEnum<SubstrateElectionStatus>, blockNumber?: SCALEInt | undefined);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/staking/SubstrateEraRewardPoints.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEAccountId } from '../scale/type/SCALEAccountId';\nimport { SCALEArray } from '../scale/type/SCALEArray';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nimport { SCALETuple } from '../scale/type/SCALETuple';\nexport declare class SubstrateEraRewardPoints {\n    readonly total: SCALEInt;\n    readonly individual: SCALEArray<SCALETuple<SCALEAccountId, SCALEInt>>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SubstrateEraRewardPoints;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/staking/SubstrateExposure.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEAccountId } from '../scale/type/SCALEAccountId';\nimport { SCALEArray } from '../scale/type/SCALEArray';\nimport { SCALECompactInt } from '../scale/type/SCALECompactInt';\nimport { SCALETuple } from '../scale/type/SCALETuple';\nexport declare class SubstrateExposure {\n    readonly total: SCALECompactInt;\n    readonly own: SCALECompactInt;\n    readonly others: SCALEArray<SCALETuple<SCALEAccountId, SCALECompactInt>>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SubstrateExposure;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/staking/SubstrateNominationStatus.d.ts",dts:"export declare enum SubstrateNominationStatus {\n    ACTIVE = 0,\n    INACTIVE = 1,\n    OVERSUBSCRIBED = 2\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/staking/SubstrateNominations.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEAccountId } from '../scale/type/SCALEAccountId';\nimport { SCALEArray } from '../scale/type/SCALEArray';\nimport { SCALEBoolean } from '../scale/type/SCALEBoolean';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nexport declare class SubstrateNominations {\n    readonly targets: SCALEArray<SCALEAccountId>;\n    readonly submittedIn: SCALEInt;\n    readonly suppressed: SCALEBoolean;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SubstrateNominations;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/staking/SubstrateNominatorDetails.d.ts",dts:"import { DelegatorDetails } from '../../../../ICoinDelegateProtocol';\nexport interface SubstrateLockedDetails {\n    value: string;\n    expectedUnlock: number;\n}\nexport interface SubstrateNominatorRewardDetails {\n    eraIndex: number;\n    amount: string;\n    exposures: [string, number][];\n    timestamp: number;\n}\nexport declare type SubstrateStakingStatus = 'bonded' | 'nominating' | 'nominating_waiting' | 'nominating_inactive';\nexport interface SubstrateStakingDetails {\n    total: string;\n    active: string;\n    unlocked: string;\n    locked: SubstrateLockedDetails[];\n    status: SubstrateStakingStatus;\n    nextEra: number;\n    rewards: SubstrateNominatorRewardDetails[];\n}\nexport interface SubstrateNominatorDetails extends DelegatorDetails {\n    stakingDetails?: SubstrateStakingDetails;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/staking/SubstratePayee.d.ts",dts:"export declare enum SubstratePayee {\n    STAKED = 0,\n    STASH = 1,\n    CONTROLLER = 2\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/staking/SubstrateSlashingSpans.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEArray } from '../scale/type/SCALEArray';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nexport declare class SubstrateSlashingSpans {\n    readonly spanIndex: SCALEInt;\n    readonly lastStart: SCALEInt;\n    readonly lastNonzeroSlash: SCALEInt;\n    readonly prior: SCALEArray<SCALEInt>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SubstrateSlashingSpans;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/staking/SubstrateStakingActionType.d.ts",dts:'export declare enum SubstrateStakingActionType {\n    BOND_NOMINATE = "bond_nominate",\n    REBOND_NOMINATE = "rebond_nominate",\n    NOMINATE = "nominate",\n    CANCEL_NOMINATION = "cancel_nomination",\n    CHANGE_NOMINATION = "change_nomination",\n    UNBOND = "unbond",\n    REBOND = "rebond",\n    BOND_EXTRA = "bond_extra",\n    REBOND_EXTRA = "rebond_extra",\n    WITHDRAW_UNBONDED = "withdraw_unbonded",\n    CHANGE_REWARD_DESTINATION = "change_reward_destination",\n    CHANGE_CONTROLLER = "change_controller"\n}\n'},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/staking/SubstrateStakingLedger.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEAccountId } from '../scale/type/SCALEAccountId';\nimport { SCALEArray } from '../scale/type/SCALEArray';\nimport { SCALECompactInt } from '../scale/type/SCALECompactInt';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nimport { SCALETuple } from '../scale/type/SCALETuple';\nexport declare class SubstrateStakingLedger {\n    readonly stash: SCALEAccountId;\n    readonly total: SCALECompactInt;\n    readonly active: SCALECompactInt;\n    readonly unlocking: SCALEArray<SCALETuple<SCALECompactInt, SCALECompactInt>>;\n    readonly claimedRewards: SCALEArray<SCALEInt>;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SubstrateStakingLedger;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/staking/SubstrateValidatorDetails.d.ts",dts:"import { DelegateeDetails } from '../../../../ICoinDelegateProtocol';\nexport declare type SubstrateValidatorStatus = 'Active' | 'Inactive' | 'Reaped';\nexport interface SubstrateValidatorRewardDetails {\n    amount: string;\n    totalStake: string;\n    ownStake: string;\n    commission: string;\n}\nexport interface SubstrateValidatorDetails extends DelegateeDetails {\n    status?: SubstrateValidatorStatus;\n    ownStash?: string;\n    totalStakingBalance?: string;\n    commission?: string;\n    lastEraReward?: SubstrateValidatorRewardDetails;\n    nominators: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/staking/SubstrateValidatorPrefs.d.ts",dts:"import { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALECompactInt } from '../scale/type/SCALECompactInt';\nexport declare class SubstrateValidatorPrefs {\n    readonly commission: SCALECompactInt;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SubstrateValidatorPrefs;\n    private constructor();\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/state/SubstrateRuntimeVersion.d.ts",dts:"export interface SubstrateRuntimeVersion {\n    specName: string;\n    implName: string;\n    authoringVersion: number;\n    specVersion: number;\n    implVersion: number;\n    apis: [string, number][];\n    transactionVersion: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/transaction/method/SubstrateTransactionMethod.d.ts",dts:"import { IAirGapTransaction } from '../../../../../../interfaces/IAirGapTransaction';\nimport { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../../scale/SCALEDecoder';\nimport { SCALEClass } from '../../scale/type/SCALEClass';\nimport { SCALEInt } from '../../scale/type/SCALEInt';\nimport { SCALEType } from '../../scale/type/SCALEType';\nimport { SubstrateTransactionType } from '../SubstrateTransaction';\nexport declare class SubstrateTransactionMethod extends SCALEClass {\n    readonly moduleIndex: SCALEInt;\n    readonly callIndex: SCALEInt;\n    readonly args: [string, SCALEType][];\n    readonly toAirGapTransactionParts: () => Partial<IAirGapTransaction>[];\n    static create(network: SubstrateNetwork, type: SubstrateTransactionType, moduleIndex: number, callIndex: number, args: any): SubstrateTransactionMethod;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, type: SubstrateTransactionType, raw: string): SCALEDecodeResult<SubstrateTransactionMethod>;\n    protected readonly scaleFields: (SCALEType | SCALEInt)[];\n    private constructor();\n    toString(): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/transaction/method/SubstrateTransactionMethodArgs.d.ts",dts:"import { IAirGapTransaction } from '../../../../../../interfaces/IAirGapTransaction';\nimport { SubstrateNetwork } from '../../../../SubstrateNetwork';\nimport { SCALEDecoder, SCALEDecodeResult } from '../../scale/SCALEDecoder';\nimport { SCALEType } from '../../scale/type/SCALEType';\nimport { SubstrateTransactionType } from '../SubstrateTransaction';\nexport declare abstract class SubstrateTransactionMethodArgsFactory<T> {\n    protected readonly network: SubstrateNetwork;\n    protected readonly args: T;\n    static create(network: SubstrateNetwork, type: SubstrateTransactionType, args: any): SubstrateTransactionMethodArgsFactory<any>;\n    protected constructor(network: SubstrateNetwork, args: T);\n    abstract createFields(): [string, SCALEType][];\n    abstract createToAirGapTransactionParts(): () => Partial<IAirGapTransaction>[];\n}\nexport declare abstract class SubstrateTransactionMethodArgsDecoder<T> {\n    static create(type: SubstrateTransactionType): SubstrateTransactionMethodArgsDecoder<any>;\n    decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<T>;\n    protected abstract _decode(decoder: SCALEDecoder): SCALEDecodeResult<T>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/transaction/SubstrateSignature.d.ts",dts:"/// <reference types=\"node\" />\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../scale/SCALEDecoder';\nimport { SCALEClass } from '../scale/type/SCALEClass';\nimport { SCALEEnum } from '../scale/type/SCALEEnum';\nimport { SCALEHash } from '../scale/type/SCALEHash';\nexport declare enum SubstrateSignatureType {\n    Ed25519 = 0,\n    Sr25519 = 1,\n    Ecdsa = 2\n}\nexport declare class SubstrateSignature extends SCALEClass {\n    readonly type: SCALEEnum<SubstrateSignatureType>;\n    readonly signature: SCALEHash;\n    static create(type: SubstrateSignatureType, signature?: string | Uint8Array | Buffer): SubstrateSignature;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, raw: string): SCALEDecodeResult<SubstrateSignature>;\n    protected scaleFields: (SCALEHash | SCALEEnum<SubstrateSignatureType>)[];\n    readonly isSigned: boolean;\n    private constructor();\n    toString(): string;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/transaction/SubstrateTransaction.d.ts",dts:"import BigNumber from '../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { IAirGapTransaction } from '../../../../../interfaces/IAirGapTransaction';\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SubstrateAccountId } from '../account/SubstrateAddress';\nimport { SubstrateCall } from '../metadata/decorator/call/SubstrateCall';\nimport { SCALEDecodeResult } from '../scale/SCALEDecoder';\nimport { SCALEClass } from '../scale/type/SCALEClass';\nimport { SCALECompactInt } from '../scale/type/SCALECompactInt';\nimport { EraConfig, SCALEEra } from '../scale/type/SCALEEra';\nimport { SCALEMultiAddress, SCALEMultiAddressType } from '../scale/type/SCALEMultiAddress';\nimport { SCALEEncodeConfig } from '../scale/type/SCALEType';\nimport { SubstrateTransactionMethod } from './method/SubstrateTransactionMethod';\nimport { SubstrateSignature } from './SubstrateSignature';\ninterface SubstrateTransactionConfig {\n    from: SubstrateAccountId;\n    args: any;\n    tip: number | BigNumber;\n    methodId: SubstrateCall;\n    era: EraConfig | null;\n    nonce: number | BigNumber;\n    signature?: SubstrateSignature;\n}\nexport declare enum SubstrateTransactionType {\n    TRANSFER = 0,\n    BOND = 1,\n    UNBOND = 2,\n    REBOND = 3,\n    BOND_EXTRA = 4,\n    WITHDRAW_UNBONDED = 5,\n    NOMINATE = 6,\n    CANCEL_NOMINATION = 7,\n    COLLECT_PAYOUT = 8,\n    SET_PAYEE = 9,\n    SET_CONTROLLER = 10,\n    SUBMIT_BATCH = 11\n}\nexport declare class SubstrateTransaction extends SCALEClass {\n    readonly network: SubstrateNetwork;\n    readonly type: SubstrateTransactionType;\n    readonly signer: SCALEMultiAddress<SCALEMultiAddressType.Id>;\n    readonly signature: SubstrateSignature;\n    readonly era: SCALEEra;\n    readonly nonce: SCALECompactInt;\n    readonly tip: SCALECompactInt;\n    readonly method: SubstrateTransactionMethod;\n    static create(network: SubstrateNetwork, type: SubstrateTransactionType, config: SubstrateTransactionConfig): SubstrateTransaction;\n    static fromTransaction(transaction: SubstrateTransaction, config?: Partial<SubstrateTransactionConfig>): SubstrateTransaction;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, type: SubstrateTransactionType, raw: string): SCALEDecodeResult<SubstrateTransaction>;\n    protected scaleFields: (SCALECompactInt | SCALEEra | SCALEMultiAddress<SCALEMultiAddressType.Id> | SubstrateTransactionMethod | SubstrateSignature)[];\n    private constructor();\n    toString(): string;\n    toAirGapTransactions(): Partial<IAirGapTransaction>[];\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/data/transaction/SubstrateTransactionPayload.d.ts",dts:"import BigNumber from '../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SubstrateNetwork } from '../../../SubstrateNetwork';\nimport { SCALEDecodeResult } from '../scale/SCALEDecoder';\nimport { SCALEClass } from '../scale/type/SCALEClass';\nimport { SCALECompactInt } from '../scale/type/SCALECompactInt';\nimport { SCALEEra } from '../scale/type/SCALEEra';\nimport { SCALEHash } from '../scale/type/SCALEHash';\nimport { SCALEInt } from '../scale/type/SCALEInt';\nimport { SCALEEncodeConfig } from '../scale/type/SCALEType';\nimport { SubstrateTransactionMethod } from './method/SubstrateTransactionMethod';\nimport { SubstrateTransaction, SubstrateTransactionType } from './SubstrateTransaction';\ninterface PayloadConfig {\n    lastHash: string;\n    genesisHash: string;\n    specVersion: number | BigNumber;\n    transactionVersion: number | BigNumber;\n}\nexport declare class SubstrateTransactionPayload extends SCALEClass {\n    readonly method: SubstrateTransactionMethod;\n    readonly era: SCALEEra;\n    readonly nonce: SCALECompactInt;\n    readonly tip: SCALECompactInt;\n    readonly specVersion: SCALEInt;\n    readonly transactionVersion: SCALEInt;\n    readonly genesisHash: SCALEHash;\n    readonly blockHash: SCALEHash;\n    static create(transaction: SubstrateTransaction, config: PayloadConfig): SubstrateTransactionPayload;\n    static decode(network: SubstrateNetwork, runtimeVersion: number | undefined, type: SubstrateTransactionType, hex: string): SCALEDecodeResult<SubstrateTransactionPayload>;\n    protected readonly scaleFields: (SCALECompactInt | SCALEInt | SCALEEra | SCALEHash | SubstrateTransactionMethod)[];\n    private constructor();\n    protected _encode(config?: SCALEEncodeConfig): string;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/node/SubstrateNodeCache.d.ts",dts:"interface CacheConfig {\n    cacheValue: boolean;\n}\nexport declare class SubstrateNodeCache {\n    expirationTime: number;\n    constructor(expirationTime: number);\n    private readonly cachedValues;\n    private readonly promises;\n    get<T>(key: string): Promise<T>;\n    save(key: string, promise: Promise<any>, config?: CacheConfig): Promise<any>;\n    private isValidOrDelete;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/node/SubstrateNodeClient.d.ts",dts:"import BigNumber from '../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SubstrateNetwork } from '../../SubstrateNetwork';\nimport { SubstrateAccountInfo } from '../data/account/SubstrateAccountInfo';\nimport { SubstrateAddress } from '../data/account/SubstrateAddress';\nimport { SubstrateRegistration } from '../data/account/SubstrateRegistration';\nimport { SubstrateCall } from '../data/metadata/decorator/call/SubstrateCall';\nimport { SCALEAccountId } from '../data/scale/type/SCALEAccountId';\nimport { SCALEArray } from '../data/scale/type/SCALEArray';\nimport { SCALECompactInt } from '../data/scale/type/SCALECompactInt';\nimport { SCALEData } from '../data/scale/type/SCALEData';\nimport { SCALETuple } from '../data/scale/type/SCALETuple';\nimport { SubstrateActiveEraInfo } from '../data/staking/SubstrateActiveEraInfo';\nimport { SubstrateEraElectionStatus } from '../data/staking/SubstrateEraElectionStatus';\nimport { SubstrateEraRewardPoints } from '../data/staking/SubstrateEraRewardPoints';\nimport { SubstrateExposure } from '../data/staking/SubstrateExposure';\nimport { SubstrateNominations } from '../data/staking/SubstrateNominations';\nimport { SubstratePayee } from '../data/staking/SubstratePayee';\nimport { SubstrateSlashingSpans } from '../data/staking/SubstrateSlashingSpans';\nimport { SubstrateStakingLedger } from '../data/staking/SubstrateStakingLedger';\nimport { SubstrateValidatorPrefs } from '../data/staking/SubstrateValidatorPrefs';\nimport { SubstrateRuntimeVersion } from '../data/state/SubstrateRuntimeVersion';\nimport { SubstrateTransactionType } from '../data/transaction/SubstrateTransaction';\nimport { SubstrateNodeCache } from './SubstrateNodeCache';\nexport declare class SubstrateNodeClient {\n    private readonly network;\n    private readonly baseURL;\n    private readonly cache;\n    private metadata;\n    private runtimeVersion;\n    private readonly lastFees;\n    private initApiPromise;\n    constructor(network: SubstrateNetwork, baseURL: string, cache?: SubstrateNodeCache);\n    getAccountInfo(address: SubstrateAddress): Promise<SubstrateAccountInfo | null>;\n    getExistentialDeposit(): Promise<BigNumber>;\n    getTransactionMetadata(type: SubstrateTransactionType): Promise<SubstrateCall>;\n    getTransferFeeEstimate(transaction: Uint8Array | string): Promise<BigNumber | null>;\n    saveLastFee(type: SubstrateTransactionType, fee: BigNumber): void;\n    getSavedLastFee(type: SubstrateTransactionType, defaultValue?: 'null' | 'largest'): BigNumber | null;\n    getFirstBlockHash(): Promise<string | null>;\n    getLastBlockHash(): Promise<string | null>;\n    getCurrentHeight(): Promise<BigNumber>;\n    getCurrentEraIndex(): Promise<BigNumber | null>;\n    getRuntimeVersion(): Promise<SubstrateRuntimeVersion | null>;\n    getBonded(address: SubstrateAddress): Promise<SubstrateAddress | null>;\n    getNominations(address: SubstrateAddress): Promise<SubstrateNominations | null>;\n    getRewardPoints(eraIndex: number): Promise<SubstrateEraRewardPoints | null>;\n    getValidatorReward(eraIndex: number): Promise<BigNumber | null>;\n    getStakersClipped(eraIndex: number, validator: SubstrateAddress): Promise<SubstrateExposure | null>;\n    getRewardDestination(address: SubstrateAddress): Promise<SubstratePayee | null>;\n    getStakingLedger(address: SubstrateAddress): Promise<SubstrateStakingLedger | null>;\n    getValidators(): Promise<SubstrateAddress[] | null>;\n    getValidatorExposure(eraIndex: number, address: SubstrateAddress): Promise<SubstrateExposure | null>;\n    getElectionStatus(): Promise<SubstrateEraElectionStatus | null>;\n    getIdentityOf(address: SubstrateAddress): Promise<SubstrateRegistration | null>;\n    getSuperOf(address: SubstrateAddress): Promise<SCALETuple<SCALEAccountId, SCALEData> | null>;\n    getSubsOf(address: SubstrateAddress): Promise<SCALETuple<SCALECompactInt, SCALEArray<SCALEAccountId>> | null>;\n    getValidatorPrefs(eraIndex: number, address: SubstrateAddress): Promise<SubstrateValidatorPrefs | null>;\n    getExpectedEraDuration(): Promise<BigNumber | null>;\n    getActiveEraInfo(): Promise<SubstrateActiveEraInfo | null>;\n    getSlashingSpan(address: SubstrateAddress): Promise<SubstrateSlashingSpans | null>;\n    submitTransaction(encoded: string): Promise<string>;\n    private getBlockHash;\n    private fromStorage;\n    private getCall;\n    private getConstant;\n    private initApi;\n    private initCache;\n    private send;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/node/supported.d.ts",dts:'import { SubstrateTransactionType } from \'../data/transaction/SubstrateTransaction\';\nexport declare const supportedRpcMethods: {\n    author: readonly ["submitExtrinsic"];\n    chain: readonly ["getBlock", "getBlockHash"];\n    state: readonly ["getMetadata", "getStorage", "getRuntimeVersion"];\n    payment: readonly ["queryInfo"];\n};\nexport declare const supportedStorageEntries: {\n    Identity: readonly ["IdentityOf", "SuperOf", "SubsOf"];\n    Staking: readonly ["Bonded", "Ledger", "Payee", "Nominators", "CurrentEra", "ActiveEra", "EraElectionStatus", "ErasStakers", "ErasStakersClipped", "ErasValidatorPrefs", "ErasValidatorReward", "ErasRewardPoints", "SlashingSpans"];\n    Session: readonly ["Validators"];\n    System: readonly ["Account"];\n};\nexport declare const supportedCalls: {\n    Balances: readonly ["transfer"];\n    Staking: readonly ["bond", "bond_extra", "unbond", "withdraw_unbonded", "nominate", "chill", "set_payee", "set_controller", "payout_stakers", "rebond"];\n    Utility: readonly ["batch"];\n};\nexport declare const supportedConstants: {\n    Babe: readonly ["EpochDuration", "ExpectedBlockTime"];\n    Balances: readonly ["ExistentialDeposit"];\n    Staking: readonly ["SessionsPerEra"];\n};\nexport declare type SubstrateRpcModuleName = keyof typeof supportedRpcMethods;\nexport declare type SubstrateRpcMethodName<T extends SubstrateRpcModuleName> = {\n    [S in T]: typeof supportedRpcMethods[S][number];\n}[T];\nexport declare type SubstrateStorageModuleName = keyof typeof supportedStorageEntries;\nexport declare type SubstrateStorageEntryName<T extends SubstrateStorageModuleName> = {\n    [S in T]: typeof supportedStorageEntries[S][number];\n}[T];\nexport declare type SubstrateCallModuleName = keyof typeof supportedCalls;\nexport declare type SubstrateCallName<T extends SubstrateCallModuleName> = {\n    [S in T]: typeof supportedCalls[S][number];\n}[T];\nexport declare type SubstrateConstantModuleName = keyof typeof supportedConstants;\nexport declare type SubstrateConstantName<T extends SubstrateConstantModuleName> = {\n    [S in T]: typeof supportedConstants[S][number];\n}[T];\nexport declare const supportedCallEndpoints: Map<SubstrateTransactionType, [SubstrateCallModuleName, SubstrateCallName<any>]>;\n'},{name:"@airgap/coinlib-core/protocols/substrate/helpers/SubstrateAccountController.d.ts",dts:"import { KeyPair } from '../../../data/KeyPair';\nimport BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nimport { SubstrateAccountId } from './data/account/SubstrateAddress';\nimport { SubstrateNominationStatus } from './data/staking/SubstrateNominationStatus';\nimport { SubstrateNominatorDetails } from './data/staking/SubstrateNominatorDetails';\nimport { SubstrateValidatorDetails } from './data/staking/SubstrateValidatorDetails';\nimport { SubstrateNodeClient } from './node/SubstrateNodeClient';\nexport declare class SubstrateAccountController {\n    readonly network: SubstrateNetwork;\n    readonly nodeClient: SubstrateNodeClient;\n    constructor(network: SubstrateNetwork, nodeClient: SubstrateNodeClient);\n    createKeyPairFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<KeyPair>;\n    createKeyPairFromHexSecret(secret: string, derivationPath: string): Promise<KeyPair>;\n    createAddressFromPublicKey(publicKey: string): Promise<string>;\n    getBalance(accountId: SubstrateAccountId): Promise<BigNumber>;\n    getTransferableBalance(accountId: SubstrateAccountId, excludeExistentialDeposit?: boolean, ignoreFees?: boolean): Promise<BigNumber>;\n    getUnlockingBalance(accountId: SubstrateAccountId): Promise<BigNumber>;\n    isBonded(accountId: SubstrateAccountId): Promise<boolean>;\n    isNominating(accountId: SubstrateAccountId): Promise<boolean>;\n    getCurrentValidators(accountId: SubstrateAccountId): Promise<string[]>;\n    getValidatorDetails(accountId: SubstrateAccountId): Promise<SubstrateValidatorDetails>;\n    getNominatorDetails(accountId: SubstrateAccountId, validatorIds?: SubstrateAccountId[]): Promise<SubstrateNominatorDetails>;\n    getNominationStatus(nominator: SubstrateAccountId, validator: SubstrateAccountId, era?: number): Promise<SubstrateNominationStatus | undefined>;\n    getSlashingSpansNumber(accountId: SubstrateAccountId): Promise<number>;\n    private getStakingDetails;\n    private getUnlockingDetails;\n    private getStakingStatus;\n    private getEraValidatorReward;\n    private getNominatorRewards;\n    private calculateEraNominatorReward;\n    private calculateValidatorReward;\n    private calculateNominatorReward;\n    private getAvailableStakingActions;\n    private getAccountIdentityInfo;\n    private partitionArray;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/helpers/SubstrateTransactionController.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nimport { SubstrateAccountId } from './data/account/SubstrateAddress';\nimport { SubstrateTransactionMethod } from './data/transaction/method/SubstrateTransactionMethod';\nimport { SubstrateTransaction, SubstrateTransactionType } from './data/transaction/SubstrateTransaction';\nimport { SubstrateNodeClient } from './node/SubstrateNodeClient';\nexport interface SubstrateTransactionDetails {\n    runtimeVersion: number | undefined;\n    fee: BigNumber;\n    transaction: SubstrateTransaction;\n    payload: string;\n}\nexport interface SubstrateTransactionConfig {\n    type: SubstrateTransactionType;\n    tip: string | number | BigNumber;\n    args: any;\n}\nexport declare class SubstrateTransactionController {\n    readonly network: SubstrateNetwork;\n    readonly nodeClient: SubstrateNodeClient;\n    constructor(network: SubstrateNetwork, nodeClient: SubstrateNodeClient);\n    prepareSubmittableTransactions(accountId: SubstrateAccountId, available: BigNumber | string, txConfig: SubstrateTransactionConfig[]): Promise<string>;\n    createTransaction(type: SubstrateTransactionType, accountId: SubstrateAccountId, tip?: string | number | BigNumber, args?: any, chainHeight?: number | BigNumber, nonce?: number | BigNumber): Promise<SubstrateTransaction>;\n    createTransactionMethod(type: SubstrateTransactionType, args?: any): Promise<SubstrateTransactionMethod>;\n    signTransaction(privateKey: Buffer, transaction: SubstrateTransaction, payload: string): Promise<SubstrateTransaction>;\n    encodeDetails(txs: SubstrateTransactionDetails[]): string;\n    decodeDetails(serialized: string): SubstrateTransactionDetails[];\n    calculateTransactionFee(transaction: SubstrateTransaction): Promise<BigNumber | null>;\n    estimateTransactionFees(accountId: SubstrateAccountId, transationTypes: [SubstrateTransactionType, any][]): Promise<BigNumber | null>;\n    private prepareTransactionDetails;\n    private signPayload;\n    private signSr25519Payload;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/implementations/KusamaProtocol.d.ts",dts:"import { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults } from '../../ICoinProtocol';\nimport { SubstrateProtocol } from '../SubstrateProtocol';\nimport { SubstrateProtocolOptions } from '../SubstrateProtocolOptions';\nexport declare class KusamaProtocol extends SubstrateProtocol {\n    readonly options: SubstrateProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    feeDefaults: FeeDefaults;\n    units: CurrencyUnit[];\n    standardDerivationPath: string;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    protected defaultValidator: string;\n    constructor(options?: SubstrateProtocolOptions);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/implementations/KusamaProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../../utils/ProtocolNetwork';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nimport { PolkascanBlockExplorer, SubstrateProtocolConfig, SubstrateProtocolOptions } from '../SubstrateProtocolOptions';\nexport declare class KusamaProtocolNetworkExtras {\n    readonly apiUrl: string;\n    readonly network: SubstrateNetwork;\n    constructor(apiUrl?: string, network?: SubstrateNetwork);\n}\nexport declare class KusamaPolkascanBlockExplorer extends PolkascanBlockExplorer {\n    constructor(blockExplorer?: string);\n}\nexport declare class KusamaProtocolConfig extends SubstrateProtocolConfig {\n    constructor();\n}\nexport declare class KusamaProtocolNetwork extends ProtocolNetwork<KusamaProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: KusamaProtocolNetworkExtras);\n}\nexport declare class KusamaProtocolOptions extends SubstrateProtocolOptions<KusamaProtocolConfig> {\n    readonly network: KusamaProtocolNetwork;\n    readonly config: KusamaProtocolConfig;\n    constructor(network?: KusamaProtocolNetwork, config?: KusamaProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/implementations/PolkadotProtocol.d.ts",dts:"import { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { CurrencyUnit, FeeDefaults } from '../../ICoinProtocol';\nimport { SubstrateProtocol } from '../SubstrateProtocol';\nimport { SubstrateProtocolOptions } from '../SubstrateProtocolOptions';\nexport declare class PolkadotProtocol extends SubstrateProtocol {\n    readonly options: SubstrateProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    feeDefaults: FeeDefaults;\n    units: CurrencyUnit[];\n    standardDerivationPath: string;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    protected defaultValidator: string;\n    constructor(options?: SubstrateProtocolOptions);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/implementations/PolkadotProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../../utils/ProtocolNetwork';\nimport { SubstrateNetwork } from '../SubstrateNetwork';\nimport { PolkascanBlockExplorer, SubstrateProtocolConfig, SubstrateProtocolOptions } from '../SubstrateProtocolOptions';\nexport declare class PolkadotProtocolNetworkExtras {\n    readonly apiUrl: string;\n    readonly network: SubstrateNetwork;\n    constructor(apiUrl?: string, network?: SubstrateNetwork);\n}\nexport declare class PolkadotPolkascanBlockExplorer extends PolkascanBlockExplorer {\n    constructor(blockExplorer?: string);\n}\nexport declare class PolkadotProtocolConfig extends SubstrateProtocolConfig {\n    constructor();\n}\nexport declare class PolkadotProtocolNetwork extends ProtocolNetwork<PolkadotProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: PolkadotProtocolNetworkExtras);\n}\nexport declare class PolkadotProtocolOptions extends SubstrateProtocolOptions<PolkadotProtocolConfig> {\n    readonly network: PolkadotProtocolNetwork;\n    readonly config: PolkadotProtocolConfig;\n    constructor(network?: PolkadotProtocolNetwork, config?: PolkadotProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/SubstrateCryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { Sr25519CryptoClient } from '../Sr25519CryptoClient';\nexport declare class SubstrateCryptoClient extends Sr25519CryptoClient {\n    constructor();\n    signMessage(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/SubstrateNetwork.d.ts",dts:"export declare enum SubstrateNetwork {\n    POLKADOT = 0,\n    KUSAMA = 1\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/SubstrateProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { AirGapTransactionStatus, IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { SignedSubstrateTransaction } from '../../serializer/schemas/definitions/signed-transaction-substrate';\nimport { UnsignedSubstrateTransaction } from '../../serializer/schemas/definitions/unsigned-transaction-substrate';\nimport { RawSubstrateTransaction } from '../../serializer/types';\nimport { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { DelegateeDetails, DelegationDetails, DelegatorDetails, ICoinDelegateProtocol } from '../ICoinDelegateProtocol';\nimport { CurrencyUnit, FeeDefaults } from '../ICoinProtocol';\nimport { ICoinSubProtocol } from '../ICoinSubProtocol';\nimport { NonExtendedProtocol } from '../NonExtendedProtocol';\nimport { SubstrateAccountId } from './helpers/data/account/SubstrateAddress';\nimport { SubstratePayee } from './helpers/data/staking/SubstratePayee';\nimport { SubstrateStakingActionType } from './helpers/data/staking/SubstrateStakingActionType';\nimport { SubstrateTransactionType } from './helpers/data/transaction/SubstrateTransaction';\nimport { SubstrateCryptoClient } from './SubstrateCryptoClient';\nimport { SubstrateProtocolOptions } from './SubstrateProtocolOptions';\nimport { SubstrateTransactionCursor, SubstrateTransactionResult } from './SubstrateTypes';\nexport declare abstract class SubstrateProtocol extends NonExtendedProtocol implements ICoinDelegateProtocol {\n    readonly options: SubstrateProtocolOptions;\n    abstract symbol: string;\n    abstract name: string;\n    abstract marketSymbol: string;\n    abstract feeSymbol: string;\n    abstract decimals: number;\n    abstract feeDecimals: number;\n    abstract identifier: ProtocolSymbols;\n    abstract feeDefaults: FeeDefaults;\n    abstract units: CurrencyUnit[];\n    abstract standardDerivationPath: string;\n    supportsHD: boolean;\n    addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    protected defaultValidator?: string;\n    readonly cryptoClient: SubstrateCryptoClient;\n    constructor(options: SubstrateProtocolOptions);\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getAddressFromPublicKey(publicKey: string): Promise<string>;\n    getAddressesFromPublicKey(publicKey: string): Promise<string[]>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: SubstrateTransactionCursor): Promise<SubstrateTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: SubstrateTransactionCursor): Promise<SubstrateTransactionResult>;\n    signWithPrivateKey(privateKey: Buffer, rawTransaction: RawSubstrateTransaction): Promise<string>;\n    getTransactionDetails(transaction: UnsignedSubstrateTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(transaction: SignedSubstrateTransaction): Promise<IAirGapTransaction[]>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getAvailableBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: any): Promise<RawSubstrateTransaction>;\n    broadcastTransaction(encoded: string): Promise<string>;\n    getDefaultDelegatee(): Promise<string>;\n    getCurrentDelegateesForPublicKey(publicKey: string): Promise<string[]>;\n    getCurrentDelegateesForAddress(address: string): Promise<string[]>;\n    getDelegateeDetails(address: string): Promise<DelegateeDetails>;\n    isPublicKeyDelegating(publicKey: string): Promise<boolean>;\n    isAddressDelegating(address: string): Promise<boolean>;\n    getDelegatorDetailsFromPublicKey(publicKey: string): Promise<DelegatorDetails>;\n    getDelegatorDetailsFromAddress(address: string): Promise<DelegatorDetails>;\n    getDelegationDetailsFromPublicKey(publicKey: string, delegatees: string[]): Promise<DelegationDetails>;\n    getDelegationDetailsFromAddress(address: string, delegatees: string[]): Promise<DelegationDetails>;\n    prepareDelegatorActionFromPublicKey(publicKey: string, type: SubstrateStakingActionType, data?: any): Promise<RawSubstrateTransaction[]>;\n    prepareDelegation(publicKey: string, tip: string | number | BigNumber, targets: string[] | string, controller?: string, value?: string | number | BigNumber, payee?: string | SubstratePayee): Promise<RawSubstrateTransaction[]>;\n    prepareRebondNominate(publicKey: string, tip: string | number | BigNumber, targets: string[] | string, value: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareCancelDelegation(publicKey: string, tip: string | number | BigNumber, value?: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareChangeValidator(publicKey: string, tip: string | number | BigNumber, targets: string[] | string): Promise<RawSubstrateTransaction[]>;\n    prepareUnbond(publicKey: string, tip: string | number | BigNumber, value: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareRebond(publicKey: string, tip: string | number | BigNumber, value: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareBondExtra(publicKey: string, tip: string | number | BigNumber, value: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareRebondExtra(publicKey: string, tip: string | number | BigNumber, value: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    prepareWithdrawUnbonded(publicKey: string, tip: string | number | BigNumber): Promise<RawSubstrateTransaction[]>;\n    estimateMaxDelegationValueFromAddress(address: string): Promise<string>;\n    getFutureRequiredTransactions(accountId: SubstrateAccountId, intention: 'check' | 'transfer' | 'delegate'): Promise<[SubstrateTransactionType, any][]>;\n    private getTransactionDetailsFromEncoded;\n    signMessage(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(message: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(message: string, privateKey: Buffer): Promise<string>;\n    decryptAES(message: string, privateKey: Buffer): Promise<string>;\n    getTransactionStatuses(transactionHashes: string[]): Promise<AirGapTransactionStatus[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/SubstrateProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nimport { SubstrateBlockExplorerClient } from './helpers/blockexplorer/SubstrateBlockExplorerClient';\nimport { SubstrateNodeClient } from './helpers/node/SubstrateNodeClient';\nimport { SubstrateAccountController } from './helpers/SubstrateAccountController';\nimport { SubstrateTransactionController } from './helpers/SubstrateTransactionController';\nimport { SubstrateNetwork } from './SubstrateNetwork';\nexport declare class SubstrateProtocolNetworkExtras {\n    readonly apiUrl: string;\n    readonly network: SubstrateNetwork;\n    constructor(apiUrl: string, network: SubstrateNetwork);\n}\nexport declare class PolkascanBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class SubstrateProtocolConfig {\n    constructor();\n}\nexport declare class SubstrateProtocolNetwork extends ProtocolNetwork<SubstrateProtocolNetworkExtras> {\n    constructor(name: string | undefined, type: NetworkType | undefined, rpcUrl: string, blockExplorer: ProtocolBlockExplorer, extras: SubstrateProtocolNetworkExtras);\n}\nexport declare class SubstrateProtocolOptions<T extends SubstrateProtocolConfig = SubstrateProtocolConfig> implements ProtocolOptions<T> {\n    readonly network: SubstrateProtocolNetwork;\n    readonly config: T;\n    readonly nodeClient: SubstrateNodeClient;\n    readonly blockExplorerClient: SubstrateBlockExplorerClient;\n    readonly accountController: SubstrateAccountController;\n    readonly transactionController: SubstrateTransactionController;\n    constructor(network: SubstrateProtocolNetwork, config: T);\n}\n"},{name:"@airgap/coinlib-core/protocols/substrate/SubstrateTypes.d.ts",dts:"import { IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nexport interface SubstrateTransactionCursor {\n    page: number;\n}\nexport interface SubstrateTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: SubstrateTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/contract/TezosContract.d.ts",dts:"import { BigMapRequest } from '../types/fa/BigMapRequest';\nimport { BigMapResponse } from '../types/fa/BigMapResult';\nimport { MichelineNode } from '../types/micheline/MichelineNode';\nimport { TezosTransactionParameters } from '../types/operations/Transaction';\nimport { TezosContractCall } from './TezosContractCall';\nimport { TezosContractEntrypoint } from './TezosContractEntrypoint';\nexport declare class TezosContract {\n    private readonly address;\n    private readonly nodeRPCURL;\n    private readonly conseilAPIURL;\n    private readonly conseilNetwork;\n    private readonly conseilAPIKey;\n    private static readonly DEFAULT_ENTRYPOINT;\n    entrypoints?: Map<string, TezosContractEntrypoint>;\n    entrypointsPromise?: Promise<void>;\n    bigMapIDs?: number[];\n    bigMapIDsPromise?: Promise<void>;\n    constructor(address: string, nodeRPCURL: string, conseilAPIURL: string, conseilNetwork: string, conseilAPIKey: string);\n    bigMapValues(request?: BigMapRequest): Promise<BigMapResponse[]>;\n    createContractCall(entrypointName: string, value: unknown): Promise<TezosContractCall>;\n    parseContractCall(json: TezosTransactionParameters): Promise<TezosContractCall>;\n    normalizeContractCallParameters(json: (Partial<TezosTransactionParameters> & Pick<TezosTransactionParameters, 'value'>) | MichelineNode, fallbackEntrypoint?: string): Promise<TezosTransactionParameters>;\n    private createDefaultContractCall;\n    private createEntrypointContractCall;\n    private getBigMapID;\n    private waitForBigMapIDs;\n    private waitForEntrypoints;\n    private nodeRequest;\n    private apiRequest;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/contract/TezosContractCall.d.ts",dts:"import { MichelsonType } from '../types/michelson/MichelsonType';\nimport { TezosTransactionParameters } from '../types/operations/Transaction';\nexport declare class TezosContractCall {\n    readonly entrypoint: string;\n    readonly michelsonValue: MichelsonType | undefined;\n    constructor(entrypoint: string, michelsonValue: MichelsonType | undefined);\n    args(): any | undefined;\n    toJSON(): TezosTransactionParameters;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/contract/TezosContractEntrypoint.d.ts",dts:"import { MichelineTypeNode } from '../types/micheline/MichelineNode';\nimport { MichelsonTypeMeta } from '../types/michelson/MichelsonTypeMeta';\nexport declare class TezosContractEntrypoint {\n    readonly name: string;\n    readonly type: MichelsonTypeMeta;\n    static fromJSON(entrypoints: Record<string, MichelineTypeNode>): TezosContractEntrypoint[];\n    constructor(name: string, type: MichelsonTypeMeta);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosBTC.d.ts",dts:"import { TezosFA12Protocol } from './TezosFA12Protocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosBTC extends TezosFA12Protocol {\n    readonly options: TezosFAProtocolOptions;\n    private static readonly bigMapKeyLedgerPrefix;\n    constructor(options?: TezosFAProtocolOptions);\n    getTotalMinted(source?: string, callbackContract?: string): Promise<string>;\n    getTotalBurned(source?: string, callbackContract?: string): Promise<string>;\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosETHtz.d.ts",dts:"import { TezosFA12Protocol } from './TezosFA12Protocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosETHtz extends TezosFA12Protocol {\n    readonly options: TezosFAProtocolOptions;\n    private static extractAmountRegex;\n    constructor(options?: TezosFAProtocolOptions);\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosFA12Protocol.d.ts",dts:"import { RawTezosTransaction } from '../../../serializer/types';\nimport { TezosFA1Protocol } from './TezosFA1Protocol';\nexport declare class TezosFA12Protocol extends TezosFA1Protocol {\n    getAllowance(ownerAddress: string, spenderAddress: string, callbackContract?: string, source?: string): Promise<string>;\n    approve(spenderAddress: string, amount: string, fee: string, publicKey: string): Promise<RawTezosTransaction>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosFA1Protocol.d.ts",dts:"import { IAirGapTransaction } from '../../..';\nimport { RawTezosTransaction } from '../../../serializer/types';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { TezosContractCall } from '../contract/TezosContractCall';\nimport { TezosTransactionParameters } from '../types/operations/Transaction';\nimport { TezosFAProtocol } from './TezosFAProtocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosFA1Protocol extends TezosFAProtocol {\n    private readonly defaultCallbackContractMap;\n    constructor(options: TezosFAProtocolOptions);\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: {\n        addressIndex: number;\n    }): Promise<RawTezosTransaction>;\n    transactionDetailsFromParameters(parameters: TezosTransactionParameters): Partial<IAirGapTransaction>[];\n    getBalance(address: string, source?: string, callbackContract?: string): Promise<string>;\n    getTotalSupply(source?: string, callbackContract?: string): Promise<string>;\n    transfer(fromAddress: string, toAddress: string, amount: string, fee: string, publicKey: string): Promise<RawTezosTransaction>;\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n    protected getContractCallIntResult(transferCall: TezosContractCall, source: string): Promise<string>;\n    private createTransferCalls;\n    protected callbackContract(): string;\n    private isTransferRequest;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosFA2Protocol.d.ts",dts:"import { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { RawTezosTransaction } from '../../../serializer/types';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { TezosFA2BalanceOfRequest } from '../types/fa/TezosFA2BalanceOfRequest';\nimport { TezosFA2BalanceOfResponse } from '../types/fa/TezosFA2BalanceOfResponse';\nimport { TezosFA2TokenMetadata } from '../types/fa/TezosFA2TokenMetadata';\nimport { TezosFA2TransferRequest } from '../types/fa/TezosFA2TransferRequest';\nimport { TezosFA2UpdateOperatorRequest } from '../types/fa/TezosFA2UpdateOperatorRequest';\nimport { TezosTransactionParameters } from '../types/operations/Transaction';\nimport { TezosFAProtocol } from './TezosFAProtocol';\nimport { TezosFA2ProtocolOptions } from './TezosFAProtocolOptions';\ndeclare enum TezosFA2ContractEntrypoint {\n    BALANCE = \"balance_of\",\n    TRANSFER = \"transfer\",\n    UPDATE_OPERATORS = \"update_operators\",\n    TOKEN_METADATA_REGISTRY = \"token_metadata_registry\",\n    TOKEN_METADATA = \"token_metadata\"\n}\nexport declare class TezosFA2Protocol extends TezosFAProtocol {\n    private static DEFAULT_TOKEN_METADATA_BIG_MAP_NAME;\n    private static DEFAULT_TOKEN_METADATA_BIG_MAP_VALUE_REGEX;\n    readonly tokenID?: number;\n    readonly tokenMetadataBigMapID?: number;\n    readonly tokenMetadataBigMapName: string;\n    readonly tokenMedatadaBigMapValueRegex: RegExp;\n    private readonly defaultCallbackContract;\n    constructor(options: TezosFA2ProtocolOptions);\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: any): Promise<RawTezosTransaction>;\n    transactionDetailsFromParameters(parameters: TezosTransactionParameters): Partial<IAirGapTransaction>[];\n    balanceOf(balanceRequests: TezosFA2BalanceOfRequest[], source?: string, callbackContract?: string): Promise<TezosFA2BalanceOfResponse[]>;\n    transfer(transferRequests: TezosFA2TransferRequest[], fee: string, publicKey: string): Promise<RawTezosTransaction>;\n    updateOperators(updateRequests: TezosFA2UpdateOperatorRequest[], fee: string, publicKey: string): Promise<RawTezosTransaction>;\n    tokenMetadataRegistry(source?: string, callbackContract?: string): Promise<string>;\n    tokenMetadata(tokenIDs: number[], handler: string, fee: string, publicKey: string): Promise<RawTezosTransaction>;\n    getTokenMetadata(tokenIDs?: number[]): Promise<TezosFA2TokenMetadata[]>;\n    fetchTokenHolders(tokenIDs: number[]): Promise<{\n        address: string;\n        amount: string;\n        tokenID: number;\n    }[]>;\n    private createTransferCall;\n    protected callbackContract(entrypoint: TezosFA2ContractEntrypoint): string;\n    private isTransferRequest;\n    private isTokenMetadata;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosFAProtocol.d.ts",dts:"import { TezosNetwork } from './../TezosProtocol';\nimport { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { RawTezosTransaction } from '../../../serializer/types';\nimport { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { ICoinSubProtocol, SubProtocolType } from '../../ICoinSubProtocol';\nimport { TezosContract } from '../contract/TezosContract';\nimport { TezosContractCall } from '../contract/TezosContractCall';\nimport { TezosProtocol } from '../TezosProtocol';\nimport { MichelineDataNode } from '../types/micheline/MichelineNode';\nimport { TezosTransactionParameters, TezosTransactionOperation } from '../types/operations/Transaction';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nimport { TezosTransactionCursor } from '../types/TezosTransactionCursor';\nimport { TezosTransactionResult } from '../types/TezosTransactionResult';\nimport { FeeDefaults } from '../../ICoinProtocol';\nexport interface TezosFAProtocolConfiguration {\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    identifier: ProtocolSymbols;\n    contractAddress: string;\n    feeDefaults: FeeDefaults;\n    decimals?: number;\n    jsonRPCAPI?: string;\n    baseApiUrl?: string;\n    network?: TezosNetwork;\n    baseApiKey?: string;\n    baseApiNetwork?: string;\n}\nexport declare abstract class TezosFAProtocol extends TezosProtocol implements ICoinSubProtocol {\n    readonly options: TezosFAProtocolOptions;\n    readonly isSubProtocol: boolean;\n    readonly subProtocolType: SubProtocolType;\n    readonly identifier: ProtocolSymbols;\n    readonly contractAddress: string;\n    protected readonly contract: TezosContract;\n    protected readonly defaultSourceAddress: string;\n    constructor(options: TezosFAProtocolOptions);\n    abstract transactionDetailsFromParameters(parameters: TezosTransactionParameters): Partial<IAirGapTransaction>[];\n    bigMapValue(key: string, isKeyHash?: boolean, bigMapID?: number): Promise<string | null>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: TezosTransactionCursor): Promise<TezosTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: TezosTransactionCursor): Promise<TezosTransactionResult>;\n    getTransactions(limit: number, cursor?: TezosTransactionCursor): Promise<TezosTransactionResult>;\n    normalizeTransactionParameters(parameters: string, fallbackEntrypointName?: string): Promise<TezosTransactionParameters>;\n    protected getTransactionOperationDetails(transactionOperation: TezosTransactionOperation): Promise<Partial<IAirGapTransaction>[]>;\n    private parseParameters;\n    private transactionToAirGapTransactions;\n    protected runContractCall(contractCall: TezosContractCall, source: string): Promise<MichelineDataNode>;\n    protected prepareContractCall(contractCalls: TezosContractCall[], fee: string, publicKey: string): Promise<RawTezosTransaction>;\n    protected requireSource(source?: string, defaultSource?: string, ...excludedPrefixes: string[]): string;\n    private prepareMockContractCall;\n    private url;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosFAProtocolOptions.d.ts",dts:"import { ProtocolOptions } from '../../../utils/ProtocolOptions';\nimport { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { TezosProtocolConfig, TezosProtocolNetwork } from '../TezosProtocolOptions';\nexport declare class TezosFAProtocolConfig extends TezosProtocolConfig {\n    readonly symbol: string;\n    readonly name: string;\n    readonly marketSymbol: string;\n    readonly identifier: ProtocolSymbols;\n    readonly contractAddress: string;\n    readonly feeDefaults: FeeDefaults;\n    readonly decimals: number;\n    constructor(symbol: string, name: string, marketSymbol: string, identifier: ProtocolSymbols, contractAddress: string, feeDefaults: FeeDefaults, decimals: number);\n}\nexport declare class TezosFA2ProtocolConfig extends TezosFAProtocolConfig {\n    readonly symbol: string;\n    readonly name: string;\n    readonly marketSymbol: string;\n    readonly identifier: ProtocolSymbols;\n    readonly contractAddress: string;\n    readonly feeDefaults: FeeDefaults;\n    readonly decimals: number;\n    readonly tokenID?: number | undefined;\n    readonly tokenMetadataBigMapID?: number | undefined;\n    readonly tokenMetadataBigMapName?: string | undefined;\n    readonly tokenMetadataBigMapRegex?: RegExp | undefined;\n    constructor(symbol: string, name: string, marketSymbol: string, identifier: ProtocolSymbols, contractAddress: string, feeDefaults: FeeDefaults, decimals: number, tokenID?: number | undefined, tokenMetadataBigMapID?: number | undefined, tokenMetadataBigMapName?: string | undefined, tokenMetadataBigMapRegex?: RegExp | undefined);\n}\nexport declare class TezosBTCProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\nexport declare class TezosETHtzProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\nexport declare class TezosWrappedProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\nexport declare class TezosKolibriUSDProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\nexport declare class TezosStakerProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\nexport declare class TezosUSDProtocolConfig extends TezosFAProtocolConfig {\n    constructor(symbol?: string, name?: string, marketSymbol?: string, identifier?: ProtocolSymbols, contractAddress?: string, feeDefaults?: FeeDefaults, decimals?: number);\n}\nexport declare class TezosFAProtocolOptions implements ProtocolOptions<TezosFAProtocolConfig> {\n    readonly network: TezosProtocolNetwork;\n    readonly config: TezosFAProtocolConfig;\n    constructor(network: TezosProtocolNetwork, config: TezosFAProtocolConfig);\n}\nexport declare class TezosFA2ProtocolOptions implements ProtocolOptions<TezosFA2ProtocolConfig> {\n    readonly network: TezosProtocolNetwork;\n    readonly config: TezosFA2ProtocolConfig;\n    constructor(network: TezosProtocolNetwork, config: TezosFA2ProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosKolibriUSD.d.ts",dts:"import { TezosFA12Protocol } from './TezosFA12Protocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosKolibriUSD extends TezosFA12Protocol {\n    readonly options: TezosFAProtocolOptions;\n    private static extractValueRegex;\n    constructor(options?: TezosFAProtocolOptions);\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosStaker.d.ts",dts:"import { TezosFA1Protocol } from './TezosFA1Protocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosStaker extends TezosFA1Protocol {\n    readonly options: TezosFAProtocolOptions;\n    constructor(options?: TezosFAProtocolOptions);\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosUSD.d.ts",dts:"import { TezosFA12Protocol } from './TezosFA12Protocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosUSD extends TezosFA12Protocol {\n    readonly options: TezosFAProtocolOptions;\n    private static extractAmountRegex;\n    constructor(options?: TezosFAProtocolOptions);\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/fa/TezosWrapped.d.ts",dts:"import { TezosFA12Protocol } from './TezosFA12Protocol';\nimport { TezosFAProtocolOptions } from './TezosFAProtocolOptions';\nexport declare class TezosWrapped extends TezosFA12Protocol {\n    readonly options: TezosFAProtocolOptions;\n    constructor(options?: TezosFAProtocolOptions);\n    fetchTokenHolders(): Promise<{\n        address: string;\n        amount: string;\n    }[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/kt/TezosKtProtocol.d.ts",dts:"import BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { RawTezosTransaction } from '../../../serializer/types';\nimport { ProtocolSymbols } from '../../../utils/ProtocolSymbols';\nimport { FeeDefaults } from '../../ICoinProtocol';\nimport { ICoinSubProtocol, SubProtocolType } from '../../ICoinSubProtocol';\nimport { TezosProtocol } from '../TezosProtocol';\nexport declare class TezosKtProtocol extends TezosProtocol implements ICoinSubProtocol {\n    identifier: ProtocolSymbols;\n    isSubProtocol: boolean;\n    subProtocolType: SubProtocolType;\n    addressValidationPattern: string;\n    migrationFee: BigNumber;\n    getAddressFromPublicKey(publicKey: string, addressIndex?: number): Promise<string>;\n    getAddressesFromPublicKey(publicKey: string): Promise<string[]>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string, addressIndex?: number): Promise<string>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(_publicKey: string, _recipients: string[], _values: string[], _fee: string, _data?: {\n        addressIndex: number;\n    }): Promise<RawTezosTransaction>;\n    originate(publicKey: string, delegate?: string, amount?: BigNumber): Promise<RawTezosTransaction>;\n    delegate(publicKey: string, delegate?: string): Promise<RawTezosTransaction>;\n    migrateKtContract(publicKey: string, destinationContract: string): Promise<{\n        binaryTransaction: string;\n    }>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/rewardcalculation/TezosRewardCalculation005.d.ts",dts:"import BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { TezosBakingRewards, TezosEndorsingRewards, TezosEndorsingRight, TezosProtocol } from '../TezosProtocol';\nimport { TezosRewardsCalculationDefault } from './TezosRewardCalculationDefault';\nexport declare class TezosRewardsCalculation005 extends TezosRewardsCalculationDefault {\n    protocol: TezosProtocol;\n    constructor(protocol: TezosProtocol);\n    protected computeBakingRewards(bakingRights: {\n        level: number;\n        priority: number;\n    }[], isFutureCycle: boolean): Promise<TezosBakingRewards>;\n    protected specificBakingCalculation(e: number, p: number): BigNumber;\n    protected computeEndorsingRewards(endorsingRights: TezosEndorsingRight[], isFutureCycle: boolean): Promise<TezosEndorsingRewards>;\n    protected specificEndorsingCalculation(priority: number, number_of_slots: number): BigNumber;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/rewardcalculation/TezosRewardCalculation006.d.ts",dts:"import BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { TezosProtocol } from '../TezosProtocol';\nimport { TezosRewardsCalculation005 } from './TezosRewardCalculation005';\nexport declare class TezosRewardsCalculation006 extends TezosRewardsCalculation005 {\n    protocol: TezosProtocol;\n    constructor(protocol: TezosProtocol);\n    protected specificBakingCalculation(e: number, p: number): BigNumber;\n    protected specificEndorsingCalculation(priority: number, number_of_slots: number): BigNumber;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/rewardcalculation/TezosRewardCalculationDefault.d.ts",dts:"import BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { TezosBakingRewards, TezosBakingRight, TezosEndorsingRewards, TezosEndorsingRight, TezosNodeConstants, TezosProtocol, TezosRewards, TezosRewardsCalculations } from '../TezosProtocol';\nexport declare class TezosRewardsCalculationDefault implements TezosRewardsCalculations {\n    protocol: TezosProtocol;\n    protected tezosNodeConstants: TezosNodeConstants;\n    constructor(protocol: TezosProtocol);\n    protected getConstants(currentLevel: number, useHead: boolean): Promise<void>;\n    calculateRewards(bakerAddress: string, cycle: number, breakdownRewards?: boolean, currentCycleIn?: number): Promise<TezosRewards>;\n    private calculatePastRewards;\n    private calculateFutureRewards;\n    private fetchEndorsementOperations;\n    private fetchFrozenBalances;\n    protected computeBakingRewards(bakingRights: {\n        level: number;\n        priority: number;\n    }[], isFutureCycle: boolean): Promise<TezosBakingRewards>;\n    protected computeEndorsingRewards(endorsingRights: TezosEndorsingRight[], isFutureCycle: boolean): Promise<TezosEndorsingRewards>;\n    protected specificEndorsingCalculation(priority: number, number_of_slots: number): BigNumber;\n    private computeSnapshotBlockLevel;\n    private fetchBakerInfo;\n    private fetchBlocksForBaker;\n    private blockLevelFieldNameMap;\n    private fetchBlockLevelFieldPromise?;\n    private fetchBlockLevelFieldName;\n    protected fetchBakingRights(bakerAddress: string, cycle: number): Promise<TezosBakingRight[]>;\n    protected fetchEndorsingRights(bakerAddress: string, cycle: number): Promise<TezosEndorsingRight[]>;\n    protected fetchEndorsementOperationCountAndTotalFees(blockLevels: number[]): Promise<Map<number, {\n        sum_number_of_slots: string;\n        block_level: number;\n        sum_fee: number;\n    }>>;\n    protected fetchBlockPriorities(blockLevels: number[]): Promise<{\n        priority: number;\n        level: number;\n    }[]>;\n    private cycleToBlockLevel;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/fa/BigMapPredicate.d.ts",dts:"export interface BigMapPredicate {\n    field: 'account_id' | 'big_map_id' | 'key' | 'key_hash' | 'value' | 'value_type' | 'key_type';\n    operation: 'in' | 'between' | 'like' | 'lt' | 'gt' | 'eq' | 'startsWith' | 'endsWith' | 'before' | 'after' | 'isnull';\n    set: any[];\n    inverse?: boolean;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/fa/BigMapRequest.d.ts",dts:"import { BigMapPredicate } from './BigMapPredicate';\nexport interface BigMapRequest {\n    bigMapID?: number;\n    predicates?: BigMapPredicate[];\n    bigMapFilter?: BigMapPredicate[];\n    limit?: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/fa/BigMapResult.d.ts",dts:"export interface BigMapResponse {\n    big_map_id: number;\n    key: string;\n    key_hash: string;\n    value: string | null;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/fa/TezosFA2BalanceOfRequest.d.ts",dts:"export interface TezosFA2BalanceOfRequest {\n    address: string;\n    tokenID: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/fa/TezosFA2BalanceOfResponse.d.ts",dts:"export interface TezosFA2BalanceOfResponse {\n    address: string;\n    tokenID: number;\n    amount: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/fa/TezosFA2TokenMetadata.d.ts",dts:"export interface TezosFA2TokenMetadata {\n    tokenID: number;\n    symbol: string | string;\n    name: string;\n    decimals: number | string;\n    extras?: any;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/fa/TezosFA2TransferRequest.d.ts",dts:"export interface TezosFA2TransferRequest {\n    from: string;\n    txs: {\n        to: string;\n        tokenID: number;\n        amount: string;\n    }[];\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/fa/TezosFA2UpdateOperatorRequest.d.ts",dts:"export interface TezosFA2UpdateOperatorRequest {\n    operation: 'add' | 'remove';\n    owner: string;\n    operator: string;\n    tokenId: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/micheline/MichelineNode.d.ts",dts:"import { MichelsonGrammarData } from '../michelson/grammar/MichelsonGrammarData';\nimport { MichelsonGrammarType } from '../michelson/grammar/MichelsonGrammarType';\nexport declare type MichelineGenericNode<T extends MichelsonGrammarType | MichelsonGrammarData> = MichelinePrimitive<'int'> | MichelinePrimitive<'string'> | MichelinePrimitive<'bytes'> | MichelinePrimitiveApplication<T> | MichelineGenericNode<T>[];\nexport declare type MichelineNode = MichelineGenericNode<MichelsonGrammarType | MichelsonGrammarData>;\nexport declare type MichelineTypeNode = MichelineGenericNode<MichelsonGrammarType>;\nexport declare type MichelineDataNode = MichelineGenericNode<MichelsonGrammarData>;\nexport declare type MichelinePrimitive<T extends 'int' | 'string' | 'bytes'> = Record<T, string>;\nexport interface MichelinePrimitiveApplication<T extends MichelsonGrammarType | MichelsonGrammarData> {\n    prim: T;\n    args?: MichelineGenericNode<T>[];\n    annots?: string[];\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/generics/MichelsonList.d.ts",dts:"import { Lazy } from '../../../../../data/Lazy';\nimport { MichelineDataNode } from '../../micheline/MichelineNode';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonList extends MichelsonType {\n    readonly elements: Lazy<MichelsonType[]>;\n    constructor(elements: Lazy<MichelsonType[]>, name?: string);\n    static from(value: unknown, mappingFunction?: unknown, name?: string): MichelsonList;\n    asRawValue(): Record<string, Record<string, any>[]> | Record<string, any>[];\n    toMichelineJSON(): MichelineDataNode;\n    eval(): void;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/generics/MichelsonOption.d.ts",dts:"import { Lazy } from '../../../../../data/Lazy';\nimport { MichelineDataNode, MichelinePrimitiveApplication } from '../../micheline/MichelineNode';\nimport { MichelsonGrammarData } from '../grammar/MichelsonGrammarData';\nimport { MichelsonType } from '../MichelsonType';\nexport declare type MichelsonOptionType = 'Some' | 'None';\nexport declare abstract class MichelsonOption extends MichelsonType {\n    protected abstract type: MichelsonOptionType;\n    static from(value: unknown, mappingFunction?: unknown, name?: string): MichelsonOption;\n    static fromMicheline(micheline: MichelinePrimitiveApplication<MichelsonGrammarData>, mappingFunction: unknown, name?: string): MichelsonOption;\n    static fromUnknown(unknownValue: unknown, mappingFunction: unknown, name?: string): MichelsonOption;\n}\nexport declare class MichelsonSome extends MichelsonOption {\n    readonly value: Lazy<MichelsonType>;\n    protected type: MichelsonOptionType;\n    constructor(value: Lazy<MichelsonType>, name?: string);\n    asRawValue(): any;\n    toMichelineJSON(): MichelineDataNode;\n    eval(): void;\n}\nexport declare class MichelsonNone extends MichelsonOption {\n    protected type: MichelsonOptionType;\n    asRawValue(): Record<string, null> | null;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/generics/MichelsonOr.d.ts",dts:"import { Lazy } from '../../../../../data/Lazy';\nimport { MichelineDataNode, MichelinePrimitiveApplication } from '../../micheline/MichelineNode';\nimport { MichelsonGrammarData } from '../grammar/MichelsonGrammarData';\nimport { MichelsonType } from '../MichelsonType';\nexport declare type MichelsonOrType = 'Left' | 'Right';\nexport declare abstract class MichelsonOr extends MichelsonType {\n    readonly value: Lazy<MichelsonType>;\n    protected abstract type: MichelsonOrType;\n    constructor(value: Lazy<MichelsonType>, name?: string);\n    static from(or: unknown, firstMappingFunction?: unknown, secondMappingFunction?: unknown, name?: string): MichelsonOr;\n    static fromMicheline(micheline: MichelinePrimitiveApplication<MichelsonGrammarData>, firstMappingFunction: unknown, secondMappingFunction: unknown, name?: string): MichelsonOr;\n    static fromUnknown(unknownValue: unknown, firstMappingFunction: unknown, secondMappingFunction: unknown, name?: string): MichelsonOr;\n    static isOr(unknownValue: unknown): unknownValue is MichelsonOr;\n    private static create;\n    asRawValue(): Record<string, any> | any;\n    toMichelineJSON(): MichelineDataNode;\n    eval(): void;\n}\nexport declare class MichelsonLeft extends MichelsonOr {\n    protected readonly type = \"Left\";\n}\nexport declare class MichelsonRight extends MichelsonOr {\n    protected readonly type = \"Right\";\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/generics/MichelsonPair.d.ts",dts:"import { Lazy } from '../../../../../data/Lazy';\nimport { MichelineDataNode, MichelinePrimitiveApplication } from '../../micheline/MichelineNode';\nimport { MichelsonGrammarData } from '../grammar/MichelsonGrammarData';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonPair extends MichelsonType {\n    readonly items: Lazy<MichelsonType>[];\n    constructor(items: Lazy<MichelsonType>[], name?: string);\n    static from(pair: unknown, name?: string, ...mappingFunctions: unknown[]): MichelsonPair;\n    static fromMicheline(micheline: MichelinePrimitiveApplication<MichelsonGrammarData>, mappingFunctions: unknown[], name?: string): MichelsonPair;\n    private static normalizePairArgs;\n    static fromUnknown(unknownValue: MichelsonType | unknown, mappingFunctions: unknown[], name?: string): MichelsonPair;\n    private static asRawValue;\n    asRawValue(): Record<string, any> | [any, any];\n    toMichelineJSON(): MichelineDataNode;\n    eval(): void;\n    private normalized;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/grammar/MichelsonGrammarData.d.ts",dts:"import { MichelsonGrammarInstruction } from './MichelsonGrammarInstruction';\nexport declare type MichelsonGrammarData = 'Unit' | 'True' | 'False' | 'Pair' | 'Left' | 'Right' | 'Some' | 'None' | MichelsonGrammarInstruction;\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/grammar/MichelsonGrammarInstruction.d.ts",dts:"export declare type MichelsonGrammarInstruction = 'ADD' | 'IF_NONE' | 'SWAP' | 'CHECK_SIGNATURE' | 'IF_LEFT' | 'LAMBDA' | 'CREATE_CONTRACT' | 'NEG' | 'BLAKE2B' | 'SHA256' | 'SET_DELEGATE' | 'CONTRACT' | 'LSL' | 'SUB' | 'IMPLICIT_ACCOUNT' | 'PACK' | 'PAIR' | 'GT' | 'LEFT' | 'STEPS_TO_QUOTA' | 'TRANSFER_TOKENS' | 'CDR' | 'SLICE' | 'PUSH' | 'SHA512' | 'CHAIN_ID' | 'BALANCE' | 'DUG' | 'SELF' | 'EMPTY_BIG_MAP' | 'LSR' | 'OR' | 'XOR' | 'COMPARE' | 'UNPACK' | 'NEQ' | 'INT' | 'AMOUNT' | 'DIP' | 'ABS' | 'ISNAT' | 'EXEC' | 'NOW' | 'LOOP' | 'MEM' | 'MAP' | 'CONCAT' | 'EMPTY_SET' | 'MUL' | 'LOOP_LEFT' | 'LT' | 'UPDATE' | 'DUP' | 'SOURCE' | 'SENDER' | 'IF_CONS' | 'RIGHT' | 'CAR' | 'CONS' | 'LE' | 'NONE' | 'IF' | 'SOME' | 'GET' | 'CAST' | 'SIZE' | 'DROP' | 'EMPTY_MAP' | 'NIL' | 'DIG' | 'APPLY' | 'RENAME' | 'FAILWITH' | 'HASH_KEY' | 'EQ' | 'NOT' | 'UNIT' | 'ADDRESS' | 'EDIV' | 'CREATE_ACCOUNT' | 'GE' | 'ITER' | 'AND';\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/grammar/MichelsonGrammarType.d.ts",dts:"export declare type MichelsonGrammarType = 'nat' | 'int' | 'string' | 'bytes' | 'mutez' | 'bool' | 'key_hash' | 'timestamp' | 'address' | 'key' | 'unit' | 'signature' | 'option' | 'list' | 'set' | 'operation' | 'contract' | 'pair' | 'or' | 'lambda' | 'map' | 'big_map' | 'chain_id';\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/primitives/MichelsonAddress.d.ts",dts:"import { MichelineDataNode, MichelinePrimitive } from '../../micheline/MichelineNode';\nimport { MichelsonType } from '../MichelsonType';\nimport { MichelsonBytes } from './MichelsonBytes';\nimport { MichelsonString } from './MichelsonString';\nexport declare class MichelsonAddress extends MichelsonType {\n    readonly address: MichelsonString | MichelsonBytes;\n    constructor(address: MichelsonString | MichelsonBytes, name?: string);\n    static from(value: unknown, name?: string): MichelsonAddress;\n    static fromMicheline(micheline: MichelinePrimitive<'string'> | MichelinePrimitive<'bytes'>, name?: string): MichelsonAddress;\n    static fromUnknown(unknownValue: unknown, name?: string): MichelsonAddress;\n    asRawValue(): Record<string, string> | string;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/primitives/MichelsonBool.d.ts",dts:"import { MichelineDataNode, MichelinePrimitiveApplication } from '../../micheline/MichelineNode';\nimport { MichelsonGrammarData } from '../grammar/MichelsonGrammarData';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonBool extends MichelsonType {\n    readonly value: boolean;\n    constructor(value: boolean, name?: string);\n    static from(value: unknown, name?: string): MichelsonBool;\n    static fromMicheline(micheline: MichelinePrimitiveApplication<MichelsonGrammarData>, name?: string): MichelsonBool;\n    static fromUnknown(unknownValue: unknown, name?: string): MichelsonBool;\n    asRawValue(): Record<string, boolean> | boolean;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/primitives/MichelsonBytes.d.ts",dts:"/// <reference types=\"node\" />\nimport { MichelineDataNode, MichelinePrimitive } from '../../micheline/MichelineNode';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonBytes extends MichelsonType {\n    readonly value: Buffer;\n    constructor(value: Buffer, name?: string);\n    static from(value: unknown, name?: string): MichelsonBytes;\n    static fromMicheline(micheline: MichelinePrimitive<'bytes'>, name?: string): MichelsonBytes;\n    static fromUnknown(unknownValue: unknown, name?: string): MichelsonBytes;\n    asRawValue(): Record<string, string> | string;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/primitives/MichelsonInt.d.ts",dts:"import BigNumber from '../../../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { MichelineDataNode, MichelinePrimitive } from '../../micheline/MichelineNode';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonInt extends MichelsonType {\n    readonly value: BigNumber;\n    constructor(value: BigNumber, name?: string);\n    static from(value: unknown, name?: string): MichelsonInt;\n    static fromMicheline(micheline: MichelinePrimitive<'int'>, name?: string): MichelsonInt;\n    static fromUnknown(unknownValue: unknown, name?: string): MichelsonInt;\n    asRawValue(): Record<string, BigNumber> | BigNumber;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/primitives/MichelsonString.d.ts",dts:"import { MichelineDataNode, MichelinePrimitive } from '../../micheline/MichelineNode';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonString extends MichelsonType {\n    readonly value: string;\n    constructor(value: string, name?: string);\n    static from(value: unknown, name?: string): MichelsonString;\n    static fromMicheline(micheline: MichelinePrimitive<'string'>, name?: string): MichelsonString;\n    static fromUnknown(unknownValue: unknown, name?: string): MichelsonString;\n    asRawValue(): Record<string, string> | string;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/primitives/MichelsonUnit.d.ts",dts:"import { MichelineDataNode, MichelinePrimitiveApplication } from '../../micheline/MichelineNode';\nimport { MichelsonGrammarData } from '../grammar/MichelsonGrammarData';\nimport { MichelsonType } from '../MichelsonType';\nexport declare class MichelsonUnit extends MichelsonType {\n    static from(value: unknown, name?: string): MichelsonUnit;\n    static fromMicheline(micheline: MichelinePrimitiveApplication<MichelsonGrammarData>, name?: string): MichelsonUnit;\n    asRawValue(): any;\n    toMichelineJSON(): MichelineDataNode;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/MichelsonType.d.ts",dts:"import { MichelineDataNode } from '../micheline/MichelineNode';\nexport declare abstract class MichelsonType {\n    name?: string | undefined;\n    constructor(name?: string | undefined);\n    abstract asRawValue(): any;\n    abstract toMichelineJSON(): MichelineDataNode;\n    eval(): void;\n    setName(name: string): void;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/MichelsonTypeMeta.d.ts",dts:"import { Lazy } from '../../../../data/Lazy';\nimport { MichelinePrimitiveApplication, MichelineTypeNode } from '../../types/micheline/MichelineNode';\nimport { MichelsonGrammarType } from '../../types/michelson/grammar/MichelsonGrammarType';\nimport { MichelsonType } from './MichelsonType';\nexport declare enum MichelsonAnnotationPrefix {\n    TYPE = \":\",\n    VARIABLE = \"@\",\n    FIELD = \"%\"\n}\nexport interface MichelsonTypeMetaCreateValueConfiguration {\n    lazyEval?: boolean;\n    beforeNext?: (meta: MichelsonTypeMeta, raw: unknown) => void;\n    onNext?: (meta: MichelsonTypeMeta, raw: unknown, value: MichelsonType) => void;\n}\nexport declare class MichelsonTypeMeta {\n    readonly type: MichelsonGrammarType;\n    readonly parent?: MichelsonGenericTypeMeta | undefined;\n    readonly annots: string[];\n    constructor(type: MichelsonGrammarType, parent?: MichelsonGenericTypeMeta | undefined, annots?: string[]);\n    static fromMichelineNode(node: MichelineTypeNode): MichelsonTypeMeta | undefined;\n    static fromMichelinePrimitiveApplication(primitiveApplication: MichelinePrimitiveApplication<any>, parent?: MichelsonGenericTypeMeta): MichelsonTypeMeta;\n    static from(type: MichelsonGrammarType, annots: string[], args: MichelinePrimitiveApplication<any>[], parent?: MichelsonGenericTypeMeta): MichelsonTypeMeta;\n    createValue(value: unknown, configuration?: MichelsonTypeMetaCreateValueConfiguration): MichelsonType;\n    getAnnotation(...prefixes: MichelsonAnnotationPrefix[]): string | undefined;\n    protected getRawValue(value: unknown): unknown;\n}\nexport declare class MichelsonGenericTypeMeta extends MichelsonTypeMeta {\n    readonly generics: Lazy<MichelsonTypeMeta>[];\n    constructor(type: MichelsonGrammarType, genericTypes: MichelinePrimitiveApplication<any>[], parent?: MichelsonGenericTypeMeta, annots?: string[]);\n    createValue(value: unknown, configuration: MichelsonTypeMetaCreateValueConfiguration): MichelsonType;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/michelson/factories.d.ts",dts:"import { MichelsonGrammarType } from './grammar/MichelsonGrammarType';\nimport { MichelsonType } from './MichelsonType';\nexport declare const michelsonTypeFactories: Record<MichelsonGrammarType, (...args: unknown[]) => MichelsonType>;\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/ActivateAccount.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosActivateAccountOperation extends TezosOperation {\n    kind: TezosOperationType.ACTIVATE_ACCOUNT;\n    pkh: string;\n    secret: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Ballot.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosBallotOperation extends TezosOperation {\n    kind: TezosOperationType.BALLOT;\n    source: string;\n    period: string;\n    proposal: string;\n    ballot: 'nay' | 'yay' | 'pass';\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Delegation.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosDelegationOperation extends TezosOperation {\n    kind: TezosOperationType.DELEGATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    delegate?: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/DoubleBakingEvidence.d.ts",dts:"import { TezosBlockHeader } from '../TezosBlockHeader';\nimport { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosDoubleBakingEvidenceOperation extends TezosOperation {\n    kind: TezosOperationType.DOUBLE_BAKING_EVIDENCE;\n    bh1: TezosBlockHeader;\n    bh2: TezosBlockHeader;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/DoubleEndorsementEvidence.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface InlinedEndorsement {\n    branch: string;\n    operations: InlinedEndorsementContents;\n    signature?: string;\n}\nexport interface InlinedEndorsementContents {\n    kind: 'endorsement';\n    level: string;\n}\nexport interface TezosDoubleEndorsementEvidenceOperation extends TezosOperation {\n    kind: TezosOperationType.DOUBLE_ENDORSEMENT_EVIDENCE;\n    op1: InlinedEndorsement;\n    op2: InlinedEndorsement;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Endorsement.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosEndorsementOperation extends TezosOperation {\n    kind: TezosOperationType.ENDORSEMENT;\n    level: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Origination.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosOriginationOperation extends TezosOperation {\n    kind: TezosOperationType.DELEGATION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    balance: string;\n    delegate?: string;\n    script: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Proposal.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosProposalOperation extends TezosOperation {\n    kind: TezosOperationType.PROPOSALS;\n    period: string;\n    proposals: string[];\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Reveal.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosRevealOperation extends TezosOperation {\n    kind: TezosOperationType.REVEAL;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    public_key: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/SeedNonceRevelation.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosSeedNonceRevelationOperation extends TezosOperation {\n    kind: TezosOperationType.SEED_NONCE_REVELATION;\n    level: string;\n    nonce: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/TezosOperation.d.ts",dts:"import { TezosOperationType } from '../TezosOperationType';\nexport interface TezosOperation {\n    kind: TezosOperationType;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/operations/Transaction.d.ts",dts:"import { MichelineNode } from '../micheline/MichelineNode';\nimport { TezosOperationType } from '../TezosOperationType';\nimport { TezosWrappedOperation } from '../TezosWrappedOperation';\nimport { TezosOperation } from './TezosOperation';\nexport interface TezosTransactionParameters {\n    entrypoint: 'default' | 'root' | 'do' | 'set_delegate' | 'remove_delegate' | string;\n    value: MichelineNode;\n}\nexport interface TezosWrappedTransactionOperation extends TezosWrappedOperation {\n    contents: TezosTransactionOperation[];\n    signature: string;\n}\nexport interface TezosTransactionOperation extends TezosOperation {\n    kind: TezosOperationType.TRANSACTION;\n    source: string;\n    fee: string;\n    counter: string;\n    gas_limit: string;\n    storage_limit: string;\n    amount: string;\n    destination: string;\n    parameters?: TezosTransactionParameters;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosBlockHeader.d.ts",dts:"export interface TezosBlockHeader {\n    level: number;\n    proto: number;\n    predecessor: string;\n    timestamp: string;\n    validation_pass: number;\n    operations_hash: string;\n    fitness: string[];\n    context: string;\n    priority: number;\n    proof_of_work_nonce: string;\n    signature: string;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosBlockMetadata.d.ts",dts:"import { TezosBlockHeader } from './TezosBlockHeader';\nexport interface TezosBlockMetadata {\n    protocol: string;\n    chain_id: string;\n    hash: string;\n    metadata: TezosBlockHeader;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosContractCode.d.ts",dts:"import { MichelinePrimitiveApplication, MichelineTypeNode } from './micheline/MichelineNode';\nexport interface TezosContractCode extends MichelinePrimitiveApplication<any> {\n    prim: 'parameter' | 'storage';\n    args: MichelineTypeNode[];\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosOperationType.d.ts",dts:'export declare enum TezosOperationType {\n    ENDORSEMENT = "endorsement",\n    SEED_NONCE_REVELATION = "seed_nonce_revelation",\n    DOUBLE_ENDORSEMENT_EVIDENCE = "double_endorsement_evidence",\n    DOUBLE_BAKING_EVIDENCE = "double_baking_evidence",\n    ACTIVATE_ACCOUNT = "activate_account",\n    PROPOSALS = "proposals",\n    BALLOT = "ballot",\n    REVEAL = "reveal",\n    TRANSACTION = "transaction",\n    ORIGINATION = "origination",\n    DELEGATION = "delegation"\n}\n'},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosTransactionCursor.d.ts",dts:"export interface TezosTransactionCursor {\n    lastBlockLevel: number;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosTransactionResult.d.ts",dts:"import { IAirGapTransaction } from '../../../interfaces/IAirGapTransaction';\nimport { TezosTransactionCursor } from './TezosTransactionCursor';\nexport interface TezosTransactionResult {\n    transactions: IAirGapTransaction[];\n    cursor: TezosTransactionCursor;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/TezosWrappedOperation.d.ts",dts:"import { TezosOperation } from './operations/TezosOperation';\nexport interface TezosWrappedOperation {\n    branch: string;\n    contents: TezosOperation[];\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/types/utils.d.ts",dts:"import { MichelineNode, MichelinePrimitive, MichelinePrimitiveApplication } from './micheline/MichelineNode';\nexport declare function isMichelineNode(node: unknown): node is MichelineNode;\nexport declare function isMichelinePrimitive<T extends 'int' | 'string' | 'bytes'>(type: T, node: unknown): node is MichelinePrimitive<T>;\nexport declare function isMichelinePrimitiveApplication(node: unknown): node is MichelinePrimitiveApplication<any>;\nexport declare function isMichelineSequence(node: unknown, recursive?: boolean): node is MichelineNode[];\n"},{name:"@airgap/coinlib-core/protocols/tezos/TezosCryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { Ed25519CryptoClient } from '../Ed25519CryptoClient';\nexport declare class TezosCryptoClient extends Ed25519CryptoClient {\n    readonly edsigPrefix: Uint8Array;\n    constructor(edsigPrefix?: Uint8Array);\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    toBuffer(message: string): Promise<Buffer>;\n    hash(message: Buffer, size?: number): Promise<Buffer>;\n    blake2bLedgerHash(message: string): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/TezosProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { IAirGapSignedTransaction } from '../../interfaces/IAirGapSignedTransaction';\nimport { AirGapTransactionStatus, IAirGapTransaction } from '../../interfaces/IAirGapTransaction';\nimport { SignedTezosTransaction } from '../../serializer/schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTezosTransaction } from '../../serializer/schemas/definitions/unsigned-transaction-tezos';\nimport { RawTezosTransaction } from '../../serializer/types';\nimport { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { DelegateeDetails, DelegationDetails, DelegatorDetails, ICoinDelegateProtocol } from '../ICoinDelegateProtocol';\nimport { CurrencyUnit, FeeDefaults } from '../ICoinProtocol';\nimport { ICoinSubProtocol } from '../ICoinSubProtocol';\nimport { NonExtendedProtocol } from '../NonExtendedProtocol';\nimport { TezosCryptoClient } from './TezosCryptoClient';\nimport { TezosProtocolOptions } from './TezosProtocolOptions';\nimport { TezosRevealOperation } from './types/operations/Reveal';\nimport { TezosOperation } from './types/operations/TezosOperation';\nimport { TezosTransactionOperation } from './types/operations/Transaction';\nimport { TezosTransactionCursor } from './types/TezosTransactionCursor';\nimport { TezosTransactionResult } from './types/TezosTransactionResult';\nimport { TezosWrappedOperation } from './types/TezosWrappedOperation';\nexport interface TezosVotingInfo {\n    pkh: string;\n    rolls: number;\n}\nexport interface BakerInfo {\n    balance: BigNumber;\n    delegatedBalance: BigNumber;\n    stakingBalance: BigNumber;\n    selfBond: BigNumber;\n    bakerCapacity: BigNumber;\n    bakerUsage: BigNumber;\n}\nexport interface DelegationRewardInfo {\n    cycle: number;\n    reward: BigNumber;\n    deposit: BigNumber;\n    delegatedBalance: BigNumber;\n    stakingBalance: BigNumber;\n    totalRewards: BigNumber;\n    totalFees: BigNumber;\n    payout: Date;\n}\nexport interface DelegationInfo {\n    isDelegated: boolean;\n    value?: string;\n    delegatedOpLevel?: number;\n    delegatedDate?: Date;\n}\nexport declare enum TezosDelegatorAction {\n    DELEGATE = \"delegate\",\n    UNDELEGATE = \"undelegate\",\n    CHANGE_BAKER = \"change_baker\"\n}\nexport interface TezosPayoutInfo {\n    delegator: string;\n    share: string;\n    payout: string;\n    balance: string;\n}\nexport interface RunOperationBalanceUpdate {\n    kind: string;\n    contract: string;\n    change: string;\n    category: string;\n    delegate: string;\n    cycle?: number;\n}\nexport interface RunOperationOperationBalanceUpdate {\n    kind: string;\n    contract: string;\n    change: string;\n}\nexport interface RunOperationOperationResult {\n    status: string;\n    errors?: unknown;\n    balance_updates: RunOperationOperationBalanceUpdate[];\n    consumed_gas: string;\n    paid_storage_size_diff?: string;\n    originated_contracts?: string[];\n    allocated_destination_contract?: boolean;\n}\ninterface RunOperationInternalOperationResult {\n    result?: {\n        errors?: unknown;\n        consumed_gas: string;\n        paid_storage_size_diff?: string;\n        originated_contracts?: string[];\n        allocated_destination_contract?: boolean;\n    };\n    parameters?: {\n        entrypoint: string;\n        value: unknown;\n    };\n}\nexport interface RunOperationMetadata {\n    balance_updates: RunOperationBalanceUpdate[];\n    operation_result: RunOperationOperationResult;\n    internal_operation_results?: RunOperationInternalOperationResult[];\n}\nexport declare enum TezosNetwork {\n    MAINNET = \"mainnet\",\n    DELPHINET = \"delphinet\",\n    EDONET = \"edonet\"\n}\nexport declare class TezosProtocol extends NonExtendedProtocol implements ICoinDelegateProtocol {\n    readonly options: TezosProtocolOptions;\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    get subProtocols(): ICoinSubProtocol[];\n    feeDefaults: FeeDefaults;\n    units: CurrencyUnit[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    minCycleDuration: number;\n    protected readonly transactionFee: BigNumber;\n    protected readonly originationSize: BigNumber;\n    protected readonly storageCostPerByte: BigNumber;\n    protected readonly revealFee: BigNumber;\n    protected readonly activationBurn: BigNumber;\n    protected readonly originationBurn: BigNumber;\n    protected readonly tezosPrefixes: {\n        tz1: Buffer;\n        tz2: Buffer;\n        tz3: Buffer;\n        kt: Buffer;\n        edpk: Buffer;\n        edsk: Buffer;\n        edsig: Buffer;\n        branch: Buffer;\n    };\n    readonly cryptoClient: TezosCryptoClient;\n    get jsonRPCAPI(): string;\n    get baseApiUrl(): string;\n    get baseApiNetwork(): string;\n    readonly headers: {\n        'Content-Type': string;\n        apiKey: string;\n    };\n    constructor(options?: TezosProtocolOptions);\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    /**\n     * Returns the PublicKey as String, derived from a supplied hex-string\n     * @param secret HEX-Secret from BIP39\n     * @param derivationPath DerivationPath for Key\n     */\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    /**\n     * Returns the PrivateKey as Buffer, derived from a supplied hex-string\n     * @param secret HEX-Secret from BIP39\n     * @param derivationPath DerivationPath for Key\n     */\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getAddressFromPublicKey(publicKey: string): Promise<string>;\n    getAddressesFromPublicKey(publicKey: string): Promise<string[]>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: TezosTransactionCursor): Promise<TezosTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: TezosTransactionCursor): Promise<TezosTransactionResult>;\n    signWithPrivateKey(privateKey: Buffer, transaction: RawTezosTransaction): Promise<IAirGapSignedTransaction>;\n    getTransactionDetails(unsignedTx: UnsignedTezosTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(signedTx: SignedTezosTransaction): Promise<IAirGapTransaction[]>;\n    getAirGapTxFromWrappedOperations(wrappedOperations: TezosWrappedOperation): Promise<IAirGapTransaction[]>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKey(publicKey: string): Promise<string>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    getAvailableBalanceOfAddresses(addresses: string[]): Promise<string>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string): Promise<string>;\n    private estimateMaxTansactionValueWithBalance;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], _data?: any): Promise<FeeDefaults>;\n    protected estimateFeeDefaultsForOperations(publicKey: string, operations: TezosOperation[]): Promise<FeeDefaults>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: {\n        addressIndex: number;\n    }): Promise<RawTezosTransaction>;\n    prepareTransactionsFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: {\n        addressIndex: number;\n    }, operationsPerGroup?: number): Promise<RawTezosTransaction[]>;\n    protected getTransactionOperationDetails(transactionOperation: TezosTransactionOperation): Promise<Partial<IAirGapTransaction>[]>;\n    private createTransactionOperations;\n    forgeAndWrapOperations(tezosWrappedOperation: TezosWrappedOperation): Promise<RawTezosTransaction>;\n    getDefaultDelegatee(): Promise<string>;\n    getCurrentDelegateesForPublicKey(publicKey: string): Promise<string[]>;\n    getCurrentDelegateesForAddress(address: string): Promise<string[]>;\n    getDelegateeDetails(address: string): Promise<DelegateeDetails>;\n    isPublicKeyDelegating(publicKey: string): Promise<boolean>;\n    isAddressDelegating(address: string): Promise<boolean>;\n    getDelegatorDetailsFromPublicKey(publicKey: string): Promise<DelegatorDetails>;\n    getDelegatorDetailsFromAddress(address: string): Promise<DelegatorDetails>;\n    getDelegationDetailsFromPublicKey(publicKey: string, delegatees: string[]): Promise<DelegationDetails>;\n    getDelegationDetailsFromAddress(address: string, delegatees: string[]): Promise<DelegationDetails>;\n    private getDelegatorDetails;\n    prepareDelegatorActionFromPublicKey(publicKey: string, type: TezosDelegatorAction, data?: any): Promise<RawTezosTransaction[]>;\n    prepareOperations(publicKey: string, operationRequests: TezosOperation[], overrideFees?: boolean): Promise<TezosWrappedOperation>;\n    estimateAndReplaceLimitsAndFee(tezosWrappedOperation: TezosWrappedOperation, overrideFees?: boolean): Promise<TezosWrappedOperation>;\n    getDelegationInfo(delegatedAddress: string, fetchExtraInfo?: boolean): Promise<DelegationInfo>;\n    bakerInfo(tzAddress: string | undefined): Promise<BakerInfo>;\n    getDelegationRewardsForAddress(address: string): Promise<DelegationRewardInfo[]>;\n    getDelegationRewards(bakerAddress: string, delegatorAddress?: string): Promise<DelegationRewardInfo[]>;\n    undelegate(publicKey: string): Promise<RawTezosTransaction>;\n    delegate(publicKey: string, delegate?: string | string[]): Promise<RawTezosTransaction>;\n    private getAmountUsedByPreviousOperations;\n    broadcastTransaction(rawTransaction: IAirGapSignedTransaction): Promise<string>;\n    protected checkAndRemovePrefixToHex(base58CheckEncodedPayload: string, tezosPrefix: Uint8Array): string;\n    unforgeSignedTezosWrappedOperation(hexString: string): Promise<TezosWrappedOperation>;\n    unforgeUnsignedTezosWrappedOperation(hexString: string): Promise<TezosWrappedOperation>;\n    forgeTezosOperation(tezosWrappedOperation: TezosWrappedOperation): Promise<string>;\n    createRevealOperation(counter: BigNumber, publicKey: string, address: string, fee?: string): Promise<TezosRevealOperation>;\n    getTezosVotingInfo(blockHash: string): Promise<TezosVotingInfo[]>;\n    fetchCurrentCycle(): Promise<number>;\n    private static readonly FIRST_005_CYCLE;\n    private static readonly FIRST_006_CYCLE;\n    private rewardCalculations;\n    calculateRewards(bakerAddress: string, cycle: number, currentCycle?: number, breakDownRewards?: boolean): Promise<TezosRewards>;\n    calculatePayouts(rewards: TezosRewards, offsetOrAddresses: number | string[], limit?: number): Promise<TezosPayoutInfo[]>;\n    calculatePayout(address: string, rewards: TezosRewards): Promise<TezosPayoutInfo>;\n    private calculatePayoutForAddresses;\n    private fetchBlockMetadata;\n    static readonly BLOCKS_PER_CYCLE: {\n        mainnet: number;\n        delphinet: number;\n        edonet: number;\n    };\n    private fetchBalances;\n    signMessage(message: string, keypair: {\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(message: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(message: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(message: string, privateKey: Buffer): Promise<string>;\n    decryptAES(message: string, privateKey: Buffer): Promise<string>;\n    getTransactionStatuses(transactionHashes: string[]): Promise<AirGapTransactionStatus[]>;\n}\nexport interface TezosBakingRight {\n    level: number;\n    delegate: string;\n    priority: number;\n}\nexport interface TezosBakingRewards {\n    totalBakingRewards: string;\n    rewardsDetails: {\n        level: number;\n        amount: string;\n        deposit: string;\n        fees?: string;\n    }[];\n}\nexport interface TezosEndorsingRewards {\n    totalEndorsingRewards: string;\n    rewardsDetails: {\n        level: number;\n        amount: string;\n        deposit: string;\n    }[];\n}\nexport interface TezosEndorsingRight {\n    level: number;\n    block_level?: number;\n    delegate: string;\n    number_of_slots: number;\n}\nexport interface TezosRewardsCalculations {\n    protocol: TezosProtocol;\n    calculateRewards(bakerAddress: string, cycle: number, breakDownRewards: boolean, currentCycleIn?: number): Promise<TezosRewards>;\n}\nexport interface TezosRewards {\n    baker: string;\n    stakingBalance: string;\n    bakingRewards: string;\n    bakingDeposits: string;\n    endorsingDeposits: string;\n    endorsingRewards: string;\n    fees: string;\n    deposit: string;\n    totalRewards: string;\n    cycle: number;\n    snapshotBlockLevel: number;\n    delegatedContracts: string[];\n    bakingRewardsDetails: {\n        level: number;\n        amount: string;\n        deposit: string;\n        fees?: string;\n    }[];\n    endorsingRewardsDetails: {\n        level: number;\n        amount: string;\n        deposit: string;\n    }[];\n    endorsingRightsCount: number;\n}\nexport interface TezosBakerInfo {\n    balance: string;\n    frozen_balance: string;\n    frozen_balance_by_cycle: TezosFrozenBalance[];\n    staking_balance: string;\n    delegated_contracts: string[];\n    delegated_balance: string;\n    deactivated: boolean;\n    grace_period: number;\n}\nexport interface TezosFrozenBalance {\n    cycle: number;\n    deposit: string;\n    fees: string;\n    rewards: string;\n}\nexport interface TezosNodeConstants {\n    proof_of_work_nonce_size: number;\n    nonce_length: number;\n    max_revelations_per_block: number;\n    max_operation_data_length: number;\n    max_proposals_per_delegate: number;\n    preserved_cycles: number;\n    blocks_per_cycle: number;\n    blocks_per_commitment: number;\n    blocks_per_roll_snapshot: number;\n    blocks_per_voting_period: number;\n    time_between_blocks: number[];\n    endorsers_per_block: number;\n    hard_gas_limit_per_operation: string;\n    hard_gas_limit_per_block: string;\n    proof_of_work_threshold: number;\n    tokens_per_roll: string;\n    michelson_maximum_type_size: number;\n    seed_nonce_revelation_tip: string;\n    origination_size: number;\n    block_security_deposit: string;\n    endorsement_security_deposit: string;\n    cost_per_byte: string;\n    hard_storage_limit_per_operation: string;\n    test_chain_duration: string;\n    quorum_min: number;\n    quorum_max: number;\n    min_proposal_quorum: number;\n    initial_endorsers: number;\n    delay_per_missing_endorsement: string;\n}\nexport interface TezosNodeConstantsV1 extends TezosNodeConstants {\n    block_reward: string;\n    endorsement_reward: string;\n}\nexport interface TezosNodeConstantsV2 extends TezosNodeConstants {\n    baking_reward_per_endorsement: string[];\n    endorsement_reward: string[];\n}\nexport {};\n"},{name:"@airgap/coinlib-core/protocols/tezos/TezosProtocolOptions.d.ts",dts:"import { ProtocolBlockExplorer } from '../../utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from '../../utils/ProtocolNetwork';\nimport { ProtocolOptions } from '../../utils/ProtocolOptions';\nimport { TezosNetwork } from './TezosProtocol';\nexport declare class TezosProtocolNetworkExtras {\n    readonly network: TezosNetwork;\n    readonly conseilUrl: string;\n    readonly conseilNetwork: TezosNetwork;\n    readonly conseilApiKey: string;\n    constructor(network?: TezosNetwork, conseilUrl?: string, conseilNetwork?: TezosNetwork, conseilApiKey?: string);\n}\nexport declare class TezblockBlockExplorer implements ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer?: string);\n    getAddressLink(address: string): Promise<string>;\n    getTransactionLink(transactionId: string): Promise<string>;\n}\nexport declare class TezosProtocolNetwork extends ProtocolNetwork<TezosProtocolNetworkExtras> {\n    constructor(name?: string, type?: NetworkType, rpcUrl?: string, blockExplorer?: ProtocolBlockExplorer, extras?: TezosProtocolNetworkExtras);\n}\nexport declare class TezosProtocolConfig {\n    constructor();\n}\nexport declare class TezosProtocolOptions implements ProtocolOptions<TezosProtocolConfig> {\n    readonly network: TezosProtocolNetwork;\n    readonly config: TezosProtocolConfig;\n    constructor(network?: TezosProtocolNetwork, config?: TezosProtocolConfig);\n}\n"},{name:"@airgap/coinlib-core/protocols/tezos/TezosUtils.d.ts",dts:"/// <reference types=\"node\" />\nimport { MichelsonType } from './types/michelson/MichelsonType';\nexport declare class TezosUtils {\n    private static readonly tezosPrefixes;\n    static parseAddress(bytes: string | Buffer): string;\n    static parseHex(rawHex: string | string[]): MichelsonType;\n    private static decodeSignedInt;\n    private static hexStringToArray;\n    private static parsePair;\n    private static parseList;\n    private static hexToString;\n    private static hexToLength;\n    private static splitAndReturnRest;\n    private static parseTzAddress;\n    private static prefixAndBase58CheckEncode;\n}\n"},{name:"@airgap/coinlib-core/protocols/BlockExplorerProtocol.d.ts",dts:"import { ProtocolOptions } from '../utils/ProtocolOptions';\nexport declare abstract class BlockExplorerProtocol {\n    abstract options: ProtocolOptions;\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/CryptoClient.d.ts",dts:'/// <reference types="node" />\nexport declare abstract class CryptoClient {\n    abstract signMessage(message: string, keypair: {\n        publicKey?: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    abstract verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAES(payload: string, privateKey: Buffer): Promise<string>;\n    decryptAES(encryptedPayload: string, privateKey: Buffer): Promise<string>;\n    encryptAsymmetric(payload: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(encryptedPayload: string, keypair: {\n        publicKey?: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    recoverPublicKeyFromSignature(): Promise<void>;\n}\n'},{name:"@airgap/coinlib-core/protocols/Ed25519CryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { CryptoClient } from './CryptoClient';\nexport declare abstract class Ed25519CryptoClient extends CryptoClient {\n    encryptAsymmetric(payload: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(encryptedPayload: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ICoinDelegateProtocol.d.ts",dts:"import { ICoinProtocol } from './ICoinProtocol';\nexport interface DelegateeDetails {\n    name?: string;\n    status?: any;\n    address: string;\n}\nexport interface DelegatorAction {\n    type: any;\n    args?: string[];\n}\nexport interface DelegatorDetails {\n    address: string;\n    balance: string;\n    delegatees: string[];\n    availableActions?: DelegatorAction[];\n    rewards?: DelegatorReward[];\n}\nexport interface DelegatorReward {\n    index: number;\n    amount: string;\n    collected?: boolean;\n    timestamp: number;\n}\nexport interface DelegationDetails {\n    delegator: DelegatorDetails;\n    delegatees: DelegateeDetails[];\n}\nexport interface ICoinDelegateProtocol extends ICoinProtocol {\n    getDefaultDelegatee(): Promise<string>;\n    getCurrentDelegateesForPublicKey(publicKey: string): Promise<string[]>;\n    getCurrentDelegateesForAddress(address: string): Promise<string[]>;\n    getDelegateeDetails(address: string): Promise<DelegateeDetails>;\n    isPublicKeyDelegating(publicKey: string): Promise<boolean>;\n    isAddressDelegating(address: string): Promise<boolean>;\n    getDelegatorDetailsFromPublicKey(publicKey: string): Promise<DelegatorDetails>;\n    getDelegatorDetailsFromAddress(address: string): Promise<DelegatorDetails>;\n    getDelegationDetailsFromPublicKey(publicKey: string, delegatees: string[]): Promise<DelegationDetails>;\n    getDelegationDetailsFromAddress(address: string, delegatees: string[]): Promise<DelegationDetails>;\n    prepareDelegatorActionFromPublicKey(publicKey: string, type: any, data?: any): Promise<any[]>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ICoinProtocol.d.ts",dts:"/// <reference types=\"node\" />\nimport { CryptoClient } from '..';\nimport { IAirGapSignedTransaction } from '../interfaces/IAirGapSignedTransaction';\nimport { AirGapTransactionStatus, IAirGapTransaction, IAirGapTransactionResult } from '../interfaces/IAirGapTransaction';\nimport { SignedTransaction } from '../serializer/schemas/definitions/signed-transaction';\nimport { UnsignedTransaction } from '../serializer/schemas/definitions/unsigned-transaction';\nimport { ProtocolOptions } from '../utils/ProtocolOptions';\nimport { ProtocolSymbols } from '../utils/ProtocolSymbols';\nimport { IProtocolTransactionCursor } from './../interfaces/IAirGapTransaction';\nimport { ICoinSubProtocol } from './ICoinSubProtocol';\nexport interface FeeDefaults {\n    low: string;\n    medium: string;\n    high: string;\n}\nexport interface CurrencyUnit {\n    unitSymbol: string;\n    factor: string;\n}\nexport interface ICoinProtocol {\n    symbol: string;\n    name: string;\n    marketSymbol: string;\n    feeSymbol: string;\n    feeDefaults: FeeDefaults;\n    decimals: number;\n    feeDecimals: number;\n    identifier: ProtocolSymbols;\n    units: {\n        unitSymbol: string;\n        factor: string;\n    }[];\n    supportsHD: boolean;\n    standardDerivationPath: string;\n    addressIsCaseSensitive: boolean;\n    addressValidationPattern: string;\n    addressPlaceholder: string;\n    subProtocols?: ICoinSubProtocol[];\n    options: ProtocolOptions;\n    cryptoClient: CryptoClient;\n    getBlockExplorerLinkForAddress(address: string): Promise<string>;\n    getBlockExplorerLinkForTxId(txId: string): Promise<string>;\n    getPublicKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<Buffer>;\n    getExtendedPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getPublicKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<Buffer>;\n    getExtendedPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getAddressFromPublicKey(publicKey: string): Promise<string>;\n    getAddressesFromPublicKey(publicKey: string): Promise<string[]>;\n    getAddressFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressDerivationIndex: number): Promise<string>;\n    getAddressesFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressCount: number, offset: number): Promise<string[]>;\n    getTransactionsFromPublicKey(publicKey: string, limit: number, cursor?: IProtocolTransactionCursor): Promise<IAirGapTransactionResult>;\n    getTransactionsFromExtendedPublicKey(extendedPublicKey: string, limit: number, cursor?: IProtocolTransactionCursor): Promise<IAirGapTransactionResult>;\n    getTransactionsFromAddresses(addresses: string[], limit: number, cursor?: IProtocolTransactionCursor): Promise<IAirGapTransactionResult>;\n    signWithExtendedPrivateKey(extendedPrivateKey: string, transaction: any): Promise<IAirGapSignedTransaction>;\n    signWithPrivateKey(privateKey: Buffer, transaction: any): Promise<IAirGapSignedTransaction>;\n    getTransactionDetails(transaction: UnsignedTransaction): Promise<IAirGapTransaction[]>;\n    getTransactionDetailsFromSigned(transaction: SignedTransaction): Promise<IAirGapTransaction[]>;\n    getBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getBalanceOfPublicKey(publicKey: string, addressIndex?: number): Promise<string>;\n    getBalanceOfExtendedPublicKey(extendedPublicKey: string, offset: number): Promise<string>;\n    getAvailableBalanceOfAddresses(addresses: string[]): Promise<string>;\n    getTransactionStatuses(transactionHash: string[]): Promise<AirGapTransactionStatus[]>;\n    getBalanceOfPublicKeyForSubProtocols(publicKey: string, subProtocols: ICoinSubProtocol[]): Promise<string[]>;\n    estimateMaxTransactionValueFromExtendedPublicKey(extendedPublicKey: string, recipients: string[], fee?: string): Promise<string>;\n    estimateMaxTransactionValueFromPublicKey(publicKey: string, recipients: string[], fee?: string, addressIndex?: number): Promise<string>;\n    estimateFeeDefaultsFromExtendedPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    estimateFeeDefaultsFromPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    prepareTransactionFromExtendedPublicKey(extendedPublicKey: string, offset: number, recipients: string[], values: string[], fee: string, data?: any): Promise<any>;\n    prepareTransactionFromPublicKey(publicKey: string, recipients: string[], values: string[], fee: string, data?: any): Promise<any>;\n    broadcastTransaction(rawTransaction: any): Promise<string>;\n    signMessage(message: string, keypair: {\n        publicKey?: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    verifyMessage(message: string, signature: string, publicKey: string): Promise<boolean>;\n    encryptAsymmetric(payload: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(encryptedPayload: string, keypair: {\n        publicKey?: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n    encryptAES(payload: string, privateKey: Buffer): Promise<string>;\n    decryptAES(encryptedPayload: string, privateKey: Buffer): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/ICoinSubProtocol.d.ts",dts:'import { ICoinProtocol } from \'./ICoinProtocol\';\nexport declare enum SubProtocolType {\n    ACCOUNT = "account",\n    TOKEN = "token"\n}\nexport interface ICoinSubProtocol extends ICoinProtocol {\n    isSubProtocol: boolean;\n    subProtocolType: SubProtocolType;\n    contractAddress?: string;\n}\n'},{name:"@airgap/coinlib-core/protocols/NonExtendedProtocol.d.ts",dts:"import { FeeDefaults } from './ICoinProtocol';\nimport { TezosTransactionResult } from './tezos/types/TezosTransactionResult';\nimport { IProtocolTransactionCursor } from '../interfaces/IAirGapTransaction';\nexport declare abstract class NonExtendedProtocol {\n    getExtendedPrivateKeyFromMnemonic(mnemonic: string, derivationPath: string, password?: string): Promise<string>;\n    getExtendedPrivateKeyFromHexSecret(secret: string, derivationPath: string): Promise<string>;\n    getBalanceOfExtendedPublicKey(extendedPublicKey: string, offset: number): Promise<string>;\n    signWithExtendedPrivateKey(extendedPrivateKey: string, transaction: any): Promise<string>;\n    getAddressFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressDerivationIndex: number): Promise<string>;\n    getAddressesFromExtendedPublicKey(extendedPublicKey: string, visibilityDerivationIndex: number, addressCount: number, offset: number): Promise<string[]>;\n    estimateMaxTransactionValueFromExtendedPublicKey(extendedPublicKey: string, recipients: string[], fee: string): Promise<string>;\n    estimateFeeDefaultsFromExtendedPublicKey(publicKey: string, recipients: string[], values: string[], data?: any): Promise<FeeDefaults>;\n    getTransactionsFromExtendedPublicKey(extendedPublicKey: string, limit: number, cursor: IProtocolTransactionCursor): Promise<TezosTransactionResult>;\n    prepareTransactionFromExtendedPublicKey(extendedPublicKey: string, offset: number, recipients: string[], values: string[], fee: string): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/protocols/Secp256k1CryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { CryptoClient } from './CryptoClient';\nexport declare abstract class Secp256k1CryptoClient extends CryptoClient {\n    encryptAsymmetric(payload: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(encryptedPayload: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/protocols/Sr25519CryptoClient.d.ts",dts:"/// <reference types=\"node\" />\nimport { CryptoClient } from './CryptoClient';\nexport declare abstract class Sr25519CryptoClient extends CryptoClient {\n    encryptAsymmetric(payload: string, publicKey: string): Promise<string>;\n    decryptAsymmetric(encryptedPayload: string, keypair: {\n        publicKey: string;\n        privateKey: Buffer;\n    }): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/serializer/payloads/chunked-payload.d.ts",dts:"/// <reference types=\"node\" />\nimport { RLPData } from '../utils/toBuffer';\nimport { Payload } from './payload';\ninterface DecodedChunkedPayload {\n    currentPage: number;\n    total: number;\n    payload: Buffer;\n}\nexport declare class ChunkedPayload implements Payload {\n    currentPage: number;\n    total: number;\n    buffer: Buffer;\n    constructor(currentPage: number, total: number, buffer: Buffer);\n    static fromDecoded(object: DecodedChunkedPayload): ChunkedPayload;\n    static fromEncoded(buf: [Buffer, Buffer, Buffer]): ChunkedPayload;\n    asArray(): RLPData;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/payloads/full-payload.d.ts",dts:"/// <reference types=\"node\" />\nimport { IACMessageDefinitionObject } from '../message';\nimport { RLPData } from '../utils/toBuffer';\nimport { Payload } from './payload';\nexport declare class FullPayload implements Payload {\n    private readonly messages;\n    constructor(messages: IACMessageDefinitionObject[]);\n    static fromDecoded(object: IACMessageDefinitionObject[]): FullPayload;\n    static fromEncoded(buf: Buffer[]): FullPayload;\n    asJson(): IACMessageDefinitionObject[];\n    asArray(): RLPData;\n    asBuffer(): Buffer;\n    asString(): string;\n}\n"},{name:"@airgap/coinlib-core/serializer/payloads/payload.d.ts",dts:"import { RLPData } from '../utils/toBuffer';\nexport interface Payload {\n    asArray(): RLPData;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/account-share-request.d.ts",dts:"export interface AccountShareRequest {\n    protocols: string[];\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/account-share-response.d.ts",dts:"export interface AccountShareResponse {\n    publicKey: string;\n    derivationPath: string;\n    isExtendedPublicKey: boolean;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/config-set-request.d.ts",dts:"export interface ConfigSetRequest {\n    key: string;\n    value: string;\n    peerId: string;\n    signature: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/config-set-response.d.ts",dts:"export interface ConfigSetResponse {\n    key: string;\n    success: boolean;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/hex-string.d.ts",dts:"export declare type HexString = string;\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/item-retrieve-request.d.ts",dts:"export interface ItemStoreRequest {\n    storageId: string;\n    encryptionPublicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/item-retrieve-response.d.ts",dts:"export interface ItemStoreResponse {\n    payload: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/item-store-request.d.ts",dts:"export interface ItemStoreRequest {\n    id: string;\n    payload: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/item-store-response.d.ts",dts:"export interface ItemStoreResponse {\n    storageId: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/message-encrypt-request.d.ts",dts:"export interface MessageEncryptRequest {\n    method: 'symmetric' | 'asymmetric';\n    message: string;\n    publicKey: string;\n    protocol: string;\n    publicKeyToEncryptResponse: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/message-encrypt-response.d.ts",dts:"export interface MessageEncryptResponse {\n    encryptedMessage: string;\n    publicKey: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/message-sign-request.d.ts",dts:"export interface MessageSignRequest {\n    message: string;\n    publicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/message-sign-response.d.ts",dts:"export interface MessageSignResponse {\n    message: string;\n    publicKey: string;\n    signature: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/message-verify-request.d.ts",dts:"export interface MessageSignRequest {\n    message: string;\n    publicKey: string;\n    signature: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/message-verify-response.d.ts",dts:"export interface MessageSignResponse {\n    message: string;\n    publicKey: string;\n    signature: string;\n    isValid: boolean;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/multisig-request.d.ts",dts:"export interface MultisigRequest {\n    signingPeers: string[];\n    transaction: string;\n    signature: string;\n    publicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/multisig-response.d.ts",dts:"export interface MultisigResponse {\n    signingPeers: string[];\n    transaction: string;\n    signature: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/pair-request.d.ts",dts:"export interface PairRequest {\n    peerId: string;\n    appName: string;\n    appVersion: string;\n    publicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/pair-response.d.ts",dts:"export interface PairResponse {\n    peerId: string;\n    appName: string;\n    appVersion: string;\n    publicKey: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction-aeternity.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedAeternityTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction-bitcoin.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedBitcoinTransaction extends SignedTransaction {\n    from: string[];\n    to: string[];\n    amount: string;\n    fee: string;\n    accountIdentifier: string;\n    transaction: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction-cosmos.d.ts",dts:"import { IAirGapSignedTransaction } from '../../../interfaces/IAirGapSignedTransaction';\nimport { SignedTransaction } from './signed-transaction';\nexport interface SignedCosmosTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: IAirGapSignedTransaction;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction-ethereum.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedEthereumTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction-substrate.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedSubstrateTransaction extends SignedTransaction {\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction-tezos.d.ts",dts:"import { SignedTransaction } from './signed-transaction';\nexport interface SignedTezosTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/signed-transaction.d.ts",dts:"export interface SignedTransaction {\n    transaction: string;\n    accountIdentifier: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction-aeternity.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface RawAeternityTransaction {\n    networkId: string;\n    transaction: string;\n}\nexport interface UnsignedAeternityTransaction extends UnsignedTransaction {\n    transaction: RawAeternityTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction-bitcoin.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface IInTransaction {\n    txId: string;\n    value: string;\n    vout: number;\n    address: string;\n    derivationPath?: string;\n}\ninterface IOutTransaction {\n    recipient: string;\n    isChange: boolean;\n    value: string;\n    derivationPath?: string;\n}\ninterface RawBitcoinTransaction {\n    ins: IInTransaction[];\n    outs: IOutTransaction[];\n}\nexport interface UnsignedBitcoinTransaction extends UnsignedTransaction {\n    transaction: RawBitcoinTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction-cosmos.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface CosmosCoin {\n    denom: string;\n    amount: string;\n}\ninterface CosmosFee {\n    amount: CosmosCoin[];\n    gas: string;\n}\ndeclare enum CosmosMessageTypeIndex {\n    SEND = 0,\n    DELEGATE = 1,\n    UNDELEGATE = 2,\n    WITHDRAW_DELEGATION_REWARD = 3\n}\ninterface CosmosMessage {\n    type: CosmosMessageTypeIndex;\n    amount: CosmosCoin[];\n    fromAddress: string;\n    toAddress: string;\n}\ninterface CosmosTransaction {\n    messages: CosmosMessage[];\n    fee: CosmosFee;\n    memo: string;\n    chainID: string;\n    accountNumber: string;\n    sequence: string;\n}\nexport interface SerializableUnsignedCosmosTransaction extends UnsignedTransaction {\n    transaction: CosmosTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction-ethereum.d.ts",dts:"import { HexString } from './hex-string';\nimport { UnsignedTransaction } from './unsigned-transaction';\ninterface RawEthereumTransaction {\n    nonce: HexString;\n    gasPrice: HexString;\n    gasLimit: HexString;\n    to: HexString;\n    value: HexString;\n    chainId: number;\n    data: HexString;\n}\nexport interface UnsignedEthereumTransaction extends UnsignedTransaction {\n    transaction: RawEthereumTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction-substrate.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface RawSubstrateTransaction {\n    encoded: string;\n}\nexport interface UnsignedSubstrateTransaction extends UnsignedTransaction {\n    transaction: RawSubstrateTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction-tezos.d.ts",dts:"import { UnsignedTransaction } from './unsigned-transaction';\ninterface RawTezosTransaction {\n    binaryTransaction: string;\n}\nexport interface UnsignedTezosTransaction extends UnsignedTransaction {\n    transaction: RawTezosTransaction;\n}\nexport {};\n"},{name:"@airgap/coinlib-core/serializer/schemas/definitions/unsigned-transaction.d.ts",dts:"export interface UnsignedTransaction {\n    transaction: any;\n    publicKey: string;\n    callbackURL?: string;\n}\n"},{name:"@airgap/coinlib-core/serializer/schemas/schema.d.ts",dts:'export declare type SchemaTransformer = (value: any) => any;\nexport declare enum SchemaTypes {\n    STRING = "string",\n    NUMBER = "number",\n    INTEGER = "integer",\n    BOOLEAN = "boolean",\n    NULL = "null",\n    ARRAY = "array",\n    OBJECT = "object",\n    HEX_STRING = "hexString"\n}\nexport interface SchemaRoot {\n    $ref: string;\n    $schema: string;\n    definitions: SchemaDefinition;\n}\nexport interface SchemaItem {\n    $ref?: string;\n    type?: SchemaTypes;\n    additionalProperties?: boolean;\n    properties?: SchemaItem;\n    required?: string[];\n}\nexport interface SchemaDefinition {\n    [key: string]: SchemaItem;\n}\nexport interface SchemaInfo {\n    schema: SchemaRoot;\n    transformer?: SchemaTransformer;\n}\n'},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/aeternity-transactions.validator.d.ts",dts:"import { SignedAeternityTransaction } from '../schemas/definitions/signed-transaction-aeternity';\nimport { UnsignedAeternityTransaction } from '../schemas/definitions/unsigned-transaction-aeternity';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class AeternityTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedAeternityTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedAeternityTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/bitcoin-transactions.validator.d.ts",dts:"import { SignedBitcoinTransaction } from '../schemas/definitions/signed-transaction-bitcoin';\nimport { UnsignedBitcoinTransaction } from '../schemas/definitions/unsigned-transaction-bitcoin';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class BitcoinTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedBitcoinTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedBitcoinTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/cosmos-transactions.validator.d.ts",dts:"import { SignedTezosTransaction } from '../schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTezosTransaction } from '../schemas/definitions/unsigned-transaction-tezos';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class CosmosTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedTezosTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedTezosTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/ethereum-transactions.validator.d.ts",dts:"import { SignedEthereumTransaction } from '../schemas/definitions/signed-transaction-ethereum';\nimport { UnsignedEthereumTransaction } from '../schemas/definitions/unsigned-transaction-ethereum';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class EthereumTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedEthereumTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedEthereumTransaction): any;\n}\n"},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/substrate-transactions.validator.d.ts",dts:"import { SignedSubstrateTransaction } from '../schemas/definitions/signed-transaction-substrate';\nimport { UnsignedSubstrateTransaction } from '../schemas/definitions/unsigned-transaction-substrate';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class SubstrateTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedSubstrateTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedSubstrateTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/tezos-transactions.validator.d.ts",dts:"import { SignedTezosTransaction } from '../schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTezosTransaction } from '../schemas/definitions/unsigned-transaction-tezos';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class TezosTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedTezosTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedTezosTransaction): Promise<any>;\n}\n"},{name:"@airgap/coinlib-core/serializer/unsigned-transactions/xtz-btc-transactions.validator.d.ts",dts:"import { SignedTezosTransaction } from '../schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTezosTransaction } from '../schemas/definitions/unsigned-transaction-tezos';\nimport { TransactionValidator } from '../validators/transactions.validator';\nexport declare class TezosBTCTransactionValidator extends TransactionValidator {\n    validateUnsignedTransaction(unsignedTx: UnsignedTezosTransaction): Promise<any>;\n    validateSignedTransaction(signedTx: SignedTezosTransaction): Promise<any>;\n    private assertDestination;\n    private assertParameters;\n    private assertNoHiddenXTZAmount;\n}\n"},{name:"@airgap/coinlib-core/serializer/utils/generateId.d.ts",dts:"export declare function generateId(length: number): string;\n"},{name:"@airgap/coinlib-core/serializer/utils/json-to-rlp.d.ts",dts:"import { SchemaItem, SchemaRoot } from '../schemas/schema';\nimport { RLPData } from './toBuffer';\nexport declare function getDefinitionByRefPath(schema: SchemaRoot, refPath: string): SchemaItem;\nexport declare function unwrapSchema(schema: SchemaRoot): SchemaItem;\nexport declare function jsonToArray(key: string, schema: SchemaItem, value: Object): RLPData;\nexport declare function rlpArrayToJson(schema: SchemaItem, decoded: RLPData): {\n    [key: string]: unknown;\n};\n"},{name:"@airgap/coinlib-core/serializer/utils/toBuffer.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../dependencies/src/bignumber.js-9.0.0/bignumber';\nexport declare type RLPData = number | string | boolean | BigNumber | Buffer;\nexport declare function toBuffer(rlpArray: RLPData): Buffer | Buffer[];\n"},{name:"@airgap/coinlib-core/serializer/v1/errors/index.d.ts",dts:"/**\n * Gets thrown if the serializer version does not match\n */\nexport declare class SerializerVersionMismatch extends Error {\n    constructor();\n}\n/**\n * Gets thrown if the serializer cannot handle the specified coin/protocol\n */\nexport declare class ProtocolNotSupported extends Error {\n    constructor();\n}\n/**\n * Gets thrown if the serializer CAN handle the specified coin/protocol, but not in this version\n */\nexport declare class ProtocolVersionMismatch extends Error {\n    constructor();\n}\n/**\n * Gets thrown if the specified Type is not supported\n */\nexport declare class TypeNotSupported extends Error {\n    constructor();\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/signed-transactions/aeternity-transactions.serializer.d.ts",dts:"/// <reference types=\"node\" />\nimport { SerializedSyncProtocolSignedTransaction, SignedTransaction, SignedTransactionSerializer } from '../signed-transaction.serializer';\nexport declare type SerializedSignedAeternityTransaction = [Buffer];\nexport interface SignedAeternityTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: string;\n}\nexport declare class AeternitySignedTransactionSerializer extends SignedTransactionSerializer {\n    serialize(transaction: SignedAeternityTransaction): SerializedSyncProtocolSignedTransaction;\n    deserialize(serializedTx: SerializedSyncProtocolSignedTransaction): SignedAeternityTransaction;\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/signed-transactions/bitcoin-transactions.serializer.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SerializedSyncProtocolSignedTransaction, SignedTransaction, SignedTransactionSerializer } from '../signed-transaction.serializer';\nexport declare type SerializedSignedBitcoinTransaction = [Buffer, Buffer];\nexport interface SignedBitcoinTransaction extends SignedTransaction {\n    from: string[];\n    amount: BigNumber;\n    fee: BigNumber;\n    accountIdentifier: string;\n    transaction: string;\n}\nexport declare class BitcoinSignedTransactionSerializer extends SignedTransactionSerializer {\n    serialize(transaction: SignedBitcoinTransaction): SerializedSyncProtocolSignedTransaction;\n    deserialize(serializedTx: SerializedSyncProtocolSignedTransaction): SignedBitcoinTransaction;\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/signed-transactions/ethereum-transactions.serializer.d.ts",dts:"/// <reference types=\"node\" />\nimport { SerializedSyncProtocolSignedTransaction, SignedTransaction, SignedTransactionSerializer } from '../signed-transaction.serializer';\nexport declare type SerializedSignedEthereumTransaction = [Buffer];\nexport interface SignedEthereumTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: string;\n}\nexport declare class EthereumSignedTransactionSerializer extends SignedTransactionSerializer {\n    serialize(transaction: SignedEthereumTransaction): SerializedSyncProtocolSignedTransaction;\n    deserialize(serializedTx: SerializedSyncProtocolSignedTransaction): SignedEthereumTransaction;\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/signed-transactions/substrate-transactions.serializer.d.ts",dts:"/// <reference types=\"node\" />\nimport { SerializedSyncProtocolSignedTransaction, SignedTransaction, SignedTransactionSerializer } from '../signed-transaction.serializer';\nexport declare type SerializedSignedSubstrateTransaction = [Buffer];\nexport interface SignedSubstrateTransaction extends SignedTransaction {\n}\nexport declare class SubstrateSignedTransactionSerializer extends SignedTransactionSerializer {\n    serialize(transaction: SignedSubstrateTransaction): SerializedSyncProtocolSignedTransaction;\n    deserialize(serializedTx: SerializedSyncProtocolSignedTransaction): SignedSubstrateTransaction;\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/signed-transactions/tezos-transactions.serializer.d.ts",dts:"/// <reference types=\"node\" />\nimport { IAirGapSignedTransaction } from '../../../interfaces/IAirGapSignedTransaction';\nimport { SerializedSyncProtocolSignedTransaction, SignedTransaction, SignedTransactionSerializer } from '../signed-transaction.serializer';\nexport interface SignedTezosTransaction extends SignedTransaction {\n    accountIdentifier: string;\n    transaction: IAirGapSignedTransaction;\n}\nexport declare type SerializedSignedTezosTransaction = [Buffer];\nexport declare class TezosSignedTransactionSerializer extends SignedTransactionSerializer {\n    serialize(transaction: SignedTezosTransaction): SerializedSyncProtocolSignedTransaction;\n    deserialize(serializedTx: SerializedSyncProtocolSignedTransaction): SignedTezosTransaction;\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/unsigned-transactions/aeternity-transactions.serializer.d.ts",dts:"/// <reference types=\"node\" />\nimport { SerializedSyncProtocolTransaction, UnsignedTransaction, UnsignedTransactionSerializer } from '../unsigned-transaction.serializer';\nexport declare type SerializedUnsignedAeternityTransaction = [Buffer, Buffer];\nexport interface RawAeternityTransaction {\n    networkId: string;\n    transaction: string;\n}\nexport interface UnsignedAeternityTransaction extends UnsignedTransaction {\n    transaction: RawAeternityTransaction;\n}\nexport declare class AeternityUnsignedTransactionSerializer extends UnsignedTransactionSerializer {\n    serialize(transaction: UnsignedAeternityTransaction): SerializedSyncProtocolTransaction;\n    deserialize(serializedTx: SerializedSyncProtocolTransaction): UnsignedAeternityTransaction;\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/unsigned-transactions/bitcoin-transactions.serializer.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SerializedSyncProtocolTransaction, UnsignedTransaction, UnsignedTransactionSerializer } from '../unsigned-transaction.serializer';\nexport declare type SerializedUnsignedBitcoinTransaction = [[[Buffer, Buffer, Buffer, Buffer, Buffer]], [[Buffer, Buffer, Buffer]]];\nexport interface IInTransaction {\n    txId: string;\n    value: BigNumber;\n    vout: number;\n    address: string;\n    derivationPath?: string;\n}\nexport interface IOutTransaction {\n    recipient: string;\n    isChange: boolean;\n    value: BigNumber;\n}\nexport interface RawBitcoinTransaction {\n    ins: IInTransaction[];\n    outs: IOutTransaction[];\n}\nexport interface UnsignedBitcoinTransaction extends UnsignedTransaction {\n    transaction: RawBitcoinTransaction;\n}\nexport declare class BitcoinUnsignedTransactionSerializer extends UnsignedTransactionSerializer {\n    serialize(unsignedTx: UnsignedBitcoinTransaction): SerializedSyncProtocolTransaction;\n    deserialize(serializedTx: SerializedSyncProtocolTransaction): UnsignedBitcoinTransaction;\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/unsigned-transactions/ethereum-transactions.serializer.d.ts",dts:"/// <reference types=\"node\" />\nimport { SerializedSyncProtocolTransaction, UnsignedTransaction, UnsignedTransactionSerializer } from '../unsigned-transaction.serializer';\nexport declare type SerializedUnsignedEthereumTransaction = [Buffer, Buffer, Buffer, Buffer, Buffer, Buffer, Buffer];\nexport interface RawEthereumTransaction {\n    nonce: string;\n    gasPrice: string;\n    gasLimit: string;\n    to: string;\n    value: string;\n    chainId: number;\n    data: string;\n}\nexport interface UnsignedEthereumTransaction extends UnsignedTransaction {\n    transaction: RawEthereumTransaction;\n}\nexport declare class EthereumUnsignedTransactionSerializer extends UnsignedTransactionSerializer {\n    serialize(transaction: UnsignedEthereumTransaction): SerializedSyncProtocolTransaction;\n    deserialize(serializedTx: SerializedSyncProtocolTransaction): UnsignedEthereumTransaction;\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/unsigned-transactions/substrate-transactions.serializer.d.ts",dts:"/// <reference types=\"node\" />\nimport { SerializedSyncProtocolTransaction, UnsignedTransaction, UnsignedTransactionSerializer } from '../unsigned-transaction.serializer';\nexport declare type SerializedUnsignedSubstrateTransaction = [Buffer];\nexport interface RawSubstrateTransaction {\n    encoded: string;\n}\nexport interface UnsignedSubstrateTransaction extends UnsignedTransaction {\n    transaction: RawSubstrateTransaction;\n}\nexport declare class SubstrateUnsignedTransactionsSerializer extends UnsignedTransactionSerializer {\n    serialize(transaction: UnsignedSubstrateTransaction): SerializedSyncProtocolTransaction;\n    deserialize(serializedTx: SerializedSyncProtocolTransaction): UnsignedSubstrateTransaction;\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/unsigned-transactions/tezos-transactions.serializer.d.ts",dts:"/// <reference types=\"node\" />\nimport { SerializedSyncProtocolTransaction, UnsignedTransaction, UnsignedTransactionSerializer } from '../unsigned-transaction.serializer';\nexport declare type SerializedUnsignedTezosTransaction = [Buffer];\nexport interface RawTezosTransaction {\n    binaryTransaction: string;\n}\nexport interface UnsignedTezosTransaction extends UnsignedTransaction {\n    transaction: RawTezosTransaction;\n}\nexport declare class TezosUnsignedTransactionSerializer extends UnsignedTransactionSerializer {\n    serialize(unsignedTx: UnsignedTezosTransaction): SerializedSyncProtocolTransaction;\n    deserialize(serializedTx: SerializedSyncProtocolTransaction): UnsignedTezosTransaction;\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/utils/toBuffer.d.ts",dts:'/// <reference types="node" />\nexport declare function toBuffer(rlpArray: any): Buffer | Buffer[];\n'},{name:"@airgap/coinlib-core/serializer/v1/validators/validators.d.ts",dts:"export declare function validateSyncScheme(syncScheme: any): Promise<any>;\n"},{name:"@airgap/coinlib-core/serializer/v1/constants.d.ts",dts:'declare const SERIALIZER_VERSION = 1;\nexport { SERIALIZER_VERSION };\nexport declare enum TezosBTCDetails {\n    CONTRACT_ADDRESS = "KT1LH2o12xVRwTpJMZ6QJG74Fox8gE9QieFd"\n}\n'},{name:"@airgap/coinlib-core/serializer/v1/index.d.ts",dts:"import { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { SignedTransactionSerializer } from './signed-transaction.serializer';\nimport { UnsignedTransactionSerializer } from './unsigned-transaction.serializer';\nexport declare function unsignedTransactionSerializerByProtocolIdentifier(protocolIdentifier: ProtocolSymbols): UnsignedTransactionSerializer;\nexport declare function signedTransactionSerializerByProtocolIdentifier(protocolIdentifier: ProtocolSymbols): SignedTransactionSerializer;\n"},{name:"@airgap/coinlib-core/serializer/v1/serializer.d.ts",dts:"/// <reference types=\"node\" />\nimport { ProtocolSymbols } from '../../utils/ProtocolSymbols';\nimport { SerializedSyncProtocolSignedTransaction, SignedTransaction } from './signed-transaction.serializer';\nimport { SerializedSyncProtocolTransaction, UnsignedTransaction } from './unsigned-transaction.serializer';\nimport { SerializedSyncProtocolWalletSync, SyncWalletRequest } from './wallet-sync.serializer';\nexport declare enum SyncProtocolKeys {\n    VERSION = 0,\n    TYPE = 1,\n    PROTOCOL = 2,\n    PAYLOAD = 3\n}\nexport declare enum EncodedType {\n    UNSIGNED_TRANSACTION = 0,\n    SIGNED_TRANSACTION = 1,\n    WALLET_SYNC = 2\n}\nexport declare type SerializedSyncProtocolPayload = SerializedSyncProtocolTransaction | SerializedSyncProtocolWalletSync | SerializedSyncProtocolSignedTransaction;\nexport interface SerializedSyncProtocol extends Array<Buffer | SerializedSyncProtocolPayload> {\n    [0]: Buffer;\n    [1]: Buffer;\n    [2]: Buffer;\n    [3]: SerializedSyncProtocolPayload;\n}\nexport interface DeserializedSyncProtocol {\n    version?: number;\n    type: EncodedType;\n    protocol: ProtocolSymbols;\n    payload: UnsignedTransaction | SyncWalletRequest | SignedTransaction;\n}\nexport declare class SyncProtocolUtils {\n    serialize(deserializedSyncProtocol: DeserializedSyncProtocol): Promise<string>;\n    deserialize(serializedSyncProtocol: string): Promise<DeserializedSyncProtocol>;\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/signed-transaction.serializer.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { SerializedSignedAeternityTransaction } from './signed-transactions/aeternity-transactions.serializer';\nimport { SerializedSignedBitcoinTransaction } from './signed-transactions/bitcoin-transactions.serializer';\nimport { SerializedSignedEthereumTransaction } from './signed-transactions/ethereum-transactions.serializer';\nimport { SerializedSignedSubstrateTransaction } from './signed-transactions/substrate-transactions.serializer';\nimport { SerializedSignedTezosTransaction } from './signed-transactions/tezos-transactions.serializer';\nexport declare abstract class SignedTransactionSerializer {\n    abstract serialize(unsignedTx: SignedTransaction): SerializedSyncProtocolSignedTransaction;\n    abstract deserialize(serializedTx: SerializedSyncProtocolSignedTransaction): SignedTransaction;\n}\nexport interface SignedTransaction {\n    transaction: string;\n    accountIdentifier: string;\n    from?: string[];\n    amount?: BigNumber;\n    to?: string[];\n    fee?: BigNumber;\n}\nexport declare type SerializedSignedTransaction = SerializedSignedEthereumTransaction | SerializedSignedBitcoinTransaction | SerializedSignedAeternityTransaction | SerializedSignedTezosTransaction | SerializedSignedSubstrateTransaction;\nexport declare enum SyncProtocolSignedTransactionKeys {\n    SIGNED_TRANSACTION = 0,\n    ACCOUNT_IDENTIFIER = 1,\n    FROM = 2,\n    FEE = 3,\n    AMOUNT = 4,\n    TO = 5\n}\nexport interface SerializedSyncProtocolSignedTransaction extends Array<SerializedSignedTransaction | Buffer | Buffer[]> {\n    [0]: SerializedSignedTransaction;\n    [1]: Buffer;\n    [2]: Buffer[];\n    [3]: Buffer;\n    [4]: Buffer;\n    [5]: Buffer[];\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/unsigned-transaction.serializer.d.ts",dts:"/// <reference types=\"node\" />\nimport { RawAeternityTransaction } from './unsigned-transactions/aeternity-transactions.serializer';\nimport { RawBitcoinTransaction, SerializedUnsignedBitcoinTransaction } from './unsigned-transactions/bitcoin-transactions.serializer';\nimport { RawEthereumTransaction, SerializedUnsignedEthereumTransaction } from './unsigned-transactions/ethereum-transactions.serializer';\nimport { RawSubstrateTransaction, SerializedUnsignedSubstrateTransaction } from './unsigned-transactions/substrate-transactions.serializer';\nimport { RawTezosTransaction, SerializedUnsignedTezosTransaction } from './unsigned-transactions/tezos-transactions.serializer';\nexport declare abstract class UnsignedTransactionSerializer {\n    abstract serialize(unsignedTx: UnsignedTransaction): SerializedSyncProtocolTransaction;\n    abstract deserialize(serializedTx: SerializedSyncProtocolTransaction): UnsignedTransaction;\n}\nexport interface UnsignedTransaction {\n    transaction: RawEthereumTransaction | RawBitcoinTransaction | RawAeternityTransaction | RawTezosTransaction | RawSubstrateTransaction;\n    publicKey: string;\n    callback?: string;\n}\nexport declare type SerializedUnsignedTransaction = SerializedUnsignedEthereumTransaction | SerializedUnsignedBitcoinTransaction | SerializedUnsignedTezosTransaction | SerializedUnsignedSubstrateTransaction;\nexport declare enum SyncProtocolUnsignedTransactionKeys {\n    UNSIGNED_TRANSACTION = 0,\n    PUBLIC_KEY = 1,\n    CALLBACK = 2\n}\nexport interface SerializedSyncProtocolTransaction extends Array<SerializedUnsignedTransaction | Buffer | Buffer[]> {\n    [0]: SerializedUnsignedTransaction;\n    [1]: Buffer;\n    [2]: Buffer;\n}\n"},{name:"@airgap/coinlib-core/serializer/v1/wallet-sync.serializer.d.ts",dts:'/// <reference types="node" />\nexport interface SyncWalletRequest {\n    publicKey: string;\n    derivationPath: string;\n    isExtendedPublicKey: boolean;\n}\nexport declare enum SyncProtocolWalletSync {\n    PUBLIC_KEY = 0,\n    DERIVATION_PATH = 1,\n    IS_EXTENDED_PUBLIC_KEY = 2\n}\nexport interface SerializedSyncProtocolWalletSync extends Array<Buffer> {\n    [0]: Buffer;\n    [1]: Buffer;\n    [2]: Buffer;\n}\nexport declare class WalletSerializer {\n    serialize(syncWalletRequest: SyncWalletRequest): SerializedSyncProtocolWalletSync;\n    deserialize(serializedWalletRequest: SerializedSyncProtocolWalletSync): SyncWalletRequest;\n}\n'},{name:"@airgap/coinlib-core/serializer/validators/transactions.validator.d.ts",dts:"import { SignedTransaction } from '../schemas/definitions/signed-transaction';\nimport { UnsignedTransaction } from '../schemas/definitions/unsigned-transaction';\nexport declare abstract class TransactionValidator {\n    abstract validateUnsignedTransaction(transaction: UnsignedTransaction): Promise<boolean>;\n    abstract validateSignedTransaction(transaction: SignedTransaction): Promise<boolean>;\n}\n"},{name:"@airgap/coinlib-core/serializer/validators/validators.d.ts",dts:"export declare function validateSyncScheme(syncScheme: unknown): Promise<any>;\n"},{name:"@airgap/coinlib-core/serializer/constants.d.ts",dts:'declare const SERIALIZER_VERSION = 1;\nexport { SERIALIZER_VERSION };\nexport declare enum TezosBTCDetails {\n    CONTRACT_ADDRESS = "KT1PWx2mnDueood7fEmfbBDKx1D9BAnnXitn"\n}\nexport declare enum TezosETHtzDetails {\n    CONTRACT_ADDRESS = "KT19at7rQUvyjxnZ2fBv7D9zc8rkyG7gAoU8"\n}\nexport declare enum TezosWrappedDetails {\n    CONTRACT_ADDRESS = "KT1VYsVfmobT7rsMVivvZ4J8i3bPiqz12NaH"\n}\nexport declare enum TezosKolibriUSDDetails {\n    CONTRACT_ADDRESS = "KT1K9gCRgaLRFKTErYt1wVxA3Frb9FjasjTV"\n}\n'},{name:"@airgap/coinlib-core/serializer/inter-app-communication-protocol.d.ts",dts:"import { IACMessageDefinitionObject } from './message';\nimport { Payload } from './payloads/payload';\nimport { IACPayloadType } from './serializer';\nexport declare type IACProtocolVersion = number;\nexport declare type IACProtocolType = [IACProtocolVersion, IACPayloadType, Payload];\nexport declare class IACProtocol {\n    readonly version: number;\n    readonly payloadType: IACPayloadType;\n    payload: Payload;\n    constructor(data: Payload);\n    decoded(): IACProtocolType;\n    encoded(): string;\n    static fromDecoded(data: IACMessageDefinitionObject[], singleChunkSize?: number, multiChunkSize?: number): IACProtocol[];\n    static fromEncoded(data: string[]): IACProtocol[];\n}\n"},{name:"@airgap/coinlib-core/serializer/interfaces.d.ts",dts:"export declare enum IACMessageType {\n    AccountShareRequest = 3,\n    AccountShareResponse = 4,\n    TransactionSignRequest = 5,\n    TransactionSignResponse = 6,\n    MessageSignRequest = 7,\n    MessageSignResponse = 8\n}\n"},{name:"@airgap/coinlib-core/serializer/message.d.ts",dts:"/// <reference types=\"node\" />\nimport { ProtocolSymbols } from '../utils/ProtocolSymbols';\nimport { IACMessageType } from './interfaces';\nimport { AccountShareResponse } from './schemas/definitions/account-share-response';\nimport { MessageSignRequest } from './schemas/definitions/message-sign-request';\nimport { MessageSignResponse } from './schemas/definitions/message-sign-response';\nimport { SignedAeternityTransaction } from './schemas/definitions/signed-transaction-aeternity';\nimport { SignedBitcoinTransaction } from './schemas/definitions/signed-transaction-bitcoin';\nimport { SignedCosmosTransaction } from './schemas/definitions/signed-transaction-cosmos';\nimport { SignedEthereumTransaction } from './schemas/definitions/signed-transaction-ethereum';\nimport { SignedSubstrateTransaction } from './schemas/definitions/signed-transaction-substrate';\nimport { SignedTezosTransaction } from './schemas/definitions/signed-transaction-tezos';\nimport { UnsignedAeternityTransaction } from './schemas/definitions/unsigned-transaction-aeternity';\nimport { UnsignedBitcoinTransaction } from './schemas/definitions/unsigned-transaction-bitcoin';\nimport { UnsignedEthereumTransaction } from './schemas/definitions/unsigned-transaction-ethereum';\nimport { UnsignedSubstrateTransaction } from './schemas/definitions/unsigned-transaction-substrate';\nimport { UnsignedTezosTransaction } from './schemas/definitions/unsigned-transaction-tezos';\nimport { UnsignedCosmosTransaction } from './types';\nimport { RLPData } from './utils/toBuffer';\nexport declare type IACMessages = AccountShareResponse | MessageSignRequest | MessageSignResponse | UnsignedTezosTransaction | UnsignedAeternityTransaction | UnsignedBitcoinTransaction | UnsignedCosmosTransaction | UnsignedEthereumTransaction | UnsignedSubstrateTransaction | SignedTezosTransaction | SignedAeternityTransaction | SignedBitcoinTransaction | SignedCosmosTransaction | SignedEthereumTransaction | SignedSubstrateTransaction;\nexport interface IACMessageDefinitionObject {\n    id: string;\n    type: IACMessageType;\n    protocol: ProtocolSymbols;\n    payload: IACMessages;\n}\nexport interface MessageDefinitionArray {\n    [0]: Buffer;\n    [1]: Buffer;\n    [2]: Buffer;\n    [3]: Buffer;\n    [4]: Buffer;\n}\nexport declare class Message implements IACMessageDefinitionObject {\n    private readonly version;\n    private readonly schema;\n    readonly id: string;\n    readonly type: IACMessageType;\n    readonly protocol: ProtocolSymbols;\n    readonly payload: IACMessages;\n    constructor(type: IACMessageType, protocol: ProtocolSymbols, payload: IACMessages, id?: string, version?: string);\n    asJson(): IACMessageDefinitionObject;\n    asArray(): RLPData;\n    static fromDecoded(object: IACMessageDefinitionObject): Message;\n    static fromEncoded(buf: MessageDefinitionArray): Message;\n    private static parseVersion;\n    private static parseType;\n    private static parseProtocol;\n    private static parseId;\n    private static parsePayload;\n    private static validateProperty;\n}\n"},{name:"@airgap/coinlib-core/serializer/serializer.d.ts",dts:"import { ProtocolSymbols } from '../utils/ProtocolSymbols';\nimport { IACMessageDefinitionObject } from './message';\nimport { SchemaInfo } from './schemas/schema';\nimport { TransactionValidator } from './validators/transactions.validator';\nexport declare enum IACPayloadType {\n    FULL = 0,\n    CHUNKED = 1\n}\nexport declare class Serializer {\n    private static readonly schemas;\n    static addSchema(schemaId: number, schema: SchemaInfo, protocol?: ProtocolSymbols): void;\n    static getSchema(schemaId: number, protocol?: ProtocolSymbols): SchemaInfo;\n    private static getSchemaName;\n    serialize(messages: IACMessageDefinitionObject[], singleChunkSize?: number, multiChunkSize?: number): Promise<string[]>;\n    deserialize(data: string[]): Promise<IACMessageDefinitionObject[]>;\n    serializationValidatorByProtocolIdentifier(protocolIdentifier: ProtocolSymbols): TransactionValidator;\n}\n"},{name:"@airgap/coinlib-core/serializer/types.d.ts",dts:"import { CosmosTransaction } from '../protocols/cosmos/CosmosTransaction';\nimport { UnsignedTransaction } from './schemas/definitions/unsigned-transaction';\nexport interface RawTezosTransaction {\n    binaryTransaction: string;\n}\nexport interface RawEthereumTransaction {\n    nonce: string;\n    gasPrice: string;\n    gasLimit: string;\n    to: string;\n    value: string;\n    chainId: number;\n    data: string;\n}\nexport interface IInTransaction {\n    txId: string;\n    value: string;\n    vout: number;\n    address: string;\n    derivationPath?: string;\n}\nexport interface IOutTransaction {\n    recipient: string;\n    isChange: boolean;\n    value: string;\n    derivationPath?: string;\n}\nexport interface RawBitcoinTransaction {\n    ins: IInTransaction[];\n    outs: IOutTransaction[];\n}\nexport interface RawAeternityTransaction {\n    networkId: string;\n    transaction: string;\n}\nexport interface UnsignedCosmosTransaction extends UnsignedTransaction {\n    transaction: CosmosTransaction;\n}\nexport interface RawSubstrateTransaction {\n    encoded: string;\n}\n"},{name:"@airgap/coinlib-core/utils/AES.d.ts",dts:"/// <reference types=\"node\" />\nexport declare class AES {\n    readonly AES_KEY_SIZE: number;\n    readonly KEY_DERIVATION_ITERATION_COUNT: number;\n    readonly ALGORITHM: 'aes-256-gcm';\n    readonly encoding: 'base64' | 'hex';\n    constructor(AES_KEY_SIZE?: number, KEY_DERIVATION_ITERATION_COUNT?: number, ALGORITHM?: 'aes-256-gcm', encoding?: 'base64' | 'hex');\n    encryptString(plainText: string, privateKey: Buffer): Promise<string>;\n    decryptString(encryptedValue: string, privateKey: Buffer): Promise<string>;\n    private deriveKeyFromPrivateKey;\n}\n"},{name:"@airgap/coinlib-core/utils/ErrorWithData.d.ts",dts:"export declare class ErrorWithData extends Error {\n    data: unknown;\n    constructor(message: string, data: unknown);\n}\n"},{name:"@airgap/coinlib-core/utils/Network.d.ts",dts:"import { ProtocolNetwork } from './ProtocolNetwork';\nexport declare const isNetworkEqual: (network1: ProtocolNetwork, network2: ProtocolNetwork) => boolean;\n"},{name:"@airgap/coinlib-core/utils/ProtocolBlockExplorer.d.ts",dts:"export declare abstract class ProtocolBlockExplorer {\n    readonly blockExplorer: string;\n    constructor(blockExplorer: string);\n    abstract getAddressLink(address: string): Promise<string>;\n    abstract getTransactionLink(transactionId: string): Promise<string>;\n}\n"},{name:"@airgap/coinlib-core/utils/ProtocolNetwork.d.ts",dts:'import { ProtocolBlockExplorer } from \'./ProtocolBlockExplorer\';\nexport declare enum NetworkType {\n    MAINNET = "MAINNET",\n    TESTNET = "TESTNET",\n    CUSTOM = "CUSTOM"\n}\nexport declare abstract class ProtocolNetwork<T = unknown> {\n    readonly name: string;\n    readonly type: NetworkType;\n    readonly rpcUrl: string;\n    readonly blockExplorer: ProtocolBlockExplorer;\n    readonly extras: T;\n    get identifier(): string;\n    constructor(name: string, type: NetworkType, rpcUrl: string, blockExplorer: ProtocolBlockExplorer, extras: T);\n}\n'},{name:"@airgap/coinlib-core/utils/ProtocolOptions.d.ts",dts:"import { ProtocolNetwork } from './ProtocolNetwork';\nexport interface ProtocolOptions<T = unknown> {\n    network: ProtocolNetwork;\n    config: T;\n}\n"},{name:"@airgap/coinlib-core/utils/ProtocolSymbols.d.ts",dts:'export declare enum MainProtocolSymbols {\n    AE = "ae",\n    BTC = "btc",\n    ETH = "eth",\n    XTZ = "xtz",\n    GRS = "grs",\n    COSMOS = "cosmos",\n    POLKADOT = "polkadot",\n    KUSAMA = "kusama"\n}\nexport declare enum SubProtocolSymbols {\n    XTZ_KT = "xtz-kt",\n    XTZ_BTC = "xtz-btc",\n    XTZ_USD = "xtz-usd",\n    XTZ_KUSD = "xtz-kusd",\n    XTZ_STKR = "xtz-stkr",\n    XTZ_ETHTZ = "xtz-eth",\n    XTZ_W = "xtz-w",\n    ETH_ERC20 = "eth-erc20",\n    ETH_ERC20_XCHF = "eth-erc20-xchf"\n}\nexport declare type ProtocolSymbols = MainProtocolSymbols | SubProtocolSymbols;\n'},{name:"@airgap/coinlib-core/utils/assert.d.ts",dts:"export declare const assertNever: (x: never) => void;\nexport declare function assertFields(name: string, object: any, ...fields: string[]): void;\n"},{name:"@airgap/coinlib-core/utils/base64Check.d.ts",dts:'/// <reference types="node" />\ndeclare const bs64check: {\n    encode(input: any): string;\n    decode(input: Buffer | string): any;\n    checkSum: (payload: Buffer | string) => any;\n};\nexport default bs64check;\n'},{name:"@airgap/coinlib-core/utils/blake2b.d.ts",dts:"export declare function blake2bAsHex(data: Uint8Array | string, bitLength: number, config?: {\n    withPrefix: boolean;\n}): string;\nexport declare function blake2bAsBytes(data: Uint8Array | string, bitLength: number): Uint8Array;\n"},{name:"@airgap/coinlib-core/utils/coinlibReady.d.ts",dts:"declare const isCoinlibReady: () => Promise<boolean>;\nexport { isCoinlibReady };\n"},{name:"@airgap/coinlib-core/utils/error.d.ts",dts:"export declare function invalidArgumentTypeError(name: string, expected: string, actual: string): Error;\n"},{name:"@airgap/coinlib-core/utils/hex.d.ts",dts:"/// <reference types=\"node\" />\nimport BigNumber from '../dependencies/src/bignumber.js-9.0.0/bignumber';\nexport declare function addHexPrefix(raw: string): string;\nexport declare function stripHexPrefix(hex: string): string;\nexport declare function isHex(value: string): boolean;\nexport declare function toHexBuffer(value: number | BigNumber): Buffer;\nexport declare function toHexStringRaw(value: number | BigNumber, bitLength?: number): string;\nexport declare function toHexString(value: number | BigNumber, bitLength?: number): string;\nexport declare function hexToBytes(hex: string | Uint8Array | Buffer): Buffer;\nexport declare function bytesToHex(bytes: Uint8Array | Buffer | string, config?: {\n    withPrefix: boolean;\n}): string;\nexport declare function changeEndianness(hex: string): string;\n"},{name:"@airgap/coinlib-core/utils/padStart.d.ts",dts:"export declare function padStart(targetString: string, targetLength: number, padString: string): string;\n"},{name:"@airgap/coinlib-core/utils/protocolOptionsByIdentifier.d.ts",dts:"import { ProtocolNetwork } from './ProtocolNetwork';\nimport { ProtocolOptions } from './ProtocolOptions';\nimport { ProtocolSymbols } from './ProtocolSymbols';\ndeclare const getProtocolOptionsByIdentifier: (identifier: ProtocolSymbols, network?: ProtocolNetwork) => ProtocolOptions;\nexport { getProtocolOptionsByIdentifier };\n"},{name:"@airgap/coinlib-core/utils/protocolsByIdentifier.d.ts",dts:"import { ICoinProtocol } from '../protocols/ICoinProtocol';\nimport { ProtocolNetwork } from './ProtocolNetwork';\nimport { ProtocolSymbols } from './ProtocolSymbols';\nexport declare const getProtocolByIdentifier: (identifier: ProtocolSymbols, network?: ProtocolNetwork) => ICoinProtocol;\n"},{name:"@airgap/coinlib-core/utils/sr25519.d.ts",dts:"import { KeyPair } from '../data/KeyPair';\nexport declare function createSr25519KeyPair(secret: string | Uint8Array, derivationPath: string): Promise<KeyPair>;\n"},{name:"@airgap/coinlib-core/utils/subProtocols.d.ts",dts:"import { ICoinProtocol } from '../protocols/ICoinProtocol';\nimport { ICoinSubProtocol } from '../protocols/ICoinSubProtocol';\nimport { ProtocolNetwork } from './ProtocolNetwork';\nimport { ProtocolSymbols } from './ProtocolSymbols';\ndeclare const getSubProtocolsByIdentifier: (identifier: ProtocolSymbols, network?: ProtocolNetwork) => ICoinSubProtocol[];\ndeclare const addSubProtocol: (protocol: ICoinProtocol, subProtocol: ICoinSubProtocol) => void;\ndeclare const removeSubProtocol: (protocol: ICoinProtocol, subProtocol: ICoinSubProtocol) => void;\nexport { addSubProtocol, removeSubProtocol, getSubProtocolsByIdentifier };\n"},{name:"@airgap/coinlib-core/utils/supportedProtocols.d.ts",dts:"import { ICoinProtocol } from '../protocols/ICoinProtocol';\ndeclare const supportedProtocols: () => ICoinProtocol[];\ndeclare const addSupportedProtocol: (newProtocol: ICoinProtocol) => void;\ndeclare const removeSupportedProtocol: (protocolToRemove: ICoinProtocol) => void;\nexport { addSupportedProtocol, removeSupportedProtocol, supportedProtocols };\n"},{name:"@airgap/coinlib-core/utils/type.d.ts",dts:"export declare function isRecord(obj: unknown): obj is Record<string, any>;\n"},{name:"@airgap/coinlib-core/utils/xxhash.d.ts",dts:'/// <reference types="node" />\nexport declare function xxhashAsHex(data: string | Uint8Array | Buffer, bitLength: number, config?: {\n    littleEndian: boolean;\n    withPrefix: boolean;\n}): string;\n'},{name:"@airgap/coinlib-core/wallet/AirGapMarketWallet.d.ts",dts:"import BigNumber from '../dependencies/src/bignumber.js-9.0.0/bignumber';\nimport { IAirGapTransaction, IProtocolTransactionCursor, IAirGapTransactionResult } from '../interfaces/IAirGapTransaction';\nimport { FeeDefaults, ICoinProtocol } from '../protocols/ICoinProtocol';\nimport { AirGapWallet } from './AirGapWallet';\nexport declare enum TimeInterval {\n    HOURS = \"24h\",\n    DAYS = \"7d\",\n    MONTH = \"30d\"\n}\nexport interface AirGapWalletPriceService {\n    getCurrentMarketPrice(protocol: ICoinProtocol, baseSymbol: string): Promise<BigNumber>;\n}\nexport declare class AirGapMarketWallet extends AirGapWallet {\n    protocol: ICoinProtocol;\n    publicKey: string;\n    isExtendedPublicKey: boolean;\n    derivationPath: string;\n    priceService: AirGapWalletPriceService;\n    addressIndex?: number | undefined;\n    currentBalance: BigNumber | undefined;\n    _currentMarketPrice: BigNumber | undefined;\n    private synchronizePromise?;\n    get currentMarketPrice(): BigNumber | undefined;\n    set currentMarketPrice(marketPrice: BigNumber | undefined);\n    constructor(protocol: ICoinProtocol, publicKey: string, isExtendedPublicKey: boolean, derivationPath: string, priceService: AirGapWalletPriceService, addressIndex?: number | undefined);\n    synchronize(): Promise<void>;\n    setProtocol(protocol: ICoinProtocol): Promise<void>;\n    fetchCurrentMarketPrice(baseSymbol?: string): Promise<BigNumber>;\n    private addressesToCheck;\n    balanceOf(): Promise<BigNumber>;\n    fetchTransactions(limit: number, cursor?: IProtocolTransactionCursor): Promise<IAirGapTransactionResult>;\n    getMaxTransferValue(recipients: string[], fee?: string): Promise<BigNumber>;\n    prepareTransaction(recipients: string[], values: string[], fee: string, data?: unknown): Promise<IAirGapTransaction>;\n    estimateFees(recipients: string[], values: string[], data?: unknown): Promise<FeeDefaults>;\n}\n"},{name:"@airgap/coinlib-core/wallet/AirGapWallet.d.ts",dts:"import { IAirGapWallet } from '../interfaces/IAirGapWallet';\nimport { ICoinProtocol } from '../protocols/ICoinProtocol';\nimport { ProtocolSymbols } from '../utils/ProtocolSymbols';\nexport interface SerializedAirGapWallet {\n    protocolIdentifier: ProtocolSymbols;\n    networkIdentifier: string;\n    publicKey: string;\n    isExtendedPublicKey: boolean;\n    derivationPath: string;\n    addresses: string[];\n    addressIndex?: number;\n}\nexport declare class AirGapWallet implements IAirGapWallet {\n    protocol: ICoinProtocol;\n    publicKey: string;\n    isExtendedPublicKey: boolean;\n    derivationPath: string;\n    addressIndex?: number | undefined;\n    addresses: string[];\n    constructor(protocol: ICoinProtocol, publicKey: string, isExtendedPublicKey: boolean, derivationPath: string, addressIndex?: number | undefined);\n    readonly receivingPublicAddress: string;\n    setProtocol(protocol: ICoinProtocol): Promise<void>;\n    deriveAddresses(amount?: number): Promise<string[]>;\n    toJSON(): SerializedAirGapWallet;\n}\n"},{name:"@airgap/coinlib-core/index.d.ts",dts:"import { EthereumProtocol } from './protocols/ethereum/EthereumProtocol';\nimport { ProtocolNotSupported, ProtocolVersionMismatch, SerializerVersionMismatch, TypeNotSupported } from './errors';\nimport { IAirGapTransaction, IAirGapTransactionResult, IProtocolTransactionCursor } from './interfaces/IAirGapTransaction';\nimport { IAirGapWallet } from './interfaces/IAirGapWallet';\nimport { AeternityProtocol } from './protocols/aeternity/AeternityProtocol';\nimport { BitcoinProtocol } from './protocols/bitcoin/BitcoinProtocol';\nimport { BitcoinTestnetProtocol } from './protocols/bitcoin/BitcoinTestnetProtocol';\nimport { CosmosDelegationActionType, CosmosProtocol } from './protocols/cosmos/CosmosProtocol';\nimport { GenericERC20 } from './protocols/ethereum/erc20/GenericERC20';\nimport { EthereumClassicProtocol } from './protocols/ethereum/EthereumClassicProtocol';\nimport { EthereumRopstenProtocol } from './protocols/ethereum/EthereumRopstenProtocol';\nimport { GroestlcoinProtocol } from './protocols/groestlcoin/GroestlcoinProtocol';\nimport { GroestlcoinTestnetProtocol } from './protocols/groestlcoin/GroestlcoinTestnetProtocol';\nimport { DelegateeDetails, DelegatorAction, DelegatorDetails, DelegatorReward, ICoinDelegateProtocol } from './protocols/ICoinDelegateProtocol';\nimport { FeeDefaults, ICoinProtocol } from './protocols/ICoinProtocol';\nimport { ICoinSubProtocol, SubProtocolType } from './protocols/ICoinSubProtocol';\nimport { SubstratePayee } from './protocols/substrate/helpers/data/staking/SubstratePayee';\nimport { KusamaProtocol } from './protocols/substrate/implementations/KusamaProtocol';\nimport { PolkadotProtocol } from './protocols/substrate/implementations/PolkadotProtocol';\nimport { SubstrateProtocol } from './protocols/substrate/SubstrateProtocol';\nimport { TezosBTC } from './protocols/tezos/fa/TezosBTC';\nimport { TezosFAProtocol } from './protocols/tezos/fa/TezosFAProtocol';\nimport { TezosStaker } from './protocols/tezos/fa/TezosStaker';\nimport { TezosKtProtocol } from './protocols/tezos/kt/TezosKtProtocol';\nimport { TezosUSD } from './protocols/tezos/fa/TezosUSD';\nimport { BakerInfo, DelegationInfo, DelegationRewardInfo, TezosDelegatorAction, TezosNetwork, TezosPayoutInfo, TezosProtocol } from './protocols/tezos/TezosProtocol';\nimport { IACMessageType } from './serializer/interfaces';\nimport { IACMessageDefinitionObject, Message } from './serializer/message';\nimport { AccountShareResponse } from './serializer/schemas/definitions/account-share-response';\nimport { MessageSignRequest } from './serializer/schemas/definitions/message-sign-request';\nimport { MessageSignResponse } from './serializer/schemas/definitions/message-sign-response';\nimport { SignedTransaction } from './serializer/schemas/definitions/signed-transaction';\nimport { SignedAeternityTransaction } from './serializer/schemas/definitions/signed-transaction-aeternity';\nimport { SignedBitcoinTransaction } from './serializer/schemas/definitions/signed-transaction-bitcoin';\nimport { SignedCosmosTransaction } from './serializer/schemas/definitions/signed-transaction-cosmos';\nimport { SignedEthereumTransaction } from './serializer/schemas/definitions/signed-transaction-ethereum';\nimport { SignedTezosTransaction } from './serializer/schemas/definitions/signed-transaction-tezos';\nimport { UnsignedTransaction } from './serializer/schemas/definitions/unsigned-transaction';\nimport { UnsignedAeternityTransaction } from './serializer/schemas/definitions/unsigned-transaction-aeternity';\nimport { UnsignedBitcoinTransaction } from './serializer/schemas/definitions/unsigned-transaction-bitcoin';\nimport { UnsignedEthereumTransaction } from './serializer/schemas/definitions/unsigned-transaction-ethereum';\nimport { UnsignedTezosTransaction } from './serializer/schemas/definitions/unsigned-transaction-tezos';\nimport { IACPayloadType, Serializer } from './serializer/serializer';\nimport { RawAeternityTransaction, RawBitcoinTransaction, RawEthereumTransaction, RawSubstrateTransaction, RawTezosTransaction, UnsignedCosmosTransaction } from './serializer/types';\nimport { isCoinlibReady } from './utils/coinlibReady';\nimport { isNetworkEqual } from './utils/Network';\nimport { getProtocolByIdentifier } from './utils/protocolsByIdentifier';\nimport { addSubProtocol, getSubProtocolsByIdentifier } from './utils/subProtocols';\nimport { getProtocolOptionsByIdentifier } from './utils/protocolOptionsByIdentifier';\nimport { addSupportedProtocol, supportedProtocols } from './utils/supportedProtocols';\nimport { AirGapMarketWallet, AirGapWalletPriceService, TimeInterval } from './wallet/AirGapMarketWallet';\nimport { AirGapWallet, SerializedAirGapWallet } from './wallet/AirGapWallet';\nimport { AeternityProtocolOptions, AeternalBlockExplorer, AeternityProtocolNetwork } from './protocols/aeternity/AeternityProtocolOptions';\nimport { AeternityCryptoClient } from './protocols/aeternity/AeternityCryptoClient';\nimport { BitcoinCryptoClient } from './protocols/bitcoin/BitcoinCryptoClient';\nimport { BitcoinProtocolNetworkExtras, BitcoinProtocolNetwork, BitcoinProtocolConfig, BlockcypherBlockExplorer, BitcoinProtocolOptions } from './protocols/bitcoin/BitcoinProtocolOptions';\nimport { CosmosCryptoClient } from './protocols/cosmos/CosmosCryptoClient';\nimport { MintscanBlockExplorer, CosmosProtocolNetwork, CosmosProtocolConfig, CosmosProtocolOptions } from './protocols/cosmos/CosmosProtocolOptions';\nimport { EthereumCryptoClient } from './protocols/ethereum/EthereumCryptoClient';\nimport { SubstrateCryptoClient } from './protocols/substrate/SubstrateCryptoClient';\nimport { TezosCryptoClient } from './protocols/tezos/TezosCryptoClient';\nimport { EthereumProtocolNetworkExtras, EtherscanBlockExplorer, EthereumProtocolNetwork, EthereumProtocolConfig, EthereumProtocolOptions, EthereumERC20ProtocolConfig, EthereumERC20ProtocolOptions } from './protocols/ethereum/EthereumProtocolOptions';\nimport { ProtocolBlockExplorer } from './utils/ProtocolBlockExplorer';\nimport { NetworkType, ProtocolNetwork } from './utils/ProtocolNetwork';\nimport { GroestlcoinProtocolNetworkExtras, CryptoidBlockExplorer, GroestlcoinProtocolNetwork, GroestlcoinProtocolConfig, GroestlcoinProtocolOptions } from './protocols/groestlcoin/GroestlcoinProtocolOptions';\nimport { SubstrateProtocolNetworkExtras, PolkascanBlockExplorer, SubstrateProtocolConfig, SubstrateProtocolNetwork, SubstrateProtocolOptions } from './protocols/substrate/SubstrateProtocolOptions';\nimport { KusamaProtocolNetworkExtras, KusamaPolkascanBlockExplorer, KusamaProtocolConfig, KusamaProtocolNetwork, KusamaProtocolOptions } from './protocols/substrate/implementations/KusamaProtocolOptions';\nimport { PolkadotProtocolNetworkExtras, PolkadotPolkascanBlockExplorer, PolkadotProtocolConfig, PolkadotProtocolNetwork, PolkadotProtocolOptions } from './protocols/substrate/implementations/PolkadotProtocolOptions';\nimport { CryptoClient } from './protocols/CryptoClient';\nimport { TezosProtocolNetworkExtras, TezblockBlockExplorer, TezosProtocolNetwork, TezosProtocolConfig, TezosProtocolOptions } from './protocols/tezos/TezosProtocolOptions';\nimport { TezosFAProtocolConfig, TezosBTCProtocolConfig, TezosStakerProtocolConfig, TezosUSDProtocolConfig, TezosFAProtocolOptions, TezosFA2ProtocolConfig, TezosFA2ProtocolOptions, TezosETHtzProtocolConfig, TezosWrappedProtocolConfig, TezosKolibriUSDProtocolConfig } from './protocols/tezos/fa/TezosFAProtocolOptions';\nimport { TezosTransactionResult } from './protocols/tezos/types/TezosTransactionResult';\nimport { TezosTransactionCursor } from './protocols/tezos/types/TezosTransactionCursor';\nimport { generateId } from './serializer/utils/generateId';\nimport { ProtocolSymbols, MainProtocolSymbols, SubProtocolSymbols } from './utils/ProtocolSymbols';\nimport { TezosUtils } from './protocols/tezos/TezosUtils';\nimport { TezosFA2Protocol } from './protocols/tezos/fa/TezosFA2Protocol';\nimport { TezosFA1Protocol } from './protocols/tezos/fa/TezosFA1Protocol';\nimport { TezosFA12Protocol } from './protocols/tezos/fa/TezosFA12Protocol';\nimport { DeserializedSyncProtocol, EncodedType, SyncProtocolUtils } from './serializer/v1/serializer';\nimport { ImportAccountAction, ImportAccoutActionContext } from './actions/GetKtAccountsAction';\nimport { CosmosUnbondingDelegation, CosmosValidator } from './protocols/cosmos/CosmosNodeClient';\nimport { SubstrateElectionStatus } from './protocols/substrate/helpers/data/staking/SubstrateEraElectionStatus';\nimport { SubstrateNominationStatus } from './protocols/substrate/helpers/data/staking/SubstrateNominationStatus';\nimport { SubstrateNominatorDetails, SubstrateStakingDetails } from './protocols/substrate/helpers/data/staking/SubstrateNominatorDetails';\nimport { SubstrateStakingActionType } from './protocols/substrate/helpers/data/staking/SubstrateStakingActionType';\nimport { SubstrateValidatorDetails } from './protocols/substrate/helpers/data/staking/SubstrateValidatorDetails';\nimport { IAirGapSignedTransaction } from './interfaces/IAirGapSignedTransaction';\nimport { Action } from './actions/Action';\nimport { SubstrateTransaction } from './protocols/substrate/helpers/data/transaction/SubstrateTransaction';\nimport { LinkedAction } from './actions/LinkedAction';\nimport { SimpleAction } from './actions/SimpleAction';\nimport { RepeatableAction } from './actions/RepeatableAction';\nimport { TezosWrappedOperation } from './protocols/tezos/types/TezosWrappedOperation';\nimport { assertNever } from './utils/assert';\nimport { CosmosTransaction } from './protocols/cosmos/CosmosTransaction';\nimport { TezosETHtz } from './protocols/tezos/fa/TezosETHtz';\nimport { TezosWrapped } from './protocols/tezos/fa/TezosWrapped';\nimport { TezosKolibriUSD } from './protocols/tezos/fa/TezosKolibriUSD';\nexport { AirGapWallet, AirGapMarketWallet, IAirGapWallet, IAirGapTransaction, ICoinProtocol, ICoinSubProtocol, ICoinDelegateProtocol, CryptoClient, ProtocolBlockExplorer, ProtocolNetwork, ProtocolSymbols, MainProtocolSymbols, SubProtocolSymbols, NetworkType, FeeDefaults };\nexport { AeternityProtocol, AeternityCryptoClient, AeternityProtocolOptions, AeternalBlockExplorer, AeternityProtocolNetwork, RawAeternityTransaction };\nexport { BitcoinProtocol, BitcoinTestnetProtocol, BitcoinCryptoClient, BitcoinProtocolNetworkExtras, BlockcypherBlockExplorer, BitcoinProtocolNetwork, BitcoinProtocolConfig, BitcoinProtocolOptions, RawBitcoinTransaction };\nexport { CosmosProtocol, CosmosCryptoClient, MintscanBlockExplorer, CosmosProtocolNetwork, CosmosProtocolConfig, CosmosProtocolOptions, CosmosUnbondingDelegation, CosmosValidator, CosmosDelegationActionType, CosmosTransaction };\nexport { EthereumProtocol, EthereumRopstenProtocol, EthereumClassicProtocol, GenericERC20, EthereumCryptoClient, EthereumProtocolNetworkExtras, EtherscanBlockExplorer, EthereumProtocolNetwork, EthereumProtocolConfig, EthereumProtocolOptions, EthereumERC20ProtocolConfig, EthereumERC20ProtocolOptions, RawEthereumTransaction };\nexport { GroestlcoinProtocol, GroestlcoinTestnetProtocol, GroestlcoinProtocolNetworkExtras, CryptoidBlockExplorer, GroestlcoinProtocolNetwork, GroestlcoinProtocolConfig, GroestlcoinProtocolOptions };\nexport { SubstrateProtocol, PolkadotProtocol, KusamaProtocol, SubstratePayee, SubstrateCryptoClient, SubstrateProtocolNetworkExtras, PolkascanBlockExplorer, SubstrateProtocolConfig, SubstrateProtocolNetwork, SubstrateProtocolOptions, KusamaProtocolNetworkExtras, KusamaPolkascanBlockExplorer, KusamaProtocolConfig, KusamaProtocolNetwork, KusamaProtocolOptions, PolkadotProtocolNetworkExtras, PolkadotPolkascanBlockExplorer, PolkadotProtocolConfig, PolkadotProtocolNetwork, PolkadotProtocolOptions, SubstrateElectionStatus, SubstrateNominationStatus, SubstrateNominatorDetails, SubstrateStakingDetails, SubstrateStakingActionType, SubstrateValidatorDetails, SubstrateTransaction, RawSubstrateTransaction };\nexport { TezosProtocol, TezosKtProtocol, TezosFAProtocol, TezosFA1Protocol, TezosFA12Protocol, TezosFA2Protocol, TezosBTC, TezosStaker, TezosUSD, TezosETHtz as TezosETH, TezosWrapped, TezosKolibriUSD, TezosTransactionResult, TezosTransactionCursor, BakerInfo, DelegationRewardInfo, DelegationInfo, TezosPayoutInfo, TezosDelegatorAction, TezosCryptoClient, TezosProtocolNetworkExtras, TezblockBlockExplorer, TezosProtocolNetwork, TezosProtocolConfig, TezosProtocolOptions, TezosFAProtocolConfig, TezosFA2ProtocolConfig, TezosBTCProtocolConfig, TezosETHtzProtocolConfig as TezosETHProtocolConfig, TezosWrappedProtocolConfig, TezosKolibriUSDProtocolConfig, TezosStakerProtocolConfig, TezosUSDProtocolConfig, TezosFAProtocolOptions, TezosFA2ProtocolOptions, TezosNetwork, TezosUtils, TezosWrappedOperation, RawTezosTransaction };\nexport { IACMessageType, IACMessageDefinitionObject, AccountShareResponse, MessageSignRequest, MessageSignResponse, SignedTransaction, UnsignedTransaction, UnsignedAeternityTransaction, UnsignedBitcoinTransaction, UnsignedCosmosTransaction, UnsignedEthereumTransaction, UnsignedTezosTransaction, SignedAeternityTransaction, SignedBitcoinTransaction, SignedCosmosTransaction, SignedEthereumTransaction, SignedTezosTransaction, IACPayloadType, Serializer, DeserializedSyncProtocol, EncodedType, SyncProtocolUtils, Message, SerializedAirGapWallet };\nexport { Action, RepeatableAction, LinkedAction, SimpleAction, ImportAccountAction, ImportAccoutActionContext };\nexport { isNetworkEqual, getProtocolOptionsByIdentifier, addSupportedProtocol, getProtocolByIdentifier, getSubProtocolsByIdentifier, supportedProtocols, TypeNotSupported, SerializerVersionMismatch, ProtocolNotSupported, ProtocolVersionMismatch, isCoinlibReady, addSubProtocol, generateId, TimeInterval, DelegateeDetails, DelegatorAction, DelegatorDetails, DelegatorReward, IAirGapSignedTransaction, IAirGapTransactionResult, AirGapWalletPriceService, IProtocolTransactionCursor, SubProtocolType, assertNever };\n"},{name:"@airgap/coinlib-core/networks.d.ts",dts:"interface Bip32 {\n    public: number;\n    private: number;\n}\nexport interface Network {\n    messagePrefix?: string;\n    bip32: Bip32;\n    pubKeyHash: number;\n    scriptHash?: number;\n    wif: number;\n    dustSoftThreshold?: number;\n    dustThreshold?: number;\n    feePerKb?: number;\n    ethereum?: boolean;\n}\ndeclare const networks: {\n    [key: string]: Network;\n};\nexport { networks };\n"}],c=Object(o.lazy)((function(){return Promise.all([t.e(0),t.e(55)]).then(t.bind(null,525))}));n.a=function(e){var n,t=Object(s.a)().isDarkTheme;return i.a.createElement(o.Suspense,{fallback:i.a.createElement("div",null,"Loading")},i.a.createElement(c,Object(r.a)({},e,{editorWillMount:function(t){n=t,t.editor.defineTheme("vs-dark",{base:"vs-dark",inherit:!0,rules:[{background:"121212"}],colors:{"editor.background":"#121212"}}),t.languages.typescript.typescriptDefaults.setCompilerOptions({target:t.languages.typescript.ScriptTarget.ES2017,allowNonTsExtensions:!0,moduleResolution:t.languages.typescript.ModuleResolutionKind.NodeJs,module:t.languages.typescript.ModuleKind.ESNext,typeRoots:["node_modules/@types"]}),a.forEach((function(e){var n="file:///node_modules/"+e.name;t.languages.typescript.typescriptDefaults.addExtraLib(e.dts,n)})),e.editorWillMount&&e.editorWillMount(t)},editorDidMount:function(t){t.setModel(n.editor.createModel(e.value,"typescript",n.Uri.parse("file:///main-"+Math.random()+".ts")))},theme:t?"vs-dark":"vs-light"})))}},325:function(e,n){function t(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}t.keys=function(){return[]},t.resolve=t,e.exports=t,t.id=325},326:function(e,n){},356:function(e,n,t){"use strict";(function(e){var r=t(357),o=t(358),i=t(359);function s(){return c.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(e,n){if(s()<n)throw new RangeError("Invalid typed array length");return c.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(n)).__proto__=c.prototype:(null===e&&(e=new c(n)),e.length=n),e}function c(e,n,t){if(!(c.TYPED_ARRAY_SUPPORT||this instanceof c))return new c(e,n,t);if("number"==typeof e){if("string"==typeof n)throw new Error("If encoding is specified then the first argument must be a string");return p(this,e)}return l(this,e,n,t)}function l(e,n,t,r){if("number"==typeof n)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&n instanceof ArrayBuffer?function(e,n,t,r){if(n.byteLength,t<0||n.byteLength<t)throw new RangeError("'offset' is out of bounds");if(n.byteLength<t+(r||0))throw new RangeError("'length' is out of bounds");n=void 0===t&&void 0===r?new Uint8Array(n):void 0===r?new Uint8Array(n,t):new Uint8Array(n,t,r);c.TYPED_ARRAY_SUPPORT?(e=n).__proto__=c.prototype:e=m(e,n);return e}(e,n,t,r):"string"==typeof n?function(e,n,t){"string"==typeof t&&""!==t||(t="utf8");if(!c.isEncoding(t))throw new TypeError('"encoding" must be a valid string encoding');var r=0|g(n,t),o=(e=a(e,r)).write(n,t);o!==r&&(e=e.slice(0,o));return e}(e,n,t):function(e,n){if(c.isBuffer(n)){var t=0|u(n.length);return 0===(e=a(e,t)).length||n.copy(e,0,0,t),e}if(n){if("undefined"!=typeof ArrayBuffer&&n.buffer instanceof ArrayBuffer||"length"in n)return"number"!=typeof n.length||(r=n.length)!=r?a(e,0):m(e,n);if("Buffer"===n.type&&i(n.data))return m(e,n.data)}var r;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,n)}function d(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function p(e,n){if(d(n),e=a(e,n<0?0:0|u(n)),!c.TYPED_ARRAY_SUPPORT)for(var t=0;t<n;++t)e[t]=0;return e}function m(e,n){var t=n.length<0?0:0|u(n.length);e=a(e,t);for(var r=0;r<t;r+=1)e[r]=255&n[r];return e}function u(e){if(e>=s())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s().toString(16)+" bytes");return 0|e}function g(e,n){if(c.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var t=e.length;if(0===t)return 0;for(var r=!1;;)switch(n){case"ascii":case"latin1":case"binary":return t;case"utf8":case"utf-8":case void 0:return U(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*t;case"hex":return t>>>1;case"base64":return V(e).length;default:if(r)return U(e).length;n=(""+n).toLowerCase(),r=!0}}function f(e,n,t){var r=!1;if((void 0===n||n<0)&&(n=0),n>this.length)return"";if((void 0===t||t>this.length)&&(t=this.length),t<=0)return"";if((t>>>=0)<=(n>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return I(this,n,t);case"utf8":case"utf-8":return k(this,n,t);case"ascii":return L(this,n,t);case"latin1":case"binary":return N(this,n,t);case"base64":return x(this,n,t);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return z(this,n,t);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0}}function y(e,n,t){var r=e[n];e[n]=e[t],e[t]=r}function b(e,n,t,r,o){if(0===e.length)return-1;if("string"==typeof t?(r=t,t=0):t>2147483647?t=2147483647:t<-2147483648&&(t=-2147483648),t=+t,isNaN(t)&&(t=o?0:e.length-1),t<0&&(t=e.length+t),t>=e.length){if(o)return-1;t=e.length-1}else if(t<0){if(!o)return-1;t=0}if("string"==typeof n&&(n=c.from(n,r)),c.isBuffer(n))return 0===n.length?-1:S(e,n,t,r,o);if("number"==typeof n)return n&=255,c.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(e,n,t):Uint8Array.prototype.lastIndexOf.call(e,n,t):S(e,[n],t,r,o);throw new TypeError("val must be string, number or Buffer")}function S(e,n,t,r,o){var i,s=1,a=e.length,c=n.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||n.length<2)return-1;s=2,a/=2,c/=2,t/=2}function l(e,n){return 1===s?e[n]:e.readUInt16BE(n*s)}if(o){var d=-1;for(i=t;i<a;i++)if(l(e,i)===l(n,-1===d?0:i-d)){if(-1===d&&(d=i),i-d+1===c)return d*s}else-1!==d&&(i-=i-d),d=-1}else for(t+c>a&&(t=a-c),i=t;i>=0;i--){for(var p=!0,m=0;m<c;m++)if(l(e,i+m)!==l(n,m)){p=!1;break}if(p)return i}return-1}function T(e,n,t,r){t=Number(t)||0;var o=e.length-t;r?(r=Number(r))>o&&(r=o):r=o;var i=n.length;if(i%2!=0)throw new TypeError("Invalid hex string");r>i/2&&(r=i/2);for(var s=0;s<r;++s){var a=parseInt(n.substr(2*s,2),16);if(isNaN(a))return s;e[t+s]=a}return s}function C(e,n,t,r){return G(U(n,e.length-t),e,t,r)}function P(e,n,t,r){return G(function(e){for(var n=[],t=0;t<e.length;++t)n.push(255&e.charCodeAt(t));return n}(n),e,t,r)}function A(e,n,t,r){return P(e,n,t,r)}function E(e,n,t,r){return G(V(n),e,t,r)}function h(e,n,t,r){return G(function(e,n){for(var t,r,o,i=[],s=0;s<e.length&&!((n-=2)<0);++s)r=(t=e.charCodeAt(s))>>8,o=t%256,i.push(o),i.push(r);return i}(n,e.length-t),e,t,r)}function x(e,n,t){return 0===n&&t===e.length?r.fromByteArray(e):r.fromByteArray(e.slice(n,t))}function k(e,n,t){t=Math.min(e.length,t);for(var r=[],o=n;o<t;){var i,s,a,c,l=e[o],d=null,p=l>239?4:l>223?3:l>191?2:1;if(o+p<=t)switch(p){case 1:l<128&&(d=l);break;case 2:128==(192&(i=e[o+1]))&&(c=(31&l)<<6|63&i)>127&&(d=c);break;case 3:i=e[o+1],s=e[o+2],128==(192&i)&&128==(192&s)&&(c=(15&l)<<12|(63&i)<<6|63&s)>2047&&(c<55296||c>57343)&&(d=c);break;case 4:i=e[o+1],s=e[o+2],a=e[o+3],128==(192&i)&&128==(192&s)&&128==(192&a)&&(c=(15&l)<<18|(63&i)<<12|(63&s)<<6|63&a)>65535&&c<1114112&&(d=c)}null===d?(d=65533,p=1):d>65535&&(d-=65536,r.push(d>>>10&1023|55296),d=56320|1023&d),r.push(d),o+=p}return function(e){var n=e.length;if(n<=v)return String.fromCharCode.apply(String,e);var t="",r=0;for(;r<n;)t+=String.fromCharCode.apply(String,e.slice(r,r+=v));return t}(r)}n.Buffer=c,n.SlowBuffer=function(e){+e!=e&&(e=0);return c.alloc(+e)},n.INSPECT_MAX_BYTES=50,c.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(n){return!1}}(),n.kMaxLength=s(),c.poolSize=8192,c._augment=function(e){return e.__proto__=c.prototype,e},c.from=function(e,n,t){return l(null,e,n,t)},c.TYPED_ARRAY_SUPPORT&&(c.prototype.__proto__=Uint8Array.prototype,c.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&c[Symbol.species]===c&&Object.defineProperty(c,Symbol.species,{value:null,configurable:!0})),c.alloc=function(e,n,t){return function(e,n,t,r){return d(n),n<=0?a(e,n):void 0!==t?"string"==typeof r?a(e,n).fill(t,r):a(e,n).fill(t):a(e,n)}(null,e,n,t)},c.allocUnsafe=function(e){return p(null,e)},c.allocUnsafeSlow=function(e){return p(null,e)},c.isBuffer=function(e){return!(null==e||!e._isBuffer)},c.compare=function(e,n){if(!c.isBuffer(e)||!c.isBuffer(n))throw new TypeError("Arguments must be Buffers");if(e===n)return 0;for(var t=e.length,r=n.length,o=0,i=Math.min(t,r);o<i;++o)if(e[o]!==n[o]){t=e[o],r=n[o];break}return t<r?-1:r<t?1:0},c.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},c.concat=function(e,n){if(!i(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return c.alloc(0);var t;if(void 0===n)for(n=0,t=0;t<e.length;++t)n+=e[t].length;var r=c.allocUnsafe(n),o=0;for(t=0;t<e.length;++t){var s=e[t];if(!c.isBuffer(s))throw new TypeError('"list" argument must be an Array of Buffers');s.copy(r,o),o+=s.length}return r},c.byteLength=g,c.prototype._isBuffer=!0,c.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var n=0;n<e;n+=2)y(this,n,n+1);return this},c.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var n=0;n<e;n+=4)y(this,n,n+3),y(this,n+1,n+2);return this},c.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var n=0;n<e;n+=8)y(this,n,n+7),y(this,n+1,n+6),y(this,n+2,n+5),y(this,n+3,n+4);return this},c.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?k(this,0,e):f.apply(this,arguments)},c.prototype.equals=function(e){if(!c.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===c.compare(this,e)},c.prototype.inspect=function(){var e="",t=n.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,t).match(/.{2}/g).join(" "),this.length>t&&(e+=" ... ")),"<Buffer "+e+">"},c.prototype.compare=function(e,n,t,r,o){if(!c.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===n&&(n=0),void 0===t&&(t=e?e.length:0),void 0===r&&(r=0),void 0===o&&(o=this.length),n<0||t>e.length||r<0||o>this.length)throw new RangeError("out of range index");if(r>=o&&n>=t)return 0;if(r>=o)return-1;if(n>=t)return 1;if(this===e)return 0;for(var i=(o>>>=0)-(r>>>=0),s=(t>>>=0)-(n>>>=0),a=Math.min(i,s),l=this.slice(r,o),d=e.slice(n,t),p=0;p<a;++p)if(l[p]!==d[p]){i=l[p],s=d[p];break}return i<s?-1:s<i?1:0},c.prototype.includes=function(e,n,t){return-1!==this.indexOf(e,n,t)},c.prototype.indexOf=function(e,n,t){return b(this,e,n,t,!0)},c.prototype.lastIndexOf=function(e,n,t){return b(this,e,n,t,!1)},c.prototype.write=function(e,n,t,r){if(void 0===n)r="utf8",t=this.length,n=0;else if(void 0===t&&"string"==typeof n)r=n,t=this.length,n=0;else{if(!isFinite(n))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");n|=0,isFinite(t)?(t|=0,void 0===r&&(r="utf8")):(r=t,t=void 0)}var o=this.length-n;if((void 0===t||t>o)&&(t=o),e.length>0&&(t<0||n<0)||n>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");for(var i=!1;;)switch(r){case"hex":return T(this,e,n,t);case"utf8":case"utf-8":return C(this,e,n,t);case"ascii":return P(this,e,n,t);case"latin1":case"binary":return A(this,e,n,t);case"base64":return E(this,e,n,t);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return h(this,e,n,t);default:if(i)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),i=!0}},c.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var v=4096;function L(e,n,t){var r="";t=Math.min(e.length,t);for(var o=n;o<t;++o)r+=String.fromCharCode(127&e[o]);return r}function N(e,n,t){var r="";t=Math.min(e.length,t);for(var o=n;o<t;++o)r+=String.fromCharCode(e[o]);return r}function I(e,n,t){var r=e.length;(!n||n<0)&&(n=0),(!t||t<0||t>r)&&(t=r);for(var o="",i=n;i<t;++i)o+=F(e[i]);return o}function z(e,n,t){for(var r=e.slice(n,t),o="",i=0;i<r.length;i+=2)o+=String.fromCharCode(r[i]+256*r[i+1]);return o}function R(e,n,t){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+n>t)throw new RangeError("Trying to access beyond buffer length")}function D(e,n,t,r,o,i){if(!c.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(n>o||n<i)throw new RangeError('"value" argument is out of bounds');if(t+r>e.length)throw new RangeError("Index out of range")}function w(e,n,t,r){n<0&&(n=65535+n+1);for(var o=0,i=Math.min(e.length-t,2);o<i;++o)e[t+o]=(n&255<<8*(r?o:1-o))>>>8*(r?o:1-o)}function B(e,n,t,r){n<0&&(n=4294967295+n+1);for(var o=0,i=Math.min(e.length-t,4);o<i;++o)e[t+o]=n>>>8*(r?o:3-o)&255}function M(e,n,t,r,o,i){if(t+r>e.length)throw new RangeError("Index out of range");if(t<0)throw new RangeError("Index out of range")}function O(e,n,t,r,i){return i||M(e,0,t,4),o.write(e,n,t,r,23,4),t+4}function _(e,n,t,r,i){return i||M(e,0,t,8),o.write(e,n,t,r,52,8),t+8}c.prototype.slice=function(e,n){var t,r=this.length;if((e=~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),(n=void 0===n?r:~~n)<0?(n+=r)<0&&(n=0):n>r&&(n=r),n<e&&(n=e),c.TYPED_ARRAY_SUPPORT)(t=this.subarray(e,n)).__proto__=c.prototype;else{var o=n-e;t=new c(o,void 0);for(var i=0;i<o;++i)t[i]=this[i+e]}return t},c.prototype.readUIntLE=function(e,n,t){e|=0,n|=0,t||R(e,n,this.length);for(var r=this[e],o=1,i=0;++i<n&&(o*=256);)r+=this[e+i]*o;return r},c.prototype.readUIntBE=function(e,n,t){e|=0,n|=0,t||R(e,n,this.length);for(var r=this[e+--n],o=1;n>0&&(o*=256);)r+=this[e+--n]*o;return r},c.prototype.readUInt8=function(e,n){return n||R(e,1,this.length),this[e]},c.prototype.readUInt16LE=function(e,n){return n||R(e,2,this.length),this[e]|this[e+1]<<8},c.prototype.readUInt16BE=function(e,n){return n||R(e,2,this.length),this[e]<<8|this[e+1]},c.prototype.readUInt32LE=function(e,n){return n||R(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},c.prototype.readUInt32BE=function(e,n){return n||R(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},c.prototype.readIntLE=function(e,n,t){e|=0,n|=0,t||R(e,n,this.length);for(var r=this[e],o=1,i=0;++i<n&&(o*=256);)r+=this[e+i]*o;return r>=(o*=128)&&(r-=Math.pow(2,8*n)),r},c.prototype.readIntBE=function(e,n,t){e|=0,n|=0,t||R(e,n,this.length);for(var r=n,o=1,i=this[e+--r];r>0&&(o*=256);)i+=this[e+--r]*o;return i>=(o*=128)&&(i-=Math.pow(2,8*n)),i},c.prototype.readInt8=function(e,n){return n||R(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},c.prototype.readInt16LE=function(e,n){n||R(e,2,this.length);var t=this[e]|this[e+1]<<8;return 32768&t?4294901760|t:t},c.prototype.readInt16BE=function(e,n){n||R(e,2,this.length);var t=this[e+1]|this[e]<<8;return 32768&t?4294901760|t:t},c.prototype.readInt32LE=function(e,n){return n||R(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},c.prototype.readInt32BE=function(e,n){return n||R(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},c.prototype.readFloatLE=function(e,n){return n||R(e,4,this.length),o.read(this,e,!0,23,4)},c.prototype.readFloatBE=function(e,n){return n||R(e,4,this.length),o.read(this,e,!1,23,4)},c.prototype.readDoubleLE=function(e,n){return n||R(e,8,this.length),o.read(this,e,!0,52,8)},c.prototype.readDoubleBE=function(e,n){return n||R(e,8,this.length),o.read(this,e,!1,52,8)},c.prototype.writeUIntLE=function(e,n,t,r){(e=+e,n|=0,t|=0,r)||D(this,e,n,t,Math.pow(2,8*t)-1,0);var o=1,i=0;for(this[n]=255&e;++i<t&&(o*=256);)this[n+i]=e/o&255;return n+t},c.prototype.writeUIntBE=function(e,n,t,r){(e=+e,n|=0,t|=0,r)||D(this,e,n,t,Math.pow(2,8*t)-1,0);var o=t-1,i=1;for(this[n+o]=255&e;--o>=0&&(i*=256);)this[n+o]=e/i&255;return n+t},c.prototype.writeUInt8=function(e,n,t){return e=+e,n|=0,t||D(this,e,n,1,255,0),c.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[n]=255&e,n+1},c.prototype.writeUInt16LE=function(e,n,t){return e=+e,n|=0,t||D(this,e,n,2,65535,0),c.TYPED_ARRAY_SUPPORT?(this[n]=255&e,this[n+1]=e>>>8):w(this,e,n,!0),n+2},c.prototype.writeUInt16BE=function(e,n,t){return e=+e,n|=0,t||D(this,e,n,2,65535,0),c.TYPED_ARRAY_SUPPORT?(this[n]=e>>>8,this[n+1]=255&e):w(this,e,n,!1),n+2},c.prototype.writeUInt32LE=function(e,n,t){return e=+e,n|=0,t||D(this,e,n,4,4294967295,0),c.TYPED_ARRAY_SUPPORT?(this[n+3]=e>>>24,this[n+2]=e>>>16,this[n+1]=e>>>8,this[n]=255&e):B(this,e,n,!0),n+4},c.prototype.writeUInt32BE=function(e,n,t){return e=+e,n|=0,t||D(this,e,n,4,4294967295,0),c.TYPED_ARRAY_SUPPORT?(this[n]=e>>>24,this[n+1]=e>>>16,this[n+2]=e>>>8,this[n+3]=255&e):B(this,e,n,!1),n+4},c.prototype.writeIntLE=function(e,n,t,r){if(e=+e,n|=0,!r){var o=Math.pow(2,8*t-1);D(this,e,n,t,o-1,-o)}var i=0,s=1,a=0;for(this[n]=255&e;++i<t&&(s*=256);)e<0&&0===a&&0!==this[n+i-1]&&(a=1),this[n+i]=(e/s>>0)-a&255;return n+t},c.prototype.writeIntBE=function(e,n,t,r){if(e=+e,n|=0,!r){var o=Math.pow(2,8*t-1);D(this,e,n,t,o-1,-o)}var i=t-1,s=1,a=0;for(this[n+i]=255&e;--i>=0&&(s*=256);)e<0&&0===a&&0!==this[n+i+1]&&(a=1),this[n+i]=(e/s>>0)-a&255;return n+t},c.prototype.writeInt8=function(e,n,t){return e=+e,n|=0,t||D(this,e,n,1,127,-128),c.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[n]=255&e,n+1},c.prototype.writeInt16LE=function(e,n,t){return e=+e,n|=0,t||D(this,e,n,2,32767,-32768),c.TYPED_ARRAY_SUPPORT?(this[n]=255&e,this[n+1]=e>>>8):w(this,e,n,!0),n+2},c.prototype.writeInt16BE=function(e,n,t){return e=+e,n|=0,t||D(this,e,n,2,32767,-32768),c.TYPED_ARRAY_SUPPORT?(this[n]=e>>>8,this[n+1]=255&e):w(this,e,n,!1),n+2},c.prototype.writeInt32LE=function(e,n,t){return e=+e,n|=0,t||D(this,e,n,4,2147483647,-2147483648),c.TYPED_ARRAY_SUPPORT?(this[n]=255&e,this[n+1]=e>>>8,this[n+2]=e>>>16,this[n+3]=e>>>24):B(this,e,n,!0),n+4},c.prototype.writeInt32BE=function(e,n,t){return e=+e,n|=0,t||D(this,e,n,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),c.TYPED_ARRAY_SUPPORT?(this[n]=e>>>24,this[n+1]=e>>>16,this[n+2]=e>>>8,this[n+3]=255&e):B(this,e,n,!1),n+4},c.prototype.writeFloatLE=function(e,n,t){return O(this,e,n,!0,t)},c.prototype.writeFloatBE=function(e,n,t){return O(this,e,n,!1,t)},c.prototype.writeDoubleLE=function(e,n,t){return _(this,e,n,!0,t)},c.prototype.writeDoubleBE=function(e,n,t){return _(this,e,n,!1,t)},c.prototype.copy=function(e,n,t,r){if(t||(t=0),r||0===r||(r=this.length),n>=e.length&&(n=e.length),n||(n=0),r>0&&r<t&&(r=t),r===t)return 0;if(0===e.length||0===this.length)return 0;if(n<0)throw new RangeError("targetStart out of bounds");if(t<0||t>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-n<r-t&&(r=e.length-n+t);var o,i=r-t;if(this===e&&t<n&&n<r)for(o=i-1;o>=0;--o)e[o+n]=this[o+t];else if(i<1e3||!c.TYPED_ARRAY_SUPPORT)for(o=0;o<i;++o)e[o+n]=this[o+t];else Uint8Array.prototype.set.call(e,this.subarray(t,t+i),n);return i},c.prototype.fill=function(e,n,t,r){if("string"==typeof e){if("string"==typeof n?(r=n,n=0,t=this.length):"string"==typeof t&&(r=t,t=this.length),1===e.length){var o=e.charCodeAt(0);o<256&&(e=o)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!c.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof e&&(e&=255);if(n<0||this.length<n||this.length<t)throw new RangeError("Out of range index");if(t<=n)return this;var i;if(n>>>=0,t=void 0===t?this.length:t>>>0,e||(e=0),"number"==typeof e)for(i=n;i<t;++i)this[i]=e;else{var s=c.isBuffer(e)?e:U(new c(e,r).toString()),a=s.length;for(i=0;i<t-n;++i)this[i+n]=s[i%a]}return this};var K=/[^+\/0-9A-Za-z-_]/g;function F(e){return e<16?"0"+e.toString(16):e.toString(16)}function U(e,n){var t;n=n||1/0;for(var r=e.length,o=null,i=[],s=0;s<r;++s){if((t=e.charCodeAt(s))>55295&&t<57344){if(!o){if(t>56319){(n-=3)>-1&&i.push(239,191,189);continue}if(s+1===r){(n-=3)>-1&&i.push(239,191,189);continue}o=t;continue}if(t<56320){(n-=3)>-1&&i.push(239,191,189),o=t;continue}t=65536+(o-55296<<10|t-56320)}else o&&(n-=3)>-1&&i.push(239,191,189);if(o=null,t<128){if((n-=1)<0)break;i.push(t)}else if(t<2048){if((n-=2)<0)break;i.push(t>>6|192,63&t|128)}else if(t<65536){if((n-=3)<0)break;i.push(t>>12|224,t>>6&63|128,63&t|128)}else{if(!(t<1114112))throw new Error("Invalid code point");if((n-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,63&t|128)}}return i}function V(e){return r.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(K,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function G(e,n,t,r){for(var o=0;o<r&&!(o+t>=n.length||o>=e.length);++o)n[o+t]=e[o];return o}}).call(this,t(24))},357:function(e,n,t){"use strict";n.byteLength=function(e){var n=l(e),t=n[0],r=n[1];return 3*(t+r)/4-r},n.toByteArray=function(e){var n,t,r=l(e),s=r[0],a=r[1],c=new i(function(e,n,t){return 3*(n+t)/4-t}(0,s,a)),d=0,p=a>0?s-4:s;for(t=0;t<p;t+=4)n=o[e.charCodeAt(t)]<<18|o[e.charCodeAt(t+1)]<<12|o[e.charCodeAt(t+2)]<<6|o[e.charCodeAt(t+3)],c[d++]=n>>16&255,c[d++]=n>>8&255,c[d++]=255&n;2===a&&(n=o[e.charCodeAt(t)]<<2|o[e.charCodeAt(t+1)]>>4,c[d++]=255&n);1===a&&(n=o[e.charCodeAt(t)]<<10|o[e.charCodeAt(t+1)]<<4|o[e.charCodeAt(t+2)]>>2,c[d++]=n>>8&255,c[d++]=255&n);return c},n.fromByteArray=function(e){for(var n,t=e.length,o=t%3,i=[],s=16383,a=0,c=t-o;a<c;a+=s)i.push(d(e,a,a+s>c?c:a+s));1===o?(n=e[t-1],i.push(r[n>>2]+r[n<<4&63]+"==")):2===o&&(n=(e[t-2]<<8)+e[t-1],i.push(r[n>>10]+r[n>>4&63]+r[n<<2&63]+"="));return i.join("")};for(var r=[],o=[],i="undefined"!=typeof Uint8Array?Uint8Array:Array,s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0,c=s.length;a<c;++a)r[a]=s[a],o[s.charCodeAt(a)]=a;function l(e){var n=e.length;if(n%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var t=e.indexOf("=");return-1===t&&(t=n),[t,t===n?0:4-t%4]}function d(e,n,t){for(var o,i,s=[],a=n;a<t;a+=3)o=(e[a]<<16&16711680)+(e[a+1]<<8&65280)+(255&e[a+2]),s.push(r[(i=o)>>18&63]+r[i>>12&63]+r[i>>6&63]+r[63&i]);return s.join("")}o["-".charCodeAt(0)]=62,o["_".charCodeAt(0)]=63},358:function(e,n){n.read=function(e,n,t,r,o){var i,s,a=8*o-r-1,c=(1<<a)-1,l=c>>1,d=-7,p=t?o-1:0,m=t?-1:1,u=e[n+p];for(p+=m,i=u&(1<<-d)-1,u>>=-d,d+=a;d>0;i=256*i+e[n+p],p+=m,d-=8);for(s=i&(1<<-d)-1,i>>=-d,d+=r;d>0;s=256*s+e[n+p],p+=m,d-=8);if(0===i)i=1-l;else{if(i===c)return s?NaN:1/0*(u?-1:1);s+=Math.pow(2,r),i-=l}return(u?-1:1)*s*Math.pow(2,i-r)},n.write=function(e,n,t,r,o,i){var s,a,c,l=8*i-o-1,d=(1<<l)-1,p=d>>1,m=23===o?Math.pow(2,-24)-Math.pow(2,-77):0,u=r?0:i-1,g=r?1:-1,f=n<0||0===n&&1/n<0?1:0;for(n=Math.abs(n),isNaN(n)||n===1/0?(a=isNaN(n)?1:0,s=d):(s=Math.floor(Math.log(n)/Math.LN2),n*(c=Math.pow(2,-s))<1&&(s--,c*=2),(n+=s+p>=1?m/c:m*Math.pow(2,1-p))*c>=2&&(s++,c/=2),s+p>=d?(a=0,s=d):s+p>=1?(a=(n*c-1)*Math.pow(2,o),s+=p):(a=n*Math.pow(2,p-1)*Math.pow(2,o),s=0));o>=8;e[t+u]=255&a,u+=g,a/=256,o-=8);for(s=s<<o|a,l+=o;l>0;e[t+u]=255&s,u+=g,s/=256,l-=8);e[t+u-g]|=128*f}},359:function(e,n){var t={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==t.call(e)}},365:function(e,n){},366:function(e,n){},367:function(e,n){},368:function(e,n){},369:function(e,n){},370:function(e,n){},78:function(e,n,t){"use strict";t.r(n),function(e){var r=t(3),o=t(360),i=t(361),s=t.n(i),a=t(0),c=t.n(a),l=t(407),d=t.n(l),p=t(350),m=t(253),u=t(321),g=t(79),f=t.n(g),y=t(302),b=t(303);n.default=function(){if("undefined"==typeof window||void 0===e)return null;var n=new URLSearchParams(window.location.search),t=n.has("code")?atob(n.get("code")):'import { TezosProtocol } from "@airgap/coinlib-core";\n\nconst mnemonic =\n"abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";\n\nconst protocol = new TezosProtocol();\n\nconst publicKey = await protocol.getPublicKeyFromMnemonic(\nmnemonic,\nprotocol.standardDerivationPath\n);\nconst address = await protocol.getAddressFromPublicKey(publicKey);\n\nconsole.log("Address", address);\n',i=Object(a.useState)(t),l=i[0],g=i[1],S=Object(a.useState)(""),T=S[0],C=S[1],P=Object(a.useState)(y.a.INIT),A=P[0],E=P[1],h=Object(m.a)(),x=100,k={xs:{width:h.width,height:200},lg:{width:.6*h.width,height:h.height-x}},v={xs:{width:h.width,height:h.height-x-k.xs.height},lg:{width:(.4-.05)*h.width,height:h.height}},L=function(){var e=Object(o.a)(s.a.mark((function e(){return s.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(A!==y.a.STARTED){e.next=2;break}return e.abrupt("return");case 2:return e.next=4,N();case 4:return E(y.a.STARTED),e.next=7,Object(b.b)(l,C);case 7:E(y.a.ENDED);case 8:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}(),N=function(){var e=Object(o.a)(s.a.mark((function e(){return s.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:C(""),E(y.a.INIT);case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}();return c.a.createElement(p.a,{title:"AirGap",description:"AirGap Playground",noFooter:!0},c.a.createElement("div",{className:d()(f.a.runbox)},c.a.createElement("button",{onClick:L,className:"button button--primary margin-bottom--lg margin-right--xs"},"Run Code"),c.a.createElement("button",{onClick:N,className:"button button--secondary margin-bottom--lg margin-right--xs"},"Clear Output"),c.a.createElement("button",{onClick:function(){Object(b.a)(l)},className:"button button--secondary margin-bottom--lg margin-right--xs"},"Share Code (Copy to Clipboard)")),c.a.createElement("div",{className:d()(f.a.row)},c.a.createElement(u.a,Object(r.a)({},h.width>600?k.lg:k.xs,{language:"typescript",value:l,onChange:function(e){g(e)},options:{minimap:{enabled:!1},wordWrap:"on"}})),c.a.createElement(u.a,Object(r.a)({},h.width>600?v.lg:v.xs,{language:"bash",value:T,options:{readOnly:!0,minimap:{enabled:!1},wordWrap:"on"}}))))}}.call(this,t(356).Buffer)}}]);